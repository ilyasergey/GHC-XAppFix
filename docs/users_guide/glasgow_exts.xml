<?xml version="1.0" encoding="iso-8859-1"?>
<para>
<indexterm><primary>language, GHC</primary></indexterm>
<indexterm><primary>extensions, GHC</primary></indexterm>
As with all known Haskell systems, GHC implements some extensions to
the language.  They can all be enabled or disabled by commandline flags
or language pragmas. By default GHC understands the most recent Haskell
version it supports, plus a handful of extensions.
</para>

<para>
Some of the Glasgow extensions serve to give you access to the
underlying facilities with which we implement Haskell.  Thus, you can
get at the Raw Iron, if you are willing to write some non-portable
code at a more primitive level.  You need not be &ldquo;stuck&rdquo;
on performance because of the implementation costs of Haskell's
&ldquo;high-level&rdquo; features&mdash;you can always code
&ldquo;under&rdquo; them.  In an extreme case, you can write all your
time-critical code in C, and then just glue it together with Haskell!
</para>

<para>
Before you get too carried away working at the lowest level (e.g.,
sloshing <literal>MutableByteArray&num;</literal>s around your
program), you may wish to check if there are libraries that provide a
&ldquo;Haskellised veneer&rdquo; over the features you want.  The
separate <ulink url="../libraries/index.html">libraries
documentation</ulink> describes all the libraries that come with GHC.
</para>

<!-- LANGUAGE OPTIONS -->
  <sect1 id="options-language">
    <title>Language options</title>

    <indexterm><primary>language</primary><secondary>option</secondary>
    </indexterm>
    <indexterm><primary>options</primary><secondary>language</secondary>
    </indexterm>
    <indexterm><primary>extensions</primary><secondary>options controlling</secondary>
    </indexterm>

    <para>The language option flags control what variation of the language are
    permitted.</para>

    <para>Language options can be controlled in two ways:
    <itemizedlist>
      <listitem><para>Every language option can switched on by a command-line flag "<option>-X...</option>"
        (e.g. <option>-XTemplateHaskell</option>), and switched off by the flag "<option>-XNo...</option>";
        (e.g. <option>-XNoTemplateHaskell</option>).</para></listitem>
      <listitem><para>
          Language options recognised by Cabal can also be enabled using the <literal>LANGUAGE</literal> pragma,
          thus <literal>{-# LANGUAGE TemplateHaskell #-}</literal> (see <xref linkend="language-pragma"/>). </para>
          </listitem>
      </itemizedlist></para>

    <para>The flag <option>-fglasgow-exts</option>
          <indexterm><primary><option>-fglasgow-exts</option></primary></indexterm>
	  is equivalent to enabling the following extensions:
          &what_glasgow_exts_does;
	    Enabling these options is the <emphasis>only</emphasis>
	    effect of <option>-fglasgow-exts</option>.
          We are trying to move away from this portmanteau flag,
	  and towards enabling features individually.</para>

  </sect1>

<!-- UNBOXED TYPES AND PRIMITIVE OPERATIONS -->
<sect1 id="primitives">
  <title>Unboxed types and primitive operations</title>

<para>GHC is built on a raft of primitive data types and operations;
"primitive" in the sense that they cannot be defined in Haskell itself.
While you really can use this stuff to write fast code,
  we generally find it a lot less painful, and more satisfying in the
  long run, to use higher-level language features and libraries.  With
  any luck, the code you write will be optimised to the efficient
  unboxed version in any case.  And if it isn't, we'd like to know
  about it.</para>

<para>All these primitive data types and operations are exported by the
library <literal>GHC.Prim</literal>, for which there is
<ulink url="&libraryGhcPrimLocation;/GHC-Prim.html">detailed online documentation</ulink>.
(This documentation is generated from the file <filename>compiler/prelude/primops.txt.pp</filename>.)
</para>
<para>
If you want to mention any of the primitive data types or operations in your
program, you must first import <literal>GHC.Prim</literal> to bring them
into scope.  Many of them have names ending in "&num;", and to mention such
names you need the <option>-XMagicHash</option> extension (<xref linkend="magic-hash"/>).
</para>

<para>The primops make extensive use of <link linkend="glasgow-unboxed">unboxed types</link>
and <link linkend="unboxed-tuples">unboxed tuples</link>, which
we briefly summarise here. </para>

<sect2 id="glasgow-unboxed">
<title>Unboxed types
</title>

<para>
<indexterm><primary>Unboxed types (Glasgow extension)</primary></indexterm>
</para>

<para>Most types in GHC are <firstterm>boxed</firstterm>, which means
that values of that type are represented by a pointer to a heap
object.  The representation of a Haskell <literal>Int</literal>, for
example, is a two-word heap object.  An <firstterm>unboxed</firstterm>
type, however, is represented by the value itself, no pointers or heap
allocation are involved.
</para>

<para>
Unboxed types correspond to the &ldquo;raw machine&rdquo; types you
would use in C: <literal>Int&num;</literal> (long int),
<literal>Double&num;</literal> (double), <literal>Addr&num;</literal>
(void *), etc.  The <emphasis>primitive operations</emphasis>
(PrimOps) on these types are what you might expect; e.g.,
<literal>(+&num;)</literal> is addition on
<literal>Int&num;</literal>s, and is the machine-addition that we all
know and love&mdash;usually one instruction.
</para>

<para>
Primitive (unboxed) types cannot be defined in Haskell, and are
therefore built into the language and compiler.  Primitive types are
always unlifted; that is, a value of a primitive type cannot be
bottom.  We use the convention (but it is only a convention)
that primitive types, values, and
operations have a <literal>&num;</literal> suffix (see <xref linkend="magic-hash"/>).
For some primitive types we have special syntax for literals, also
described in the <link linkend="magic-hash">same section</link>.
</para>

<para>
Primitive values are often represented by a simple bit-pattern, such
as <literal>Int&num;</literal>, <literal>Float&num;</literal>,
<literal>Double&num;</literal>.  But this is not necessarily the case:
a primitive value might be represented by a pointer to a
heap-allocated object.  Examples include
<literal>Array&num;</literal>, the type of primitive arrays.  A
primitive array is heap-allocated because it is too big a value to fit
in a register, and would be too expensive to copy around; in a sense,
it is accidental that it is represented by a pointer.  If a pointer
represents a primitive value, then it really does point to that value:
no unevaluated thunks, no indirections&hellip;nothing can be at the
other end of the pointer than the primitive value.
A numerically-intensive program using unboxed types can
go a <emphasis>lot</emphasis> faster than its &ldquo;standard&rdquo;
counterpart&mdash;we saw a threefold speedup on one example.
</para>

<para>
There are some restrictions on the use of primitive types:
<itemizedlist>
<listitem><para>The main restriction
is that you can't pass a primitive value to a polymorphic
function or store one in a polymorphic data type.  This rules out
things like <literal>[Int&num;]</literal> (i.e. lists of primitive
integers).  The reason for this restriction is that polymorphic
arguments and constructor fields are assumed to be pointers: if an
unboxed integer is stored in one of these, the garbage collector would
attempt to follow it, leading to unpredictable space leaks.  Or a
<function>seq</function> operation on the polymorphic component may
attempt to dereference the pointer, with disastrous results.  Even
worse, the unboxed value might be larger than a pointer
(<literal>Double&num;</literal> for instance).
</para>
</listitem>
<listitem><para> You cannot define a newtype whose representation type
(the argument type of the data constructor) is an unboxed type.  Thus,
this is illegal:
<programlisting>
  newtype A = MkA Int#
</programlisting>
</para></listitem>
<listitem><para> You cannot bind a variable with an unboxed type
in a <emphasis>top-level</emphasis> binding.
</para></listitem>
<listitem><para> You cannot bind a variable with an unboxed type
in a <emphasis>recursive</emphasis> binding.
</para></listitem>
<listitem><para> You may bind unboxed variables in a (non-recursive,
non-top-level) pattern binding, but you must make any such pattern-match
strict.  For example, rather than:
<programlisting>
  data Foo = Foo Int Int#

  f x = let (Foo a b, w) = ..rhs.. in ..body..
</programlisting>
you must write:
<programlisting>
  data Foo = Foo Int Int#

  f x = let !(Foo a b, w) = ..rhs.. in ..body..
</programlisting>
since <literal>b</literal> has type <literal>Int#</literal>.
</para>
</listitem>
</itemizedlist>
</para>

</sect2>

<sect2 id="unboxed-tuples">
<title>Unboxed Tuples
</title>

<para>
Unboxed tuples aren't really exported by <literal>GHC.Exts</literal>;
they are a syntactic extension enabled by the language flag <option>-XUnboxedTuples</option>.  An
unboxed tuple looks like this:
</para>

<para>

<programlisting>
(# e_1, ..., e_n #)
</programlisting>

</para>

<para>
where <literal>e&lowbar;1..e&lowbar;n</literal> are expressions of any
type (primitive or non-primitive).  The type of an unboxed tuple looks
the same.
</para>

<para>
Unboxed tuples are used for functions that need to return multiple
values, but they avoid the heap allocation normally associated with
using fully-fledged tuples.  When an unboxed tuple is returned, the
components are put directly into registers or on the stack; the
unboxed tuple itself does not have a composite representation.  Many
of the primitive operations listed in <literal>primops.txt.pp</literal> return unboxed
tuples.
In particular, the <literal>IO</literal> and <literal>ST</literal> monads use unboxed
tuples to avoid unnecessary allocation during sequences of operations.
</para>

<para>
There are some pretty stringent restrictions on the use of unboxed tuples:
<itemizedlist>
<listitem>

<para>
Values of unboxed tuple types are subject to the same restrictions as
other unboxed types; i.e. they may not be stored in polymorphic data
structures or passed to polymorphic functions.

</para>
</listitem>
<listitem>

<para>
No variable can have an unboxed tuple type, nor may a constructor or function
argument have an unboxed tuple type.  The following are all illegal:
<programlisting>
  data Foo = Foo (# Int, Int #)

  f :: (# Int, Int #) -&#62; (# Int, Int #)
  f x = x

  g :: (# Int, Int #) -&#62; Int
  g (# a,b #) = a

  h x = let y = (# x,x #) in ...
</programlisting>
</para>
</listitem>
<listitem>
<para>
Unboxed tuples may not be nested. So this is illegal:
<programlisting>
f :: (# Int, (# Int, Int #), Bool #)
</programlisting>
</para>
</listitem>
</itemizedlist>
</para>
<para>
The typical use of unboxed tuples is simply to return multiple values,
binding those multiple results with a <literal>case</literal> expression, thus:
<programlisting>
  f x y = (# x+1, y-1 #)
  g x = case f x x of { (# a, b #) -&#62; a + b }
</programlisting>
You can have an unboxed tuple in a pattern binding, thus
<programlisting>
  f x = let (# p,q #) = h x in ..body..
</programlisting>
If the types of <literal>p</literal> and <literal>q</literal> are not unboxed,
the resulting binding is lazy like any other Haskell pattern binding.  The
above example desugars like this:
<programlisting>
  f x = let t = case h x o f{ (# p,q #) -> (p,q)
            p = fst t
            q = snd t
        in ..body..
</programlisting>
Indeed, the bindings can even be recursive.
</para>

</sect2>
</sect1>


<!-- ====================== SYNTACTIC EXTENSIONS =======================  -->

<sect1 id="syntax-extns">
<title>Syntactic extensions</title>

    <sect2 id="unicode-syntax">
      <title>Unicode syntax</title>
      <para>The language
      extension <option>-XUnicodeSyntax</option><indexterm><primary><option>-XUnicodeSyntax</option></primary></indexterm>
      enables Unicode characters to be used to stand for certain ASCII
      character sequences.  The following alternatives are provided:</para>

      <informaltable>
	<tgroup cols="2" align="left" colsep="1" rowsep="1">
	  <thead>
	    <row>
	      <entry>ASCII</entry>
              <entry>Unicode alternative</entry>
	      <entry>Code point</entry>
	      <entry>Name</entry>
	    </row>
	  </thead>

<!--
               to find the DocBook entities for these characters, find
               the Unicode code point (e.g. 0x2237), and grep for it in
               /usr/share/sgml/docbook/xml-dtd-*/ent/* (or equivalent on
               your system.  Some of these Unicode code points don't have
               equivalent DocBook entities.
            -->

	  <tbody>
	    <row>
	      <entry><literal>::</literal></entry>
	      <entry>::</entry> <!-- no special char, apparently -->
              <entry>0x2237</entry>
	      <entry>PROPORTION</entry>
	    </row>
          </tbody>
	  <tbody>
	    <row>
	      <entry><literal>=&gt;</literal></entry>
	      <entry>&rArr;</entry>
	      <entry>0x21D2</entry>
              <entry>RIGHTWARDS DOUBLE ARROW</entry>
	    </row>
          </tbody>
	  <tbody>
	    <row>
	      <entry><literal>forall</literal></entry>
	      <entry>&forall;</entry>
	      <entry>0x2200</entry>
              <entry>FOR ALL</entry>
	    </row>
          </tbody>
	  <tbody>
	    <row>
	      <entry><literal>-&gt;</literal></entry>
	      <entry>&rarr;</entry>
	      <entry>0x2192</entry>
              <entry>RIGHTWARDS ARROW</entry>
	    </row>
          </tbody>
	  <tbody>
	    <row>
	      <entry><literal>&lt;-</literal></entry>
	      <entry>&larr;</entry>
	      <entry>0x2190</entry>
              <entry>LEFTWARDS ARROW</entry>
	    </row>
          </tbody>

	  <tbody>
	    <row>
	      <entry>-&lt;</entry>
	      <entry>&larrtl;</entry>
	      <entry>0x2919</entry>
	      <entry>LEFTWARDS ARROW-TAIL</entry>
	    </row>
          </tbody>

	  <tbody>
	    <row>
	      <entry>&gt;-</entry>
	      <entry>&rarrtl;</entry>
	      <entry>0x291A</entry>
	      <entry>RIGHTWARDS ARROW-TAIL</entry>
	    </row>
          </tbody>

	  <tbody>
	    <row>
	      <entry>-&lt;&lt;</entry>
	      <entry></entry>
	      <entry>0x291B</entry>
	      <entry>LEFTWARDS DOUBLE ARROW-TAIL</entry>
	    </row>
          </tbody>

	  <tbody>
	    <row>
	      <entry>&gt;&gt;-</entry>
	      <entry></entry>
	      <entry>0x291C</entry>
	      <entry>RIGHTWARDS DOUBLE ARROW-TAIL</entry>
	    </row>
          </tbody>

	  <tbody>
	    <row>
	      <entry>*</entry>
	      <entry>&starf;</entry>
	      <entry>0x2605</entry>
	      <entry>BLACK STAR</entry>
	    </row>
          </tbody>

        </tgroup>
      </informaltable>
    </sect2>

    <sect2 id="magic-hash">
      <title>The magic hash</title>
      <para>The language extension <option>-XMagicHash</option> allows "&num;" as a
	postfix modifier to identifiers.  Thus, "x&num;" is a valid variable, and "T&num;" is
	a valid type constructor or data constructor.</para>

      <para>The hash sign does not change semantics at all.  We tend to use variable
	names ending in "&num;" for unboxed values or types (e.g. <literal>Int&num;</literal>),
        but there is no requirement to do so; they are just plain ordinary variables.
	Nor does the <option>-XMagicHash</option> extension bring anything into scope.
	For example, to bring <literal>Int&num;</literal> into scope you must
	import <literal>GHC.Prim</literal> (see <xref linkend="primitives"/>);
	the <option>-XMagicHash</option> extension
	then allows you to <emphasis>refer</emphasis> to the <literal>Int&num;</literal>
	that is now in scope.</para>
      <para> The <option>-XMagicHash</option> also enables some new forms of literals (see <xref linkend="glasgow-unboxed"/>):
	<itemizedlist>
	  <listitem><para> <literal>'x'&num;</literal> has type <literal>Char&num;</literal></para> </listitem>
	  <listitem><para> <literal>&quot;foo&quot;&num;</literal> has type <literal>Addr&num;</literal></para> </listitem>
	  <listitem><para> <literal>3&num;</literal> has type <literal>Int&num;</literal>. In general,
	  any Haskell integer lexeme followed by a <literal>&num;</literal> is an <literal>Int&num;</literal> literal, e.g.
            <literal>-0x3A&num;</literal> as well as <literal>32&num;</literal></para>.</listitem>
	  <listitem><para> <literal>3&num;&num;</literal> has type <literal>Word&num;</literal>. In general,
	  any non-negative Haskell integer lexeme followed by <literal>&num;&num;</literal>
	      is a <literal>Word&num;</literal>. </para> </listitem>
	  <listitem><para> <literal>3.2&num;</literal> has type <literal>Float&num;</literal>.</para> </listitem>
	  <listitem><para> <literal>3.2&num;&num;</literal> has type <literal>Double&num;</literal></para> </listitem>
	  </itemizedlist>
      </para>
   </sect2>

    <!-- ====================== HIERARCHICAL MODULES =======================  -->


    <sect2 id="hierarchical-modules">
      <title>Hierarchical Modules</title>

      <para>GHC supports a small extension to the syntax of module
      names: a module name is allowed to contain a dot
      <literal>&lsquo;.&rsquo;</literal>.  This is also known as the
      &ldquo;hierarchical module namespace&rdquo; extension, because
      it extends the normally flat Haskell module namespace into a
      more flexible hierarchy of modules.</para>

      <para>This extension has very little impact on the language
      itself; modules names are <emphasis>always</emphasis> fully
      qualified, so you can just think of the fully qualified module
      name as <quote>the module name</quote>.  In particular, this
      means that the full module name must be given after the
      <literal>module</literal> keyword at the beginning of the
      module; for example, the module <literal>A.B.C</literal> must
      begin</para>

<programlisting>module A.B.C</programlisting>


      <para>It is a common strategy to use the <literal>as</literal>
      keyword to save some typing when using qualified names with
      hierarchical modules.  For example:</para>

<programlisting>
import qualified Control.Monad.ST.Strict as ST
</programlisting>

      <para>For details on how GHC searches for source and interface
      files in the presence of hierarchical modules, see <xref
      linkend="search-path"/>.</para>

      <para>GHC comes with a large collection of libraries arranged
      hierarchically; see the accompanying <ulink
      url="../libraries/index.html">library
      documentation</ulink>.  More libraries to install are available
      from <ulink
      url="http://hackage.haskell.org/packages/hackage.html">HackageDB</ulink>.</para>
    </sect2>

    <!-- ====================== PATTERN GUARDS =======================  -->

<sect2 id="pattern-guards">
<title>Pattern guards</title>

<para>
<indexterm><primary>Pattern guards (Glasgow extension)</primary></indexterm>
The discussion that follows is an abbreviated version of Simon Peyton Jones's original <ulink url="http://research.microsoft.com/~simonpj/Haskell/guards.html">proposal</ulink>. (Note that the proposal was written before pattern guards were implemented, so refers to them as unimplemented.)
</para>

<para>
Suppose we have an abstract data type of finite maps, with a
lookup operation:

<programlisting>
lookup :: FiniteMap -> Int -> Maybe Int
</programlisting>

The lookup returns <function>Nothing</function> if the supplied key is not in the domain of the mapping, and <function>(Just v)</function> otherwise,
where <varname>v</varname> is the value that the key maps to.  Now consider the following definition:
</para>

<programlisting>
clunky env var1 var2 | ok1 &amp;&amp; ok2 = val1 + val2
| otherwise  = var1 + var2
where
  m1 = lookup env var1
  m2 = lookup env var2
  ok1 = maybeToBool m1
  ok2 = maybeToBool m2
  val1 = expectJust m1
  val2 = expectJust m2
</programlisting>

<para>
The auxiliary functions are
</para>

<programlisting>
maybeToBool :: Maybe a -&gt; Bool
maybeToBool (Just x) = True
maybeToBool Nothing  = False

expectJust :: Maybe a -&gt; a
expectJust (Just x) = x
expectJust Nothing  = error "Unexpected Nothing"
</programlisting>

<para>
What is <function>clunky</function> doing? The guard <literal>ok1 &amp;&amp;
ok2</literal> checks that both lookups succeed, using
<function>maybeToBool</function> to convert the <function>Maybe</function>
types to booleans. The (lazily evaluated) <function>expectJust</function>
calls extract the values from the results of the lookups, and binds the
returned values to <varname>val1</varname> and <varname>val2</varname>
respectively.  If either lookup fails, then clunky takes the
<literal>otherwise</literal> case and returns the sum of its arguments.
</para>

<para>
This is certainly legal Haskell, but it is a tremendously verbose and
un-obvious way to achieve the desired effect.  Arguably, a more direct way
to write clunky would be to use case expressions:
</para>

<programlisting>
clunky env var1 var2 = case lookup env var1 of
  Nothing -&gt; fail
  Just val1 -&gt; case lookup env var2 of
    Nothing -&gt; fail
    Just val2 -&gt; val1 + val2
where
  fail = var1 + var2
</programlisting>

<para>
This is a bit shorter, but hardly better.  Of course, we can rewrite any set
of pattern-matching, guarded equations as case expressions; that is
precisely what the compiler does when compiling equations! The reason that
Haskell provides guarded equations is because they allow us to write down
the cases we want to consider, one at a time, independently of each other.
This structure is hidden in the case version.  Two of the right-hand sides
are really the same (<function>fail</function>), and the whole expression
tends to become more and more indented.
</para>

<para>
Here is how I would write clunky:
</para>

<programlisting>
clunky env var1 var2
  | Just val1 &lt;- lookup env var1
  , Just val2 &lt;- lookup env var2
  = val1 + val2
...other equations for clunky...
</programlisting>

<para>
The semantics should be clear enough.  The qualifiers are matched in order.
For a <literal>&lt;-</literal> qualifier, which I call a pattern guard, the
right hand side is evaluated and matched against the pattern on the left.
If the match fails then the whole guard fails and the next equation is
tried.  If it succeeds, then the appropriate binding takes place, and the
next qualifier is matched, in the augmented environment.  Unlike list
comprehensions, however, the type of the expression to the right of the
<literal>&lt;-</literal> is the same as the type of the pattern to its
left.  The bindings introduced by pattern guards scope over all the
remaining guard qualifiers, and over the right hand side of the equation.
</para>

<para>
Just as with list comprehensions, boolean expressions can be freely mixed
with among the pattern guards.  For example:
</para>

<programlisting>
f x | [y] &lt;- x
    , y > 3
    , Just z &lt;- h y
    = ...
</programlisting>

<para>
Haskell's current guards therefore emerge as a special case, in which the
qualifier list has just one element, a boolean expression.
</para>
</sect2>

    <!-- ===================== View patterns ===================  -->

<sect2 id="view-patterns">
<title>View patterns
</title>

<para>
View patterns are enabled by the flag <literal>-XViewPatterns</literal>.
More information and examples of view patterns can be found on the
<ulink url="http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns">Wiki
page</ulink>.
</para>

<para>
View patterns are somewhat like pattern guards that can be nested inside
of other patterns.  They are a convenient way of pattern-matching
against values of abstract types. For example, in a programming language
implementation, we might represent the syntax of the types of the
language as follows:

<programlisting>
type Typ

data TypView = Unit
             | Arrow Typ Typ

view :: Type -> TypeView

-- additional operations for constructing Typ's ...
</programlisting>

The representation of Typ is held abstract, permitting implementations
to use a fancy representation (e.g., hash-consing to manage sharing).

Without view patterns, using this signature a little inconvenient:
<programlisting>
size :: Typ -> Integer
size t = case view t of
  Unit -> 1
  Arrow t1 t2 -> size t1 + size t2
</programlisting>

It is necessary to iterate the case, rather than using an equational
function definition. And the situation is even worse when the matching
against <literal>t</literal> is buried deep inside another pattern.
</para>

<para>
View patterns permit calling the view function inside the pattern and
matching against the result:
<programlisting>
size (view -> Unit) = 1
size (view -> Arrow t1 t2) = size t1 + size t2
</programlisting>

That is, we add a new form of pattern, written
<replaceable>expression</replaceable> <literal>-></literal>
<replaceable>pattern</replaceable> that means "apply the expression to
whatever we're trying to match against, and then match the result of
that application against the pattern". The expression can be any Haskell
expression of function type, and view patterns can be used wherever
patterns are used.
</para>

<para>
The semantics of a pattern <literal>(</literal>
<replaceable>exp</replaceable> <literal>-></literal>
<replaceable>pat</replaceable> <literal>)</literal> are as follows:

<itemizedlist>

<listitem> Scoping:

<para>The variables bound by the view pattern are the variables bound by
<replaceable>pat</replaceable>.
</para>

<para>
Any variables in <replaceable>exp</replaceable> are bound occurrences,
but variables bound "to the left" in a pattern are in scope.  This
feature permits, for example, one argument to a function to be used in
the view of another argument.  For example, the function
<literal>clunky</literal> from <xref linkend="pattern-guards" /> can be
written using view patterns as follows:

<programlisting>
clunky env (lookup env -> Just val1) (lookup env -> Just val2) = val1 + val2
...other equations for clunky...
</programlisting>
</para>

<para>
More precisely, the scoping rules are:
<itemizedlist>
<listitem>
<para>
In a single pattern, variables bound by patterns to the left of a view
pattern expression are in scope. For example:
<programlisting>
example :: Maybe ((String -> Integer,Integer), String) -> Bool
example Just ((f,_), f -> 4) = True
</programlisting>

Additionally, in function definitions, variables bound by matching earlier curried
arguments may be used in view pattern expressions in later arguments:
<programlisting>
example :: (String -> Integer) -> String -> Bool
example f (f -> 4) = True
</programlisting>
That is, the scoping is the same as it would be if the curried arguments
were collected into a tuple.
</para>
</listitem>

<listitem>
<para>
In mutually recursive bindings, such as <literal>let</literal>,
<literal>where</literal>, or the top level, view patterns in one
declaration may not mention variables bound by other declarations.  That
is, each declaration must be self-contained.  For example, the following
program is not allowed:
<programlisting>
let {(x -> y) = e1 ;
     (y -> x) = e2 } in x
</programlisting>

(For some amplification on this design choice see
<ulink url="http://hackage.haskell.org/trac/ghc/ticket/4061">Trac #4061</ulink>.)

</para>
</listitem>
</itemizedlist>

</para>
</listitem>

<listitem><para> Typing: If <replaceable>exp</replaceable> has type
<replaceable>T1</replaceable> <literal>-></literal>
<replaceable>T2</replaceable> and <replaceable>pat</replaceable> matches
a <replaceable>T2</replaceable>, then the whole view pattern matches a
<replaceable>T1</replaceable>.
</para></listitem>

<listitem><para> Matching: To the equations in Section 3.17.3 of the
<ulink url="http://www.haskell.org/onlinereport/">Haskell 98
Report</ulink>, add the following:
<programlisting>
case v of { (e -> p) -> e1 ; _ -> e2 }
 =
case (e v) of { p -> e1 ; _ -> e2 }
</programlisting>
That is, to match a variable <replaceable>v</replaceable> against a pattern
<literal>(</literal> <replaceable>exp</replaceable>
<literal>-></literal> <replaceable>pat</replaceable>
<literal>)</literal>, evaluate <literal>(</literal>
<replaceable>exp</replaceable> <replaceable> v</replaceable>
<literal>)</literal> and match the result against
<replaceable>pat</replaceable>.
</para></listitem>

<listitem><para> Efficiency: When the same view function is applied in
multiple branches of a function definition or a case expression (e.g.,
in <literal>size</literal> above), GHC makes an attempt to collect these
applications into a single nested case expression, so that the view
function is only applied once.  Pattern compilation in GHC follows the
matrix algorithm described in Chapter 4 of <ulink
url="http://research.microsoft.com/~simonpj/Papers/slpj-book-1987/">The
Implementation of Functional Programming Languages</ulink>.  When the
top rows of the first column of a matrix are all view patterns with the
"same" expression, these patterns are transformed into a single nested
case.  This includes, for example, adjacent view patterns that line up
in a tuple, as in
<programlisting>
f ((view -> A, p1), p2) = e1
f ((view -> B, p3), p4) = e2
</programlisting>
</para>

<para> The current notion of when two view pattern expressions are "the
same" is very restricted: it is not even full syntactic equality.
However, it does include variables, literals, applications, and tuples;
e.g., two instances of <literal>view ("hi", "there")</literal> will be
collected.  However, the current implementation does not compare up to
alpha-equivalence, so two instances of <literal>(x, view x ->
y)</literal> will not be coalesced.
</para>

</listitem>

</itemizedlist>
</para>

</sect2>

    <!-- ===================== n+k patterns ===================  -->

<sect2 id="n-k-patterns">
<title>n+k patterns</title>
<indexterm><primary><option>-XNPlusKPatterns</option></primary></indexterm>

<para>
<literal>n+k</literal> pattern support is disabled by default. To enable
it, you can use the <option>-XNPlusKPatterns</option> flag.
</para>

</sect2>

    <!-- ===================== Traditional record syntax ===================  -->

<sect2 id="traditional-record-syntax">
<title>Traditional record syntax</title>
<indexterm><primary><option>-XNoTraditionalRecordSyntax</option></primary></indexterm>

<para>
Traditional record syntax, such as <literal>C {f = x}</literal>, is enabled by default.
To disable it, you can use the <option>-XNoTraditionalRecordSyntax</option> flag.
</para>

</sect2>

    <!-- ===================== Recursive do-notation ===================  -->

<sect2 id="recursive-do-notation">
<title>The recursive do-notation
</title>

<para>
The do-notation of Haskell 98 does not allow <emphasis>recursive bindings</emphasis>,
that is, the variables bound in a do-expression are visible only in the textually following
code block. Compare this to a let-expression, where bound variables are visible in the entire binding
group. It turns out that several applications can benefit from recursive bindings in
the do-notation.  The <option>-XDoRec</option> flag provides the necessary syntactic support.
</para>
<para>
Here is a simple (albeit contrived) example:
<programlisting>
{-# LANGUAGE DoRec #-}
justOnes = do { rec { xs &lt;- Just (1:xs) }
              ; return (map negate xs) }
</programlisting>
As you can guess <literal>justOnes</literal> will evaluate to <literal>Just [-1,-1,-1,...</literal>.
</para>
<para>
The background and motivation for recursive do-notation is described in
<ulink url="http://sites.google.com/site/leventerkok/">A recursive do for Haskell</ulink>,
by Levent Erkok, John Launchbury,
Haskell Workshop 2002, pages: 29-37. Pittsburgh, Pennsylvania.
The theory behind monadic value recursion is explained further in Erkok's thesis
<ulink url="http://sites.google.com/site/leventerkok/erkok-thesis.pdf">Value Recursion in Monadic Computations</ulink>.
However, note that GHC uses a different syntax than the one described in these documents.
</para>

<sect3>
<title>Details of recursive do-notation</title>
<para>
The recursive do-notation is enabled with the flag <option>-XDoRec</option> or, equivalently,
the LANGUAGE pragma <option>DoRec</option>.  It introduces the single new keyword "<literal>rec</literal>",
which wraps a mutually-recursive group of monadic statements,
producing a single statement.
</para>
<para>Similar to a <literal>let</literal>
statement, the variables bound in the <literal>rec</literal> are
visible throughout the <literal>rec</literal> group, and below it.
For example, compare
<programlisting>
do { a &lt;- getChar              do { a &lt;- getChar
   ; let { r1 = f a r2	           ; rec { r1 &lt;- f a r2
         ; r2 = g r1 }	                 ; r2 &lt;- g r1 }
   ; return (r1 ++ r2) }          ; return (r1 ++ r2) }
</programlisting>
In both cases, <literal>r1</literal> and <literal>r2</literal> are
available both throughout the <literal>let</literal> or <literal>rec</literal> block, and
in the statements that follow it.  The difference is that <literal>let</literal> is non-monadic,
while <literal>rec</literal> is monadic.  (In Haskell <literal>let</literal> is
really <literal>letrec</literal>, of course.)
</para>
<para>
The static and dynamic semantics of <literal>rec</literal> can be described as follows:
<itemizedlist>
<listitem><para>
First,
similar to let-bindings, the <literal>rec</literal> is broken into
minimal recursive groups, a process known as <emphasis>segmentation</emphasis>.
For example:
<programlisting>
rec { a &lt;- getChar      ===>     a &lt;- getChar
    ; b &lt;- f a c                 rec { b &lt;- f a c
    ; c &lt;- f b a                     ; c &lt;- f b a }
    ; putChar c }                putChar c
</programlisting>
The details of segmentation are described in Section 3.2 of
<ulink url="http://sites.google.com/site/leventerkok/">A recursive do for Haskell</ulink>.
Segmentation improves polymorphism, reduces the size of the recursive "knot", and, as the paper
describes, also has a semantic effect (unless the monad satisfies the right-shrinking law).
</para></listitem>
<listitem><para>
Then each resulting <literal>rec</literal> is desugared, using a call to <literal>Control.Monad.Fix.mfix</literal>.
For example, the <literal>rec</literal> group in the preceding example is desugared like this:
<programlisting>
rec { b &lt;- f a c     ===>    (b,c) &lt;- mfix (\~(b,c) -> do { b &lt;- f a c
    ; c &lt;- f b a }                                        ; c &lt;- f b a
                                                          ; return (b,c) })
</programlisting>
In general, the statement <literal>rec <replaceable>ss</replaceable></literal>
is desugared to the statement
<programlisting>
<replaceable>vs</replaceable> &lt;- mfix (\~<replaceable>vs</replaceable> -&gt; do { <replaceable>ss</replaceable>; return <replaceable>vs</replaceable> })
</programlisting>
where <replaceable>vs</replaceable> is a tuple of the variables bound by <replaceable>ss</replaceable>.
</para><para>
The original <literal>rec</literal> typechecks exactly
when the above desugared version would do so.  For example, this means that
the variables <replaceable>vs</replaceable> are all monomorphic in the statements
following the <literal>rec</literal>, because they are bound by a lambda.
</para>
<para>
The <literal>mfix</literal> function is defined in the <literal>MonadFix</literal>
class, in <literal>Control.Monad.Fix</literal>, thus:
<programlisting>
class Monad m => MonadFix m where
   mfix :: (a -> m a) -> m a
</programlisting>
</para>
</listitem>
</itemizedlist>
</para>
<para>
Here are some other important points in using the recursive-do notation:
<itemizedlist>
<listitem><para>
It is enabled with the flag <literal>-XDoRec</literal>.
</para></listitem>

<listitem><para>
If recursive bindings are required for a monad,
then that monad must be declared an instance of the <literal>MonadFix</literal> class.
</para></listitem>

<listitem><para>
The following instances of <literal>MonadFix</literal> are automatically provided: List, Maybe, IO.
Furthermore, the Control.Monad.ST and Control.Monad.ST.Lazy modules provide the instances of the MonadFix class
for Haskell's internal state monad (strict and lazy, respectively).
</para></listitem>

<listitem><para>
Like <literal>let</literal> and <literal>where</literal> bindings,
name shadowing is not allowed within a <literal>rec</literal>;
that is, all the names bound in a single <literal>rec</literal> must
be distinct (Section 3.3 of the paper).
</para></listitem>
<listitem><para>
It supports rebindable syntax (see <xref linkend="rebindable-syntax"/>).
</para></listitem>
</itemizedlist>
</para>
</sect3>

<sect3 id="mdo-notation"> <title> Mdo-notation (deprecated) </title>

<para> GHC used to support the flag <option>-XRecursiveDo</option>,
which enabled the keyword <literal>mdo</literal>, precisely as described in
<ulink url="http://sites.google.com/site/leventerkok/">A recursive do for Haskell</ulink>,
but this is now deprecated.  Instead of <literal>mdo { Q; e }</literal>, write
<literal>do { rec Q; e }</literal>.
</para>
<para>
Historical note: The old implementation of the mdo-notation (and most
of the existing documents) used the name
<literal>MonadRec</literal> for the class and the corresponding library.
This name is not supported by GHC.
</para>
</sect3>

</sect2>


   <!-- ===================== PARALLEL LIST COMPREHENSIONS ===================  -->

  <sect2 id="parallel-list-comprehensions">
    <title>Parallel List Comprehensions</title>
    <indexterm><primary>list comprehensions</primary><secondary>parallel</secondary>
    </indexterm>
    <indexterm><primary>parallel list comprehensions</primary>
    </indexterm>

    <para>Parallel list comprehensions are a natural extension to list
    comprehensions.  List comprehensions can be thought of as a nice
    syntax for writing maps and filters.  Parallel comprehensions
    extend this to include the zipWith family.</para>

    <para>A parallel list comprehension has multiple independent
    branches of qualifier lists, each separated by a `|' symbol.  For
    example, the following zips together two lists:</para>

<programlisting>
   [ (x, y) | x &lt;- xs | y &lt;- ys ]
</programlisting>

    <para>The behaviour of parallel list comprehensions follows that of
    zip, in that the resulting list will have the same length as the
    shortest branch.</para>

    <para>We can define parallel list comprehensions by translation to
    regular comprehensions.  Here's the basic idea:</para>

    <para>Given a parallel comprehension of the form: </para>

<programlisting>
   [ e | p1 &lt;- e11, p2 &lt;- e12, ...
       | q1 &lt;- e21, q2 &lt;- e22, ...
       ...
   ]
</programlisting>

    <para>This will be translated to: </para>

<programlisting>
   [ e | ((p1,p2), (q1,q2), ...) &lt;- zipN [(p1,p2) | p1 &lt;- e11, p2 &lt;- e12, ...]
                                         [(q1,q2) | q1 &lt;- e21, q2 &lt;- e22, ...]
                                         ...
   ]
</programlisting>

    <para>where `zipN' is the appropriate zip for the given number of
    branches.</para>

  </sect2>

  <!-- ===================== TRANSFORM LIST COMPREHENSIONS ===================  -->

  <sect2 id="generalised-list-comprehensions">
    <title>Generalised (SQL-Like) List Comprehensions</title>
    <indexterm><primary>list comprehensions</primary><secondary>generalised</secondary>
    </indexterm>
    <indexterm><primary>extended list comprehensions</primary>
    </indexterm>
    <indexterm><primary>group</primary></indexterm>
    <indexterm><primary>sql</primary></indexterm>


    <para>Generalised list comprehensions are a further enhancement to the
    list comprehension syntactic sugar to allow operations such as sorting
    and grouping which are familiar from SQL.   They are fully described in the
	paper <ulink url="http://research.microsoft.com/~simonpj/papers/list-comp">
	  Comprehensive comprehensions: comprehensions with "order by" and "group by"</ulink>,
    except that the syntax we use differs slightly from the paper.</para>
<para>The extension is enabled with the flag <option>-XTransformListComp</option>.</para>
<para>Here is an example:
<programlisting>
employees = [ ("Simon", "MS", 80)
, ("Erik", "MS", 100)
, ("Phil", "Ed", 40)
, ("Gordon", "Ed", 45)
, ("Paul", "Yale", 60)]

output = [ (the dept, sum salary)
| (name, dept, salary) &lt;- employees
, then group by dept using groupWith
, then sortWith by (sum salary)
, then take 5 ]
</programlisting>
In this example, the list <literal>output</literal> would take on
    the value:

<programlisting>
[("Yale", 60), ("Ed", 85), ("MS", 180)]
</programlisting>
</para>
<para>There are three new keywords: <literal>group</literal>, <literal>by</literal>, and <literal>using</literal>.
(The functions <literal>sortWith</literal> and <literal>groupWith</literal> are not keywords; they are ordinary
functions that are exported by <literal>GHC.Exts</literal>.)</para>

<para>There are five new forms of comprehension qualifier,
all introduced by the (existing) keyword <literal>then</literal>:
    <itemizedlist>
    <listitem>

<programlisting>
then f
</programlisting>

    This statement requires that <literal>f</literal> have the type <literal>
    forall a. [a] -> [a]</literal>. You can see an example of its use in the
    motivating example, as this form is used to apply <literal>take 5</literal>.

    </listitem>


    <listitem>
<para>
<programlisting>
then f by e
</programlisting>

    This form is similar to the previous one, but allows you to create a function
    which will be passed as the first argument to f. As a consequence f must have
    the type <literal>forall a. (a -> t) -> [a] -> [a]</literal>. As you can see
    from the type, this function lets f &quot;project out&quot; some information
    from the elements of the list it is transforming.</para>

    <para>An example is shown in the opening example, where <literal>sortWith</literal>
    is supplied with a function that lets it find out the <literal>sum salary</literal>
    for any item in the list comprehension it transforms.</para>

    </listitem>


    <listitem>

<programlisting>
then group by e using f
</programlisting>

    <para>This is the most general of the grouping-type statements. In this form,
    f is required to have type <literal>forall a. (a -> t) -> [a] -> [[a]]</literal>.
    As with the <literal>then f by e</literal> case above, the first argument
    is a function supplied to f by the compiler which lets it compute e on every
    element of the list being transformed. However, unlike the non-grouping case,
    f additionally partitions the list into a number of sublists: this means that
    at every point after this statement, binders occurring before it in the comprehension
    refer to <emphasis>lists</emphasis> of possible values, not single values. To help understand
    this, let's look at an example:</para>

<programlisting>
-- This works similarly to groupWith in GHC.Exts, but doesn't sort its input first
groupRuns :: Eq b => (a -> b) -> [a] -> [[a]]
groupRuns f = groupBy (\x y -> f x == f y)

output = [ (the x, y)
| x &lt;- ([1..3] ++ [1..2])
, y &lt;- [4..6]
, then group by x using groupRuns ]
</programlisting>

    <para>This results in the variable <literal>output</literal> taking on the value below:</para>

<programlisting>
[(1, [4, 5, 6]), (2, [4, 5, 6]), (3, [4, 5, 6]), (1, [4, 5, 6]), (2, [4, 5, 6])]
</programlisting>

    <para>Note that we have used the <literal>the</literal> function to change the type
    of x from a list to its original numeric type. The variable y, in contrast, is left
    unchanged from the list form introduced by the grouping.</para>

    </listitem>

    <listitem>

<programlisting>
then group using f
</programlisting>

    <para>With this form of the group statement, f is required to simply have the type
    <literal>forall a. [a] -> [[a]]</literal>, which will be used to group up the
    comprehension so far directly. An example of this form is as follows:</para>

<programlisting>
output = [ x
| y &lt;- [1..5]
, x &lt;- "hello"
, then group using inits]
</programlisting>

    <para>This will yield a list containing every prefix of the word "hello" written out 5 times:</para>

<programlisting>
["","h","he","hel","hell","hello","helloh","hellohe","hellohel","hellohell","hellohello","hellohelloh",...]
</programlisting>

    </listitem>
</itemizedlist>
</para>
  </sect2>

   <!-- ===================== MONAD COMPREHENSIONS ===================== -->

<sect2 id="monad-comprehensions">
    <title>Monad comprehensions</title>
    <indexterm><primary>monad comprehensions</primary></indexterm>

    <para>
        Monad comprehensions generalise the list comprehension notation,
        including parallel comprehensions
        (<xref linkend="parallel-list-comprehensions"/>) and
        transform comprehensions (<xref linkend="generalised-list-comprehensions"/>)
        to work for any monad.
    </para>

    <para>Monad comprehensions support:</para>

    <itemizedlist>
        <listitem>
            <para>
                Bindings:
            </para>

<programlisting>
[ x + y | x &lt;- Just 1, y &lt;- Just 2 ]
</programlisting>

            <para>
                Bindings are translated with the <literal>(&gt;&gt;=)</literal> and
                <literal>return</literal> functions to the usual do-notation:
            </para>

<programlisting>
do x &lt;- Just 1
   y &lt;- Just 2
   return (x+y)
</programlisting>

        </listitem>
        <listitem>
            <para>
                Guards:
            </para>

<programlisting>
[ x | x &lt;- [1..10], x &lt;= 5 ]
</programlisting>

            <para>
                Guards are translated with the <literal>guard</literal> function,
                which requires a <literal>MonadPlus</literal> instance:
            </para>

<programlisting>
do x &lt;- [1..10]
   guard (x &lt;= 5)
   return x
</programlisting>

        </listitem>
        <listitem>
            <para>
                Transform statements (as with <literal>-XTransformListComp</literal>):
            </para>

<programlisting>
[ x+y | x &lt;- [1..10], y &lt;- [1..x], then take 2 ]
</programlisting>

            <para>
                This translates to:
            </para>

<programlisting>
do (x,y) &lt;- take 2 (do x &lt;- [1..10]
                       y &lt;- [1..x]
                       return (x,y))
   return (x+y)
</programlisting>

        </listitem>
        <listitem>
            <para>
                Group statements (as with <literal>-XTransformListComp</literal>):
            </para>

<programlisting>
[ x | x &lt;- [1,1,2,2,3], then group by x using GHC.Exts.groupWith ]
[ x | x &lt;- [1,1,2,2,3], then group using myGroup ]
</programlisting>

        </listitem>
        <listitem>
            <para>
                Parallel statements (as with <literal>-XParallelListComp</literal>):
            </para>

<programlisting>
[ (x+y) | x &lt;- [1..10]
        | y &lt;- [11..20]
        ]
</programlisting>

            <para>
                Parallel statements are translated using the
                <literal>mzip</literal> function, which requires a
                <literal>MonadZip</literal> instance defined in
                <ulink url="&libraryBaseLocation;/Control-Monad-Zip.html"><literal>Control.Monad.Zip</literal></ulink>:
            </para>

<programlisting>
do (x,y) &lt;- mzip (do x &lt;- [1..10]
                     return x)
                 (do y &lt;- [11..20]
                     return y)
   return (x+y)
</programlisting>

        </listitem>
    </itemizedlist>

    <para>
        All these features are enabled by default if the
        <literal>MonadComprehensions</literal> extension is enabled. The types
        and more detailed examples on how to use comprehensions are explained
        in the previous chapters <xref
            linkend="generalised-list-comprehensions"/> and <xref
            linkend="parallel-list-comprehensions"/>. In general you just have
        to replace the type <literal>[a]</literal> with the type
        <literal>Monad m => m a</literal> for monad comprehensions.
    </para>

    <para>
        Note: Even though most of these examples are using the list monad,
        monad comprehensions work for any monad.
        The <literal>base</literal> package offers all necessary instances for
        lists, which make <literal>MonadComprehensions</literal> backward
        compatible to built-in, transform and parallel list comprehensions.
    </para>
<para> More formally, the desugaring is as follows.  We write <literal>D[ e | Q]</literal>
to mean the desugaring of the monad comprehension <literal>[ e | Q]</literal>:
<programlisting>
Expressions: e
Declarations: d
Lists of qualifiers: Q,R,S

-- Basic forms
D[ e | ]               = return e
D[ e | p &lt;- e, Q ]  = e &gt;&gt;= \p -&gt; D[ e | Q ]
D[ e | e, Q ]          = guard e &gt;&gt; \p -&gt; D[ e | Q ]
D[ e | let d, Q ]      = let d in D[ e | Q ]

-- Parallel comprehensions (iterate for multiple parallel branches)
D[ e | (Q | R), S ]    = mzip D[ Qv | Q ] D[ Rv | R ] &gt;&gt;= \(Qv,Rv) -&gt; D[ e | S ]

-- Transform comprehensions
D[ e | Q then f, R ]                  = f D[ Qv | Q ] &gt;&gt;= \Qv -&gt; D[ e | R ]

D[ e | Q then f by b, R ]             = f (\Qv -&gt; b) D[ Qv | Q ] &gt;&gt;= \Qv -&gt; D[ e | R ]

D[ e | Q then group using f, R ]      = f D[ Qv | Q ] &gt;&gt;= \ys -&gt;
                                        case (fmap selQv1 ys, ..., fmap selQvn ys) of
                                 	     Qv -&gt; D[ e | R ]

D[ e | Q then group by b using f, R ] = f (\Qv -&gt; b) D[ Qv | Q ] &gt;&gt;= \ys -&gt;
                                        case (fmap selQv1 ys, ..., fmap selQvn ys) of
                                           Qv -&gt; D[ e | R ]

where  Qv is the tuple of variables bound by Q (and used subsequently)
       selQvi is a selector mapping Qv to the ith component of Qv

Operator     Standard binding       Expected type
--------------------------------------------------------------------
return       GHC.Base               t1 -&gt; m t2
(&gt;&gt;=)        GHC.Base               m1 t1 -&gt; (t2 -&gt; m2 t3) -&gt; m3 t3
(&gt;&gt;)         GHC.Base               m1 t1 -&gt; m2 t2         -&gt; m3 t3
guard        Control.Monad          t1 -&gt; m t2
fmap         GHC.Base               forall a b. (a-&gt;b) -&gt; n a -&gt; n b
mzip         Control.Monad.Zip      forall a b. m a -&gt; m b -&gt; m (a,b)
</programlisting>
The comprehension should typecheck when its desugaring would typecheck.
</para>
<para>
Monad comprehensions support rebindable syntax (<xref linkend="rebindable-syntax"/>).
Without rebindable
syntax, the operators from the "standard binding" module are used; with
rebindable syntax, the operators are looked up in the current lexical scope.
For example, parallel comprehensions will be typechecked and desugared
using whatever "<literal>mzip</literal>" is in scope.
</para>
<para>
The rebindable operators must have the "Expected type" given in the
table above.  These types are surprisingly general.  For example, you can
use a bind operator with the type
<programlisting>
(>>=) :: T x y a -> (a -> T y z b) -> T x z b
</programlisting>
In the case of transform comprehensions, notice that the groups are
parameterised over some arbitrary type <literal>n</literal> (provided it
has an <literal>fmap</literal>, as well as
the comprehension being over an arbitrary monad.
</para>
</sect2>

   <!-- ===================== REBINDABLE SYNTAX ===================  -->

<sect2 id="rebindable-syntax">
<title>Rebindable syntax and the implicit Prelude import</title>

 <para><indexterm><primary>-XNoImplicitPrelude
 option</primary></indexterm> GHC normally imports
 <filename>Prelude.hi</filename> files for you.  If you'd
 rather it didn't, then give it a
 <option>-XNoImplicitPrelude</option> option.  The idea is
 that you can then import a Prelude of your own.  (But don't
 call it <literal>Prelude</literal>; the Haskell module
 namespace is flat, and you must not conflict with any
 Prelude module.)</para>

            <para>Suppose you are importing a Prelude of your own
	      in order to define your own numeric class
            hierarchy.  It completely defeats that purpose if the
            literal "1" means "<literal>Prelude.fromInteger
            1</literal>", which is what the Haskell Report specifies.
            So the <option>-XRebindableSyntax</option>
	      flag causes
            the following pieces of built-in syntax to refer to
            <emphasis>whatever is in scope</emphasis>, not the Prelude
            versions:
	    <itemizedlist>
	      <listitem>
		<para>An integer literal <literal>368</literal> means
                "<literal>fromInteger (368::Integer)</literal>", rather than
                "<literal>Prelude.fromInteger (368::Integer)</literal>".
</para> </listitem>

      <listitem><para>Fractional literals are handed in just the same way,
	  except that the translation is
	      <literal>fromRational (3.68::Rational)</literal>.
</para> </listitem>

	  <listitem><para>The equality test in an overloaded numeric pattern
	      uses whatever <literal>(==)</literal> is in scope.
</para> </listitem>

	  <listitem><para>The subtraction operation, and the
	  greater-than-or-equal test, in <literal>n+k</literal> patterns
	      use whatever <literal>(-)</literal> and <literal>(>=)</literal> are in scope.
	      </para></listitem>

	      <listitem>
		<para>Negation (e.g. "<literal>- (f x)</literal>")
		means "<literal>negate (f x)</literal>", both in numeric
		patterns, and expressions.
	      </para></listitem>

	      <listitem>
		<para>Conditionals (e.g. "<literal>if</literal> e1 <literal>then</literal> e2 <literal>else</literal> e3")
		means "<literal>ifThenElse</literal> e1 e2 e3".  However <literal>case</literal> expressions are unaffected.
	      </para></listitem>

	      <listitem>
	  <para>"Do" notation is translated using whatever
	      functions <literal>(>>=)</literal>,
	      <literal>(>>)</literal>, and <literal>fail</literal>,
	      are in scope (not the Prelude
	      versions).  List comprehensions, mdo (<xref linkend="mdo-notation"/>), and parallel array
	      comprehensions, are unaffected.  </para></listitem>

	      <listitem>
		<para>Arrow
		notation (see <xref linkend="arrow-notation"/>)
		uses whatever <literal>arr</literal>,
		<literal>(>>>)</literal>, <literal>first</literal>,
		<literal>app</literal>, <literal>(|||)</literal> and
		<literal>loop</literal> functions are in scope. But unlike the
		other constructs, the types of these functions must match the
		Prelude types very closely.  Details are in flux; if you want
		to use this, ask!
	      </para></listitem>
	    </itemizedlist>
<option>-XRebindableSyntax</option> implies <option>-XNoImplicitPrelude</option>.
</para>
<para>
In all cases (apart from arrow notation), the static semantics should be that of the desugared form,
even if that is a little unexpected. For example, the
static semantics of the literal <literal>368</literal>
is exactly that of <literal>fromInteger (368::Integer)</literal>; it's fine for
<literal>fromInteger</literal> to have any of the types:
<programlisting>
fromInteger :: Integer -> Integer
fromInteger :: forall a. Foo a => Integer -> a
fromInteger :: Num a => a -> Integer
fromInteger :: Integer -> Bool -> Bool
</programlisting>
</para>

	     <para>Be warned: this is an experimental facility, with
	     fewer checks than usual.  Use <literal>-dcore-lint</literal>
	     to typecheck the desugared program.  If Core Lint is happy
	     you should be all right.</para>

</sect2>

<sect2 id="postfix-operators">
<title>Postfix operators</title>

<para>
  The <option>-XPostfixOperators</option> flag enables a small
extension to the syntax of left operator sections, which allows you to
define postfix operators.  The extension is this: the left section
<programlisting>
  (e !)
</programlisting>
is equivalent (from the point of view of both type checking and execution) to the expression
<programlisting>
  ((!) e)
</programlisting>
(for any expression <literal>e</literal> and operator <literal>(!)</literal>.
The strict Haskell 98 interpretation is that the section is equivalent to
<programlisting>
  (\y -> (!) e y)
</programlisting>
That is, the operator must be a function of two arguments.  GHC allows it to
take only one argument, and that in turn allows you to write the function
postfix.
</para>
<para>The extension does not extend to the left-hand side of function
definitions; you must define such a function in prefix form.</para>

</sect2>

<sect2 id="tuple-sections">
<title>Tuple sections</title>

<para>
  The <option>-XTupleSections</option> flag enables Python-style partially applied
  tuple constructors. For example, the following program
<programlisting>
  (, True)
</programlisting>
  is considered to be an alternative notation for the more unwieldy alternative
<programlisting>
  \x -> (x, True)
</programlisting>
You can omit any combination of arguments to the tuple, as in the following
<programlisting>
  (, "I", , , "Love", , 1337)
</programlisting>
which translates to
<programlisting>
  \a b c d -> (a, "I", b, c, "Love", d, 1337)
</programlisting>
</para>

<para>
  If you have <link linkend="unboxed-tuples">unboxed tuples</link> enabled, tuple sections
  will also be available for them, like so
<programlisting>
  (# , True #)
</programlisting>
Because there is no unboxed unit tuple, the following expression
<programlisting>
  (# #)
</programlisting>
continues to stand for the unboxed singleton tuple data constructor.
</para>

</sect2>

<sect2 id="disambiguate-fields">
<title>Record field disambiguation</title>
<para>
In record construction and record pattern matching
it is entirely unambiguous which field is referred to, even if there are two different
data types in scope with a common field name.  For example:
<programlisting>
module M where
  data S = MkS { x :: Int, y :: Bool }

module Foo where
  import M

  data T = MkT { x :: Int }

  ok1 (MkS { x = n }) = n+1   -- Unambiguous
  ok2 n = MkT { x = n+1 }     -- Unambiguous

  bad1 k = k { x = 3 }  -- Ambiguous
  bad2 k = x k          -- Ambiguous
</programlisting>
Even though there are two <literal>x</literal>'s in scope,
it is clear that the <literal>x</literal> in the pattern in the
definition of <literal>ok1</literal> can only mean the field
<literal>x</literal> from type <literal>S</literal>. Similarly for
the function <literal>ok2</literal>.  However, in the record update
in <literal>bad1</literal> and the record selection in <literal>bad2</literal>
it is not clear which of the two types is intended.
</para>
<para>
Haskell 98 regards all four as ambiguous, but with the
<option>-XDisambiguateRecordFields</option> flag, GHC will accept
the former two.  The rules are precisely the same as those for instance
declarations in Haskell 98, where the method names on the left-hand side
of the method bindings in an instance declaration refer unambiguously
to the method of that class (provided they are in scope at all), even
if there are other variables in scope with the same name.
This reduces the clutter of qualified names when you import two
records from different modules that use the same field name.
</para>
<para>
Some details:
<itemizedlist>
<listitem><para>
Field disambiguation can be combined with punning (see <xref linkend="record-puns"/>). For example:
<programlisting>
module Foo where
  import M
  x=True
  ok3 (MkS { x }) = x+1   -- Uses both disambiguation and punning
</programlisting>
</para></listitem>

<listitem><para>
With <option>-XDisambiguateRecordFields</option> you can use <emphasis>unqualified</emphasis>
field names even if the corresponding selector is only in scope <emphasis>qualified</emphasis>
For example, assuming the same module <literal>M</literal> as in our earlier example, this is legal:
<programlisting>
module Foo where
  import qualified M    -- Note qualified

  ok4 (M.MkS { x = n }) = n+1   -- Unambiguous
</programlisting>
Since the constructor <literal>MkS</literal> is only in scope qualified, you must
name it <literal>M.MkS</literal>, but the field <literal>x</literal> does not need
to be qualified even though <literal>M.x</literal> is in scope but <literal>x</literal>
is not.  (In effect, it is qualified by the constructor.)
</para></listitem>
</itemizedlist>
</para>

</sect2>

    <!-- ===================== Record puns ===================  -->

<sect2 id="record-puns">
<title>Record puns
</title>

<para>
Record puns are enabled by the flag <literal>-XNamedFieldPuns</literal>.
</para>

<para>
When using records, it is common to write a pattern that binds a
variable with the same name as a record field, such as:

<programlisting>
data C = C {a :: Int}
f (C {a = a}) = a
</programlisting>
</para>

<para>
Record punning permits the variable name to be elided, so one can simply
write

<programlisting>
f (C {a}) = a
</programlisting>

to mean the same pattern as above.  That is, in a record pattern, the
pattern <literal>a</literal> expands into the pattern <literal>a =
a</literal> for the same name <literal>a</literal>.
</para>

<para>
Note that:
<itemizedlist>
<listitem><para>
Record punning can also be used in an expression, writing, for example,
<programlisting>
let a = 1 in C {a}
</programlisting>
instead of
<programlisting>
let a = 1 in C {a = a}
</programlisting>
The expansion is purely syntactic, so the expanded right-hand side
expression refers to the nearest enclosing variable that is spelled the
same as the field name.
</para></listitem>

<listitem><para>
Puns and other patterns can be mixed in the same record:
<programlisting>
data C = C {a :: Int, b :: Int}
f (C {a, b = 4}) = a
</programlisting>
</para></listitem>

<listitem><para>
Puns can be used wherever record patterns occur (e.g. in
<literal>let</literal> bindings or at the top-level).
</para></listitem>

<listitem><para>
A pun on a qualified field name is expanded by stripping off the module qualifier.
For example:
<programlisting>
f (C {M.a}) = a
</programlisting>
means
<programlisting>
f (M.C {M.a = a}) = a
</programlisting>
(This is useful if the field selector <literal>a</literal> for constructor <literal>M.C</literal>
is only in scope in qualified form.)
</para></listitem>
</itemizedlist>
</para>


</sect2>

    <!-- ===================== Record wildcards ===================  -->

<sect2 id="record-wildcards">
<title>Record wildcards
</title>

<para>
Record wildcards are enabled by the flag <literal>-XRecordWildCards</literal>.
This flag implies <literal>-XDisambiguateRecordFields</literal>.
</para>

<para>
For records with many fields, it can be tiresome to write out each field
individually in a record pattern, as in
<programlisting>
data C = C {a :: Int, b :: Int, c :: Int, d :: Int}
f (C {a = 1, b = b, c = c, d = d}) = b + c + d
</programlisting>
</para>

<para>
Record wildcard syntax permits a "<literal>..</literal>" in a record
pattern, where each elided field <literal>f</literal> is replaced by the
pattern <literal>f = f</literal>.  For example, the above pattern can be
written as
<programlisting>
f (C {a = 1, ..}) = b + c + d
</programlisting>
</para>

<para>
More details:
<itemizedlist>
<listitem><para>
Wildcards can be mixed with other patterns, including puns
(<xref linkend="record-puns"/>); for example, in a pattern <literal>C {a
= 1, b, ..})</literal>.  Additionally, record wildcards can be used
wherever record patterns occur, including in <literal>let</literal>
bindings and at the top-level.  For example, the top-level binding
<programlisting>
C {a = 1, ..} = e
</programlisting>
defines <literal>b</literal>, <literal>c</literal>, and
<literal>d</literal>.
</para></listitem>

<listitem><para>
Record wildcards can also be used in expressions, writing, for example,
<programlisting>
let {a = 1; b = 2; c = 3; d = 4} in C {..}
</programlisting>
in place of
<programlisting>
let {a = 1; b = 2; c = 3; d = 4} in C {a=a, b=b, c=c, d=d}
</programlisting>
The expansion is purely syntactic, so the record wildcard
expression refers to the nearest enclosing variables that are spelled
the same as the omitted field names.
</para></listitem>

<listitem><para>
The "<literal>..</literal>" expands to the missing
<emphasis>in-scope</emphasis> record fields.
Specifically the expansion of "<literal>C {..}</literal>" includes
<literal>f</literal> if and only if:
<itemizedlist>
<listitem><para>
<literal>f</literal> is a record field of constructor <literal>C</literal>.
</para></listitem>
<listitem><para>
The record field <literal>f</literal> is in scope somehow (either qualified or unqualified).
</para></listitem>
<listitem><para>
In the case of expressions (but not patterns),
the variable <literal>f</literal> is in scope unqualified,
apart from the binding of the record selector itself.
</para></listitem>
</itemizedlist>
For example
<programlisting>
module M where
  data R = R { a,b,c :: Int }
module X where
  import M( R(a,c) )
  f b = R { .. }
</programlisting>
The <literal>R{..}</literal> expands to <literal>R{M.a=a}</literal>,
omitting <literal>b</literal> since the record field is not in scope,
and omitting <literal>c</literal> since the variable <literal>c</literal>
is not in scope (apart from the binding of the
record selector <literal>c</literal>, of course).
</para></listitem>
</itemizedlist>
</para>

</sect2>

    <!-- ===================== Local fixity declarations ===================  -->

<sect2 id="local-fixity-declarations">
<title>Local Fixity Declarations
</title>

<para>A careful reading of the Haskell 98 Report reveals that fixity
declarations (<literal>infix</literal>, <literal>infixl</literal>, and
<literal>infixr</literal>) are permitted to appear inside local bindings
such those introduced by <literal>let</literal> and
<literal>where</literal>.  However, the Haskell Report does not specify
the semantics of such bindings very precisely.
</para>

<para>In GHC, a fixity declaration may accompany a local binding:
<programlisting>
let f = ...
    infixr 3 `f`
in
    ...
</programlisting>
and the fixity declaration applies wherever the binding is in scope.
For example, in a <literal>let</literal>, it applies in the right-hand
sides of other <literal>let</literal>-bindings and the body of the
<literal>let</literal>C. Or, in recursive <literal>do</literal>
expressions (<xref linkend="recursive-do-notation"/>), the local fixity
declarations of a <literal>let</literal> statement scope over other
statements in the group, just as the bound name does.
</para>

<para>
Moreover, a local fixity declaration *must* accompany a local binding of
that name: it is not possible to revise the fixity of name bound
elsewhere, as in
<programlisting>
let infixr 9 $ in ...
</programlisting>

Because local fixity declarations are technically Haskell 98, no flag is
necessary to enable them.
</para>
</sect2>

<sect2 id="package-imports">
  <title>Package-qualified imports</title>

  <para>With the <option>-XPackageImports</option> flag, GHC allows
  import declarations to be qualified by the package name that the
    module is intended to be imported from.  For example:</para>

<programlisting>
import "network" Network.Socket
</programlisting>

  <para>would import the module <literal>Network.Socket</literal> from
    the package <literal>network</literal> (any version).  This may
    be used to disambiguate an import when the same module is
    available from multiple packages, or is present in both the
    current package being built and an external package.</para>

  <para>Note: you probably don't need to use this feature, it was
    added mainly so that we can build backwards-compatible versions of
    packages when APIs change.  It can lead to fragile dependencies in
    the common case: modules occasionally move from one package to
    another, rendering any package-qualified imports broken.</para>
</sect2>

<sect2 id="safe-imports-ext">
  <title>Safe imports</title>

  <para>With the <option>-XSafe</option>, <option>-XTrustworthy</option>
    and <option>-XUnsafe</option> language flags, GHC extends
    the import declaration syntax to take an optional <literal>safe</literal>
    keyword after the <literal>import</literal> keyword. This feature
    is part of the Safe Haskell GHC extension. For example:</para>

<programlisting>
import safe qualified Network.Socket as NS
</programlisting>

  <para>would import the module <literal>Network.Socket</literal>
    with compilation only succeeding if Network.Socket can be
    safely imported. For a description of when a import is
    considered safe see <xref linkend="safe-haskell"/></para>

</sect2>

<sect2 id="syntax-stolen">
<title>Summary of stolen syntax</title>

    <para>Turning on an option that enables special syntax
    <emphasis>might</emphasis> cause working Haskell 98 code to fail
    to compile, perhaps because it uses a variable name which has
    become a reserved word.  This section lists the syntax that is
    "stolen" by language extensions.
     We use
    notation and nonterminal names from the Haskell 98 lexical syntax
    (see the Haskell 98 Report).
    We only list syntax changes here that might affect
    existing working programs (i.e. "stolen" syntax).  Many of these
    extensions will also enable new context-free syntax, but in all
    cases programs written to use the new syntax would not be
    compilable without the option enabled.</para>

<para>There are two classes of special
    syntax:

    <itemizedlist>
      <listitem>
	<para>New reserved words and symbols: character sequences
        which are no longer available for use as identifiers in the
        program.</para>
      </listitem>
      <listitem>
	<para>Other special syntax: sequences of characters that have
	a different meaning when this particular option is turned
	on.</para>
      </listitem>
    </itemizedlist>

The following syntax is stolen:

    <variablelist>
      <varlistentry>
	<term>
          <literal>forall</literal>
          <indexterm><primary><literal>forall</literal></primary></indexterm>
	</term>
	<listitem><para>
	Stolen (in types) by: <option>-XExplicitForAll</option>, and hence by
            <option>-XScopedTypeVariables</option>,
	    <option>-XLiberalTypeSynonyms</option>,
	    <option>-XRank2Types</option>,
	    <option>-XRankNTypes</option>,
	    <option>-XPolymorphicComponents</option>,
	    <option>-XExistentialQuantification</option>
	  </para></listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>mdo</literal>
          <indexterm><primary><literal>mdo</literal></primary></indexterm>
	</term>
	<listitem><para>
	Stolen by: <option>-XRecursiveDo</option>
	  </para></listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>foreign</literal>
          <indexterm><primary><literal>foreign</literal></primary></indexterm>
	</term>
	<listitem><para>
	Stolen by: <option>-XForeignFunctionInterface</option>
	  </para></listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>rec</literal>,
	  <literal>proc</literal>, <literal>-&lt;</literal>,
	  <literal>&gt;-</literal>, <literal>-&lt;&lt;</literal>,
	  <literal>&gt;&gt;-</literal>, and <literal>(|</literal>,
	  <literal>|)</literal> brackets
          <indexterm><primary><literal>proc</literal></primary></indexterm>
	</term>
	<listitem><para>
	Stolen by: <option>-XArrows</option>
	  </para></listitem>
      </varlistentry>

      <varlistentry>
	<term>
	  <literal>?<replaceable>varid</replaceable></literal>,
	  <literal>%<replaceable>varid</replaceable></literal>
          <indexterm><primary>implicit parameters</primary></indexterm>
	</term>
	<listitem><para>
	Stolen by: <option>-XImplicitParams</option>
	  </para></listitem>
      </varlistentry>

      <varlistentry>
	<term>
	  <literal>[|</literal>,
	  <literal>[e|</literal>, <literal>[p|</literal>,
	  <literal>[d|</literal>, <literal>[t|</literal>,
	  <literal>$(</literal>,
	  <literal>$<replaceable>varid</replaceable></literal>
          <indexterm><primary>Template Haskell</primary></indexterm>
	</term>
	<listitem><para>
	Stolen by: <option>-XTemplateHaskell</option>
	  </para></listitem>
      </varlistentry>

      <varlistentry>
	<term>
	  <literal>'<replaceable>varid</replaceable></literal>
	</term>
	<listitem><para>
	Stolen by: <option>-XTemplateHaskell</option>and 
                   <option>-XPolyKinds</option>
	  </para></listitem>
      </varlistentry>

      <varlistentry>
	<term>
	  <literal>[:<replaceable>varid</replaceable>|</literal>
          <indexterm><primary>quasi-quotation</primary></indexterm>
	</term>
	<listitem><para>
	Stolen by: <option>-XQuasiQuotes</option>
	  </para></listitem>
      </varlistentry>

      <varlistentry>
	<term>
	      <replaceable>varid</replaceable>{<literal>&num;</literal>},
	      <replaceable>char</replaceable><literal>&num;</literal>,
	      <replaceable>string</replaceable><literal>&num;</literal>,
	      <replaceable>integer</replaceable><literal>&num;</literal>,
	      <replaceable>float</replaceable><literal>&num;</literal>,
	      <replaceable>float</replaceable><literal>&num;&num;</literal>,
	      <literal>(&num;</literal>, <literal>&num;)</literal>
	</term>
	<listitem><para>
	Stolen by: <option>-XMagicHash</option>
	  </para></listitem>
      </varlistentry>
    </variablelist>
</para>
</sect2>
</sect1>


<!-- TYPE SYSTEM EXTENSIONS -->
<sect1 id="data-type-extensions">
<title>Extensions to data types and type synonyms</title>

<sect2 id="nullary-types">
<title>Data types with no constructors</title>

<para>With the <option>-XEmptyDataDecls</option> flag (or equivalent LANGUAGE pragma),
GHC lets you declare a data type with no constructors.  For example:</para>

<programlisting>
  data S      -- S :: *
  data T a    -- T :: * -> *
</programlisting>

<para>Syntactically, the declaration lacks the "= constrs" part.  The
type can be parameterised over types of any kind, but if the kind is
not <literal>*</literal> then an explicit kind annotation must be used
(see <xref linkend="kinding"/>).</para>

<para>Such data types have only one value, namely bottom.
Nevertheless, they can be useful when defining "phantom types".</para>
</sect2>

<sect2 id="datatype-contexts">
<title>Data type contexts</title>

<para>Haskell allows datatypes to be given contexts, e.g.</para>

<programlisting>
data Eq a => Set a = NilSet | ConsSet a (Set a)
</programlisting>

<para>give constructors with types:</para>

<programlisting>
NilSet :: Set a
ConsSet :: Eq a => a -> Set a -> Set a
</programlisting>

<para>This is widely considered a misfeature, and is going to be removed from
the language.  In GHC, it is controlled by the deprecated extension
<literal>DatatypeContexts</literal>.</para>
</sect2>

<sect2 id="infix-tycons">
<title>Infix type constructors, classes, and type variables</title>

<para>
GHC allows type constructors, classes, and type variables to be operators, and
to be written infix, very much like expressions.  More specifically:
<itemizedlist>
<listitem><para>
  A type constructor or class can be an operator, beginning with a colon; e.g. <literal>:*:</literal>.
  The lexical syntax is the same as that for data constructors.
  </para></listitem>
<listitem><para>
  Data type and type-synonym declarations can be written infix, parenthesised
  if you want further arguments.  E.g.
<screen>
  data a :*: b = Foo a b
  type a :+: b = Either a b
  class a :=: b where ...

  data (a :**: b) x = Baz a b x
  type (a :++: b) y = Either (a,b) y
</screen>
  </para></listitem>
<listitem><para>
  Types, and class constraints, can be written infix.  For example
  <screen>
	x :: Int :*: Bool
        f :: (a :=: b) => a -> b
  </screen>
  </para></listitem>
<listitem><para>
  A type variable can be an (unqualified) operator e.g. <literal>+</literal>.
  The lexical syntax is the same as that for variable operators, excluding "(.)",
  "(!)", and "(*)".  In a binding position, the operator must be
  parenthesised.  For example:
<programlisting>
   type T (+) = Int + Int
   f :: T Either
   f = Left 3

   liftA2 :: Arrow (~>)
	  => (a -> b -> c) -> (e ~> a) -> (e ~> b) -> (e ~> c)
   liftA2 = ...
</programlisting>
  </para></listitem>
<listitem><para>
  Back-quotes work
  as for expressions, both for type constructors and type variables;  e.g. <literal>Int `Either` Bool</literal>, or
  <literal>Int `a` Bool</literal>.  Similarly, parentheses work the same; e.g.  <literal>(:*:) Int Bool</literal>.
  </para></listitem>
<listitem><para>
  Fixities may be declared for type constructors, or classes, just as for data constructors.  However,
  one cannot distinguish between the two in a fixity declaration; a fixity declaration
  sets the fixity for a data constructor and the corresponding type constructor.  For example:
<screen>
  infixl 7 T, :*:
</screen>
  sets the fixity for both type constructor <literal>T</literal> and data constructor <literal>T</literal>,
  and similarly for <literal>:*:</literal>.
  <literal>Int `a` Bool</literal>.
  </para></listitem>
<listitem><para>
  Function arrow is <literal>infixr</literal> with fixity 0.  (This might change; I'm not sure what it should be.)
  </para></listitem>

</itemizedlist>
</para>
</sect2>

<sect2 id="type-synonyms">
<title>Liberalised type synonyms</title>

<para>
Type synonyms are like macros at the type level, but Haskell 98 imposes many rules
on individual synonym declarations.
With the <option>-XLiberalTypeSynonyms</option> extension,
GHC does validity checking on types <emphasis>only after expanding type synonyms</emphasis>.
That means that GHC can be very much more liberal about type synonyms than Haskell 98.

<itemizedlist>
<listitem> <para>You can write a <literal>forall</literal> (including overloading)
in a type synonym, thus:
<programlisting>
  type Discard a = forall b. Show b => a -> b -> (a, String)

  f :: Discard a
  f x y = (x, show y)

  g :: Discard Int -> (Int,String)    -- A rank-2 type
  g f = f 3 True
</programlisting>
</para>
</listitem>

<listitem><para>
If you also use <option>-XUnboxedTuples</option>,
you can write an unboxed tuple in a type synonym:
<programlisting>
  type Pr = (# Int, Int #)

  h :: Int -> Pr
  h x = (# x, x #)
</programlisting>
</para></listitem>

<listitem><para>
You can apply a type synonym to a forall type:
<programlisting>
  type Foo a = a -> a -> Bool

  f :: Foo (forall b. b->b)
</programlisting>
After expanding the synonym, <literal>f</literal> has the legal (in GHC) type:
<programlisting>
  f :: (forall b. b->b) -> (forall b. b->b) -> Bool
</programlisting>
</para></listitem>

<listitem><para>
You can apply a type synonym to a partially applied type synonym:
<programlisting>
  type Generic i o = forall x. i x -> o x
  type Id x = x

  foo :: Generic Id []
</programlisting>
After expanding the synonym, <literal>foo</literal> has the legal (in GHC) type:
<programlisting>
  foo :: forall x. x -> [x]
</programlisting>
</para></listitem>

</itemizedlist>
</para>

<para>
GHC currently does kind checking before expanding synonyms (though even that
could be changed.)
</para>
<para>
After expanding type synonyms, GHC does validity checking on types, looking for
the following mal-formedness which isn't detected simply by kind checking:
<itemizedlist>
<listitem><para>
Type constructor applied to a type involving for-alls.
</para></listitem>
<listitem><para>
Unboxed tuple on left of an arrow.
</para></listitem>
<listitem><para>
Partially-applied type synonym.
</para></listitem>
</itemizedlist>
So, for example,
this will be rejected:
<programlisting>
  type Pr = (# Int, Int #)

  h :: Pr -> Int
  h x = ...
</programlisting>
because GHC does not allow  unboxed tuples on the left of a function arrow.
</para>
</sect2>


<sect2 id="existential-quantification">
<title>Existentially quantified data constructors
</title>

<para>
The idea of using existential quantification in data type declarations
was suggested by Perry, and implemented in Hope+ (Nigel Perry, <emphasis>The Implementation
of Practical Functional Programming Languages</emphasis>, PhD Thesis, University of
London, 1991). It was later formalised by Laufer and Odersky
(<emphasis>Polymorphic type inference and abstract data types</emphasis>,
TOPLAS, 16(5), pp1411-1430, 1994).
It's been in Lennart
Augustsson's <command>hbc</command> Haskell compiler for several years, and
proved very useful.  Here's the idea.  Consider the declaration:
</para>

<para>

<programlisting>
  data Foo = forall a. MkFoo a (a -> Bool)
           | Nil
</programlisting>

</para>

<para>
The data type <literal>Foo</literal> has two constructors with types:
</para>

<para>

<programlisting>
  MkFoo :: forall a. a -> (a -> Bool) -> Foo
  Nil   :: Foo
</programlisting>

</para>

<para>
Notice that the type variable <literal>a</literal> in the type of <function>MkFoo</function>
does not appear in the data type itself, which is plain <literal>Foo</literal>.
For example, the following expression is fine:
</para>

<para>

<programlisting>
  [MkFoo 3 even, MkFoo 'c' isUpper] :: [Foo]
</programlisting>

</para>

<para>
Here, <literal>(MkFoo 3 even)</literal> packages an integer with a function
<function>even</function> that maps an integer to <literal>Bool</literal>; and <function>MkFoo 'c'
isUpper</function> packages a character with a compatible function.  These
two things are each of type <literal>Foo</literal> and can be put in a list.
</para>

<para>
What can we do with a value of type <literal>Foo</literal>?.  In particular,
what happens when we pattern-match on <function>MkFoo</function>?
</para>

<para>

<programlisting>
  f (MkFoo val fn) = ???
</programlisting>

</para>

<para>
Since all we know about <literal>val</literal> and <function>fn</function> is that they
are compatible, the only (useful) thing we can do with them is to
apply <function>fn</function> to <literal>val</literal> to get a boolean.  For example:
</para>

<para>

<programlisting>
  f :: Foo -> Bool
  f (MkFoo val fn) = fn val
</programlisting>

</para>

<para>
What this allows us to do is to package heterogeneous values
together with a bunch of functions that manipulate them, and then treat
that collection of packages in a uniform manner.  You can express
quite a bit of object-oriented-like programming this way.
</para>

<sect3 id="existential">
<title>Why existential?
</title>

<para>
What has this to do with <emphasis>existential</emphasis> quantification?
Simply that <function>MkFoo</function> has the (nearly) isomorphic type
</para>

<para>

<programlisting>
  MkFoo :: (exists a . (a, a -> Bool)) -> Foo
</programlisting>

</para>

<para>
But Haskell programmers can safely think of the ordinary
<emphasis>universally</emphasis> quantified type given above, thereby avoiding
adding a new existential quantification construct.
</para>

</sect3>

<sect3 id="existential-with-context">
<title>Existentials and type classes</title>

<para>
An easy extension is to allow
arbitrary contexts before the constructor.  For example:
</para>

<para>

<programlisting>
data Baz = forall a. Eq a => Baz1 a a
         | forall b. Show b => Baz2 b (b -> b)
</programlisting>

</para>

<para>
The two constructors have the types you'd expect:
</para>

<para>

<programlisting>
Baz1 :: forall a. Eq a => a -> a -> Baz
Baz2 :: forall b. Show b => b -> (b -> b) -> Baz
</programlisting>

</para>

<para>
But when pattern matching on <function>Baz1</function> the matched values can be compared
for equality, and when pattern matching on <function>Baz2</function> the first matched
value can be converted to a string (as well as applying the function to it).
So this program is legal:
</para>

<para>

<programlisting>
  f :: Baz -> String
  f (Baz1 p q) | p == q    = "Yes"
               | otherwise = "No"
  f (Baz2 v fn)            = show (fn v)
</programlisting>

</para>

<para>
Operationally, in a dictionary-passing implementation, the
constructors <function>Baz1</function> and <function>Baz2</function> must store the
dictionaries for <literal>Eq</literal> and <literal>Show</literal> respectively, and
extract it on pattern matching.
</para>

</sect3>

<sect3 id="existential-records">
<title>Record Constructors</title>

<para>
GHC allows existentials to be used with records syntax as well.  For example:

<programlisting>
data Counter a = forall self. NewCounter
    { _this    :: self
    , _inc     :: self -> self
    , _display :: self -> IO ()
    , tag      :: a
    }
</programlisting>
Here <literal>tag</literal> is a public field, with a well-typed selector
function <literal>tag :: Counter a -> a</literal>.  The <literal>self</literal>
type is hidden from the outside; any attempt to apply <literal>_this</literal>,
<literal>_inc</literal> or <literal>_display</literal> as functions will raise a
compile-time error.  In other words, <emphasis>GHC defines a record selector function
only for fields whose type does not mention the existentially-quantified variables</emphasis>.
(This example used an underscore in the fields for which record selectors
will not be defined, but that is only programming style; GHC ignores them.)
</para>

<para>
To make use of these hidden fields, we need to create some helper functions:

<programlisting>
inc :: Counter a -> Counter a
inc (NewCounter x i d t) = NewCounter
    { _this = i x, _inc = i, _display = d, tag = t }

display :: Counter a -> IO ()
display NewCounter{ _this = x, _display = d } = d x
</programlisting>

Now we can define counters with different underlying implementations:

<programlisting>
counterA :: Counter String
counterA = NewCounter
    { _this = 0, _inc = (1+), _display = print, tag = "A" }

counterB :: Counter String
counterB = NewCounter
    { _this = "", _inc = ('#':), _display = putStrLn, tag = "B" }

main = do
    display (inc counterA)         -- prints "1"
    display (inc (inc counterB))   -- prints "##"
</programlisting>

Record update syntax is supported for existentials (and GADTs):
<programlisting>
setTag :: Counter a -> a -> Counter a
setTag obj t = obj{ tag = t }
</programlisting>
The rule for record update is this: <emphasis>
the types of the updated fields may
mention only the universally-quantified type variables
of the data constructor.  For GADTs, the field may mention only types
that appear as a simple type-variable argument in the constructor's result
type</emphasis>.  For example:
<programlisting>
data T a b where { T1 { f1::a, f2::b, f3::(b,c) } :: T a b } -- c is existential
upd1 t x = t { f1=x }   -- OK:   upd1 :: T a b -> a' -> T a' b
upd2 t x = t { f3=x }   -- BAD   (f3's type mentions c, which is
                        --        existentially quantified)

data G a b where { G1 { g1::a, g2::c } :: G a [c] }
upd3 g x = g { g1=x }   -- OK:   upd3 :: G a b -> c -> G c b
upd4 g x = g { g2=x }   -- BAD (f2's type mentions c, which is not a simple
                        --      type-variable argument in G1's result type)
</programlisting>
</para>

</sect3>


<sect3>
<title>Restrictions</title>

<para>
There are several restrictions on the ways in which existentially-quantified
constructors can be use.
</para>

<para>

<itemizedlist>
<listitem>

<para>
 When pattern matching, each pattern match introduces a new,
distinct, type for each existential type variable.  These types cannot
be unified with any other type, nor can they escape from the scope of
the pattern match.  For example, these fragments are incorrect:


<programlisting>
f1 (MkFoo a f) = a
</programlisting>


Here, the type bound by <function>MkFoo</function> "escapes", because <literal>a</literal>
is the result of <function>f1</function>.  One way to see why this is wrong is to
ask what type <function>f1</function> has:


<programlisting>
  f1 :: Foo -> a             -- Weird!
</programlisting>


What is this "<literal>a</literal>" in the result type? Clearly we don't mean
this:


<programlisting>
  f1 :: forall a. Foo -> a   -- Wrong!
</programlisting>


The original program is just plain wrong.  Here's another sort of error


<programlisting>
  f2 (Baz1 a b) (Baz1 p q) = a==q
</programlisting>


It's ok to say <literal>a==b</literal> or <literal>p==q</literal>, but
<literal>a==q</literal> is wrong because it equates the two distinct types arising
from the two <function>Baz1</function> constructors.


</para>
</listitem>
<listitem>

<para>
You can't pattern-match on an existentially quantified
constructor in a <literal>let</literal> or <literal>where</literal> group of
bindings. So this is illegal:


<programlisting>
  f3 x = a==b where { Baz1 a b = x }
</programlisting>

Instead, use a <literal>case</literal> expression:

<programlisting>
  f3 x = case x of Baz1 a b -> a==b
</programlisting>

In general, you can only pattern-match
on an existentially-quantified constructor in a <literal>case</literal> expression or
in the patterns of a function definition.

The reason for this restriction is really an implementation one.
Type-checking binding groups is already a nightmare without
existentials complicating the picture.  Also an existential pattern
binding at the top level of a module doesn't make sense, because it's
not clear how to prevent the existentially-quantified type "escaping".
So for now, there's a simple-to-state restriction.  We'll see how
annoying it is.

</para>
</listitem>
<listitem>

<para>
You can't use existential quantification for <literal>newtype</literal>
declarations.  So this is illegal:


<programlisting>
  newtype T = forall a. Ord a => MkT a
</programlisting>


Reason: a value of type <literal>T</literal> must be represented as a
pair of a dictionary for <literal>Ord t</literal> and a value of type
<literal>t</literal>.  That contradicts the idea that
<literal>newtype</literal> should have no concrete representation.
You can get just the same efficiency and effect by using
<literal>data</literal> instead of <literal>newtype</literal>.  If
there is no overloading involved, then there is more of a case for
allowing an existentially-quantified <literal>newtype</literal>,
because the <literal>data</literal> version does carry an
implementation cost, but single-field existentially quantified
constructors aren't much use.  So the simple restriction (no
existential stuff on <literal>newtype</literal>) stands, unless there
are convincing reasons to change it.


</para>
</listitem>
<listitem>

<para>
 You can't use <literal>deriving</literal> to define instances of a
data type with existentially quantified data constructors.

Reason: in most cases it would not make sense. For example:;

<programlisting>
data T = forall a. MkT [a] deriving( Eq )
</programlisting>

To derive <literal>Eq</literal> in the standard way we would need to have equality
between the single component of two <function>MkT</function> constructors:

<programlisting>
instance Eq T where
  (MkT a) == (MkT b) = ???
</programlisting>

But <varname>a</varname> and <varname>b</varname> have distinct types, and so can't be compared.
It's just about possible to imagine examples in which the derived instance
would make sense, but it seems altogether simpler simply to prohibit such
declarations.  Define your own instances!
</para>
</listitem>

</itemizedlist>

</para>

</sect3>
</sect2>

<!-- ====================== Generalised algebraic data types =======================  -->

<sect2 id="gadt-style">
<title>Declaring data types with explicit constructor signatures</title>

<para>When the <literal>GADTSyntax</literal> extension is enabled,
GHC allows you to declare an algebraic data type by
giving the type signatures of constructors explicitly.  For example:
<programlisting>
  data Maybe a where
      Nothing :: Maybe a
      Just    :: a -> Maybe a
</programlisting>
The form is called a "GADT-style declaration"
because Generalised Algebraic Data Types, described in <xref linkend="gadt"/>,
can only be declared using this form.</para>
<para>Notice that GADT-style syntax generalises existential types (<xref linkend="existential-quantification"/>).
For example, these two declarations are equivalent:
<programlisting>
  data Foo = forall a. MkFoo a (a -> Bool)
  data Foo' where { MKFoo :: a -> (a->Bool) -> Foo' }
</programlisting>
</para>
<para>Any data type that can be declared in standard Haskell-98 syntax
can also be declared using GADT-style syntax.
The choice is largely stylistic, but GADT-style declarations differ in one important respect:
they treat class constraints on the data constructors differently.
Specifically, if the constructor is given a type-class context, that
context is made available by pattern matching.  For example:
<programlisting>
  data Set a where
    MkSet :: Eq a => [a] -> Set a

  makeSet :: Eq a => [a] -> Set a
  makeSet xs = MkSet (nub xs)

  insert :: a -> Set a -> Set a
  insert a (MkSet as) | a `elem` as = MkSet as
                      | otherwise   = MkSet (a:as)
</programlisting>
A use of <literal>MkSet</literal> as a constructor (e.g. in the definition of <literal>makeSet</literal>)
gives rise to a <literal>(Eq a)</literal>
constraint, as you would expect.  The new feature is that pattern-matching on <literal>MkSet</literal>
(as in the definition of <literal>insert</literal>) makes <emphasis>available</emphasis> an <literal>(Eq a)</literal>
context.  In implementation terms, the <literal>MkSet</literal> constructor has a hidden field that stores
the <literal>(Eq a)</literal> dictionary that is passed to <literal>MkSet</literal>; so
when pattern-matching that dictionary becomes available for the right-hand side of the match.
In the example, the equality dictionary is used to satisfy the equality constraint
generated by the call to <literal>elem</literal>, so that the type of
<literal>insert</literal> itself has no <literal>Eq</literal> constraint.
</para>
<para>
For example, one possible application is to reify dictionaries:
<programlisting>
   data NumInst a where
     MkNumInst :: Num a => NumInst a

   intInst :: NumInst Int
   intInst = MkNumInst

   plus :: NumInst a -> a -> a -> a
   plus MkNumInst p q = p + q
</programlisting>
Here, a value of type <literal>NumInst a</literal> is equivalent
to an explicit <literal>(Num a)</literal> dictionary.
</para>
<para>
All this applies to constructors declared using the syntax of <xref linkend="existential-with-context"/>.
For example, the <literal>NumInst</literal> data type above could equivalently be declared
like this:
<programlisting>
   data NumInst a
      = Num a => MkNumInst (NumInst a)
</programlisting>
Notice that, unlike the situation when declaring an existential, there is
no <literal>forall</literal>, because the <literal>Num</literal> constrains the
data type's universally quantified type variable <literal>a</literal>.
A constructor may have both universal and existential type variables: for example,
the following two declarations are equivalent:
<programlisting>
   data T1 a
	= forall b. (Num a, Eq b) => MkT1 a b
   data T2 a where
	MkT2 :: (Num a, Eq b) => a -> b -> T2 a
</programlisting>
</para>
<para>All this behaviour contrasts with Haskell 98's peculiar treatment of
contexts on a data type declaration (Section 4.2.1 of the Haskell 98 Report).
In Haskell 98 the definition
<programlisting>
  data Eq a => Set' a = MkSet' [a]
</programlisting>
gives <literal>MkSet'</literal> the same type as <literal>MkSet</literal> above.  But instead of
<emphasis>making available</emphasis> an <literal>(Eq a)</literal> constraint, pattern-matching
on <literal>MkSet'</literal> <emphasis>requires</emphasis> an <literal>(Eq a)</literal> constraint!
GHC faithfully implements this behaviour, odd though it is.  But for GADT-style declarations,
GHC's behaviour is much more useful, as well as much more intuitive.
</para>

<para>
The rest of this section gives further details about GADT-style data
type declarations.

<itemizedlist>
<listitem><para>
The result type of each data constructor must begin with the type constructor being defined.
If the result type of all constructors
has the form <literal>T a1 ... an</literal>, where <literal>a1 ... an</literal>
are distinct type variables, then the data type is <emphasis>ordinary</emphasis>;
otherwise is a <emphasis>generalised</emphasis> data type (<xref linkend="gadt"/>).
</para></listitem>

<listitem><para>
As with other type signatures, you can give a single signature for several data constructors.
In this example we give a single signature for <literal>T1</literal> and <literal>T2</literal>:
<programlisting>
  data T a where
    T1,T2 :: a -> T a
    T3 :: T a
</programlisting>
</para></listitem>

<listitem><para>
The type signature of
each constructor is independent, and is implicitly universally quantified as usual.
In particular, the type variable(s) in the "<literal>data T a where</literal>" header
have no scope, and different constructors may have different universally-quantified type variables:
<programlisting>
  data T a where        -- The 'a' has no scope
    T1,T2 :: b -> T b   -- Means forall b. b -> T b
    T3 :: T a           -- Means forall a. T a
</programlisting>
</para></listitem>

<listitem><para>
A constructor signature may mention type class constraints, which can differ for
different constructors.  For example, this is fine:
<programlisting>
  data T a where
    T1 :: Eq b => b -> b -> T b
    T2 :: (Show c, Ix c) => c -> [c] -> T c
</programlisting>
When pattern matching, these constraints are made available to discharge constraints
in the body of the match. For example:
<programlisting>
  f :: T a -> String
  f (T1 x y) | x==y      = "yes"
             | otherwise = "no"
  f (T2 a b)             = show a
</programlisting>
Note that <literal>f</literal> is not overloaded; the <literal>Eq</literal> constraint arising
from the use of <literal>==</literal> is discharged by the pattern match on <literal>T1</literal>
and similarly the <literal>Show</literal> constraint arising from the use of <literal>show</literal>.
</para></listitem>

<listitem><para>
Unlike a Haskell-98-style
data type declaration, the type variable(s) in the "<literal>data Set a where</literal>" header
have no scope.  Indeed, one can write a kind signature instead:
<programlisting>
  data Set :: * -> * where ...
</programlisting>
or even a mixture of the two:
<programlisting>
  data Bar a :: (* -> *) -> * where ...
</programlisting>
The type variables (if given) may be explicitly kinded, so we could also write the header for <literal>Foo</literal>
like this:
<programlisting>
  data Bar a (b :: * -> *) where ...
</programlisting>
</para></listitem>


<listitem><para>
You can use strictness annotations, in the obvious places
in the constructor type:
<programlisting>
  data Term a where
      Lit    :: !Int -> Term Int
      If     :: Term Bool -> !(Term a) -> !(Term a) -> Term a
      Pair   :: Term a -> Term b -> Term (a,b)
</programlisting>
</para></listitem>

<listitem><para>
You can use a <literal>deriving</literal> clause on a GADT-style data type
declaration.   For example, these two declarations are equivalent
<programlisting>
  data Maybe1 a where {
      Nothing1 :: Maybe1 a ;
      Just1    :: a -> Maybe1 a
    } deriving( Eq, Ord )

  data Maybe2 a = Nothing2 | Just2 a
       deriving( Eq, Ord )
</programlisting>
</para></listitem>

<listitem><para>
The type signature may have quantified type variables that do not appear
in the result type:
<programlisting>
  data Foo where
     MkFoo :: a -> (a->Bool) -> Foo
     Nil   :: Foo
</programlisting>
Here the type variable <literal>a</literal> does not appear in the result type
of either constructor.
Although it is universally quantified in the type of the constructor, such
a type variable is often called "existential".
Indeed, the above declaration declares precisely the same type as
the <literal>data Foo</literal> in <xref linkend="existential-quantification"/>.
</para><para>
The type may contain a class context too, of course:
<programlisting>
  data Showable where
    MkShowable :: Show a => a -> Showable
</programlisting>
</para></listitem>

<listitem><para>
You can use record syntax on a GADT-style data type declaration:

<programlisting>
  data Person where
      Adult :: { name :: String, children :: [Person] } -> Person
      Child :: Show a => { name :: !String, funny :: a } -> Person
</programlisting>
As usual, for every constructor that has a field <literal>f</literal>, the type of
field <literal>f</literal> must be the same (modulo alpha conversion).
The <literal>Child</literal> constructor above shows that the signature
may have a context, existentially-quantified variables, and strictness annotations,
just as in the non-record case.  (NB: the "type" that follows the double-colon
is not really a type, because of the record syntax and strictness annotations.
A "type" of this form can appear only in a constructor signature.)
</para></listitem>

<listitem><para>
Record updates are allowed with GADT-style declarations,
only fields that have the following property: the type of the field
mentions no existential type variables.
</para></listitem>

<listitem><para>
As in the case of existentials declared using the Haskell-98-like record syntax
(<xref linkend="existential-records"/>),
record-selector functions are generated only for those fields that have well-typed
selectors.
Here is the example of that section, in GADT-style syntax:
<programlisting>
data Counter a where
    NewCounter { _this    :: self
               , _inc     :: self -> self
               , _display :: self -> IO ()
               , tag      :: a
               }
        :: Counter a
</programlisting>
As before, only one selector function is generated here, that for <literal>tag</literal>.
Nevertheless, you can still use all the field names in pattern matching and record construction.
</para></listitem>
</itemizedlist></para>
</sect2>

<sect2 id="gadt">
<title>Generalised Algebraic Data Types (GADTs)</title>

<para>Generalised Algebraic Data Types generalise ordinary algebraic data types
by allowing constructors to have richer return types.  Here is an example:
<programlisting>
  data Term a where
      Lit    :: Int -> Term Int
      Succ   :: Term Int -> Term Int
      IsZero :: Term Int -> Term Bool
      If     :: Term Bool -> Term a -> Term a -> Term a
      Pair   :: Term a -> Term b -> Term (a,b)
</programlisting>
Notice that the return type of the constructors is not always <literal>Term a</literal>, as is the
case with ordinary data types.  This generality allows us to
write a well-typed <literal>eval</literal> function
for these <literal>Terms</literal>:
<programlisting>
  eval :: Term a -> a
  eval (Lit i) 	    = i
  eval (Succ t)     = 1 + eval t
  eval (IsZero t)   = eval t == 0
  eval (If b e1 e2) = if eval b then eval e1 else eval e2
  eval (Pair e1 e2) = (eval e1, eval e2)
</programlisting>
The key point about GADTs is that <emphasis>pattern matching causes type refinement</emphasis>.
For example, in the right hand side of the equation
<programlisting>
  eval :: Term a -> a
  eval (Lit i) =  ...
</programlisting>
the type <literal>a</literal> is refined to <literal>Int</literal>.  That's the whole point!
A precise specification of the type rules is beyond what this user manual aspires to,
but the design closely follows that described in
the paper <ulink
url="http://research.microsoft.com/%7Esimonpj/papers/gadt/">Simple
unification-based type inference for GADTs</ulink>,
(ICFP 2006).
The general principle is this: <emphasis>type refinement is only carried out
based on user-supplied type annotations</emphasis>.
So if no type signature is supplied for <literal>eval</literal>, no type refinement happens,
and lots of obscure error messages will
occur.  However, the refinement is quite general.  For example, if we had:
<programlisting>
  eval :: Term a -> a -> a
  eval (Lit i) j =  i+j
</programlisting>
the pattern match causes the type <literal>a</literal> to be refined to <literal>Int</literal> (because of the type
of the constructor <literal>Lit</literal>), and that refinement also applies to the type of <literal>j</literal>, and
the result type of the <literal>case</literal> expression.  Hence the addition <literal>i+j</literal> is legal.
</para>
<para>
These and many other examples are given in papers by Hongwei Xi, and
Tim Sheard. There is a longer introduction
<ulink url="http://www.haskell.org/haskellwiki/GADT">on the wiki</ulink>,
and Ralf Hinze's
<ulink url="http://www.informatik.uni-bonn.de/~ralf/publications/With.pdf">Fun with phantom types</ulink> also has a number of examples. Note that papers
may use different notation to that implemented in GHC.
</para>
<para>
The rest of this section outlines the extensions to GHC that support GADTs.   The extension is enabled with
<option>-XGADTs</option>.  The <option>-XGADTs</option> flag also sets <option>-XRelaxedPolyRec</option>.
<itemizedlist>
<listitem><para>
A GADT can only be declared using GADT-style syntax (<xref linkend="gadt-style"/>);
the old Haskell-98 syntax for data declarations always declares an ordinary data type.
The result type of each constructor must begin with the type constructor being defined,
but for a GADT the arguments to the type constructor can be arbitrary monotypes.
For example, in the <literal>Term</literal> data
type above, the type of each constructor must end with <literal>Term ty</literal>, but
the <literal>ty</literal> need not be a type variable (e.g. the <literal>Lit</literal>
constructor).
</para></listitem>

<listitem><para>
It is permitted to declare an ordinary algebraic data type using GADT-style syntax.
What makes a GADT into a GADT is not the syntax, but rather the presence of data constructors
whose result type is not just <literal>T a b</literal>.
</para></listitem>

<listitem><para>
You cannot use a <literal>deriving</literal> clause for a GADT; only for
an ordinary data type.
</para></listitem>

<listitem><para>
As mentioned in <xref linkend="gadt-style"/>, record syntax is supported.
For example:
<programlisting>
  data Term a where
      Lit    { val  :: Int }      :: Term Int
      Succ   { num  :: Term Int } :: Term Int
      Pred   { num  :: Term Int } :: Term Int
      IsZero { arg  :: Term Int } :: Term Bool
      Pair   { arg1 :: Term a
             , arg2 :: Term b
             }                    :: Term (a,b)
      If     { cnd  :: Term Bool
             , tru  :: Term a
             , fls  :: Term a
             }                    :: Term a
</programlisting>
However, for GADTs there is the following additional constraint:
every constructor that has a field <literal>f</literal> must have
the same result type (modulo alpha conversion)
Hence, in the above example, we cannot merge the <literal>num</literal>
and <literal>arg</literal> fields above into a
single name.  Although their field types are both <literal>Term Int</literal>,
their selector functions actually have different types:

<programlisting>
  num :: Term Int -> Term Int
  arg :: Term Bool -> Term Int
</programlisting>
</para></listitem>

<listitem><para>
When pattern-matching against data constructors drawn from a GADT,
for example in a <literal>case</literal> expression, the following rules apply:
<itemizedlist>
<listitem><para>The type of the scrutinee must be rigid.</para></listitem>
<listitem><para>The type of the entire <literal>case</literal> expression must be rigid.</para></listitem>
<listitem><para>The type of any free variable mentioned in any of
the <literal>case</literal> alternatives must be rigid.</para></listitem>
</itemizedlist>
A type is "rigid" if it is completely known to the compiler at its binding site.  The easiest
way to ensure that a variable a rigid type is to give it a type signature.
For more precise details see <ulink url="http://research.microsoft.com/%7Esimonpj/papers/gadt">
Simple unification-based type inference for GADTs
</ulink>. The criteria implemented by GHC are given in the Appendix.

</para></listitem>

</itemizedlist>
</para>

</sect2>
</sect1>

<!-- ====================== End of Generalised algebraic data types =======================  -->

<sect1 id="deriving">
<title>Extensions to the "deriving" mechanism</title>

<sect2 id="deriving-inferred">
<title>Inferred context for deriving clauses</title>

<para>
The Haskell Report is vague about exactly when a <literal>deriving</literal> clause is
legal.  For example:
<programlisting>
  data T0 f a = MkT0 a         deriving( Eq )
  data T1 f a = MkT1 (f a)     deriving( Eq )
  data T2 f a = MkT2 (f (f a)) deriving( Eq )
</programlisting>
The natural generated <literal>Eq</literal> code would result in these instance declarations:
<programlisting>
  instance Eq a         => Eq (T0 f a) where ...
  instance Eq (f a)     => Eq (T1 f a) where ...
  instance Eq (f (f a)) => Eq (T2 f a) where ...
</programlisting>
The first of these is obviously fine. The second is still fine, although less obviously.
The third is not Haskell 98, and risks losing termination of instances.
</para>
<para>
GHC takes a conservative position: it accepts the first two, but not the third.  The  rule is this:
each constraint in the inferred instance context must consist only of type variables,
with no repetitions.
</para>
<para>
This rule is applied regardless of flags.  If you want a more exotic context, you can write
it yourself, using the <link linkend="stand-alone-deriving">standalone deriving mechanism</link>.
</para>
</sect2>

<sect2 id="stand-alone-deriving">
<title>Stand-alone deriving declarations</title>

<para>
GHC now allows stand-alone <literal>deriving</literal> declarations, enabled by <literal>-XStandaloneDeriving</literal>:
<programlisting>
  data Foo a = Bar a | Baz String

  deriving instance Eq a => Eq (Foo a)
</programlisting>
The syntax is identical to that of an ordinary instance declaration apart from (a) the keyword
<literal>deriving</literal>, and (b) the absence of the <literal>where</literal> part.
Note the following points:
<itemizedlist>
<listitem><para>
You must supply an explicit context (in the example the context is <literal>(Eq a)</literal>),
exactly as you would in an ordinary instance declaration.
(In contrast, in a <literal>deriving</literal> clause
attached to a data type declaration, the context is inferred.)
</para></listitem>

<listitem><para>
A <literal>deriving instance</literal> declaration
must obey the same rules concerning form and termination as ordinary instance declarations,
controlled by the same flags; see <xref linkend="instance-decls"/>.
</para></listitem>

<listitem><para>
Unlike a <literal>deriving</literal>
declaration attached to a <literal>data</literal> declaration, the instance can be more specific
than the data type (assuming you also use
<literal>-XFlexibleInstances</literal>, <xref linkend="instance-rules"/>).  Consider
for example
<programlisting>
  data Foo a = Bar a | Baz String

  deriving instance Eq a => Eq (Foo [a])
  deriving instance Eq a => Eq (Foo (Maybe a))
</programlisting>
This will generate a derived instance for <literal>(Foo [a])</literal> and <literal>(Foo (Maybe a))</literal>,
but other types such as <literal>(Foo (Int,Bool))</literal> will not be an instance of <literal>Eq</literal>.
</para></listitem>

<listitem><para>
Unlike a <literal>deriving</literal>
declaration attached to a <literal>data</literal> declaration,
GHC does not restrict the form of the data type.  Instead, GHC simply generates the appropriate
boilerplate code for the specified class, and typechecks it. If there is a type error, it is
your problem. (GHC will show you the offending code if it has a type error.)
The merit of this is that you can derive instances for GADTs and other exotic
data types, providing only that the boilerplate code does indeed typecheck.  For example:
<programlisting>
  data T a where
     T1 :: T Int
     T2 :: T Bool

  deriving instance Show (T a)
</programlisting>
In this example, you cannot say <literal>... deriving( Show )</literal> on the
data type declaration for <literal>T</literal>,
because <literal>T</literal> is a GADT, but you <emphasis>can</emphasis> generate
the instance declaration using stand-alone deriving.
</para>
</listitem>

<listitem>
<para>The stand-alone syntax is generalised for newtypes in exactly the same
way that ordinary <literal>deriving</literal> clauses are generalised (<xref linkend="newtype-deriving"/>).
For example:
<programlisting>
  newtype Foo a = MkFoo (State Int a)

  deriving instance MonadState Int Foo
</programlisting>
GHC always treats the <emphasis>last</emphasis> parameter of the instance
(<literal>Foo</literal> in this example) as the type whose instance is being derived.
</para></listitem>
</itemizedlist></para>

</sect2>


<sect2 id="deriving-typeable">
<title>Deriving clause for extra classes (<literal>Typeable</literal>, <literal>Data</literal>, etc)</title>

<para>
Haskell 98 allows the programmer to add "<literal>deriving( Eq, Ord )</literal>" to a data type
declaration, to generate a standard instance declaration for classes specified in the <literal>deriving</literal> clause.
In Haskell 98, the only classes that may appear in the <literal>deriving</literal> clause are the standard
classes <literal>Eq</literal>, <literal>Ord</literal>,
<literal>Enum</literal>, <literal>Ix</literal>, <literal>Bounded</literal>, <literal>Read</literal>, and <literal>Show</literal>.
</para>
<para>
GHC extends this list with several more classes that may be automatically derived:
<itemizedlist>
<listitem><para> With <option>-XDeriveDataTypeable</option>, you can derive instances of the classes
<literal>Typeable</literal>, and <literal>Data</literal>, defined in the library
modules <literal>Data.Typeable</literal> and <literal>Data.Generics</literal> respectively.
</para>
<para>An instance of <literal>Typeable</literal> can only be derived if the
data type has seven or fewer type parameters, all of kind <literal>*</literal>.
The reason for this is that the <literal>Typeable</literal> class is derived using the scheme
described in
<ulink url="http://research.microsoft.com/%7Esimonpj/papers/hmap/gmap2.ps">
Scrap More Boilerplate: Reflection, Zips, and Generalised Casts
</ulink>.
(Section 7.4 of the paper describes the multiple <literal>Typeable</literal> classes that
are used, and only <literal>Typeable1</literal> up to
<literal>Typeable7</literal> are provided in the library.)
In other cases, there is nothing to stop the programmer writing a <literal>TypeableX</literal>
class, whose kind suits that of the data type constructor, and
then writing the data type instance by hand.
</para>
</listitem>

<listitem><para> With <option>-XDeriveGeneric</option>, you can derive
instances of  the class <literal>Generic</literal>, defined in
<literal>GHC.Generics</literal>. You can use these to define generic functions,
as described in <xref linkend="generic-programming"/>.
</para></listitem>

<listitem><para> With <option>-XDeriveFunctor</option>, you can derive instances of
the class <literal>Functor</literal>,
defined in <literal>GHC.Base</literal>.
</para></listitem>

<listitem><para> With <option>-XDeriveFoldable</option>, you can derive instances of
the class <literal>Foldable</literal>,
defined in <literal>Data.Foldable</literal>.
</para></listitem>

<listitem><para> With <option>-XDeriveTraversable</option>, you can derive instances of
the class <literal>Traversable</literal>,
defined in <literal>Data.Traversable</literal>.
</para></listitem>
</itemizedlist>
In each case the appropriate class must be in scope before it
can be mentioned in the <literal>deriving</literal> clause.
</para>
</sect2>

<sect2 id="newtype-deriving">
<title>Generalised derived instances for newtypes</title>

<para>
When you define an abstract type using <literal>newtype</literal>, you may want
the new type to inherit some instances from its representation. In
Haskell 98, you can inherit instances of <literal>Eq</literal>, <literal>Ord</literal>,
<literal>Enum</literal> and <literal>Bounded</literal> by deriving them, but for any
other classes you have to write an explicit instance declaration. For
example, if you define

<programlisting>
  newtype Dollars = Dollars Int
</programlisting>

and you want to use arithmetic on <literal>Dollars</literal>, you have to
explicitly define an instance of <literal>Num</literal>:

<programlisting>
  instance Num Dollars where
    Dollars a + Dollars b = Dollars (a+b)
    ...
</programlisting>
All the instance does is apply and remove the <literal>newtype</literal>
constructor. It is particularly galling that, since the constructor
doesn't appear at run-time, this instance declaration defines a
dictionary which is <emphasis>wholly equivalent</emphasis> to the <literal>Int</literal>
dictionary, only slower!
</para>


<sect3> <title> Generalising the deriving clause </title>
<para>
GHC now permits such instances to be derived instead,
using the flag <option>-XGeneralizedNewtypeDeriving</option>,
so one can write
<programlisting>
  newtype Dollars = Dollars Int deriving (Eq,Show,Num)
</programlisting>

and the implementation uses the <emphasis>same</emphasis> <literal>Num</literal> dictionary
for <literal>Dollars</literal> as for <literal>Int</literal>. Notionally, the compiler
derives an instance declaration of the form

<programlisting>
  instance Num Int => Num Dollars
</programlisting>

which just adds or removes the <literal>newtype</literal> constructor according to the type.
</para>
<para>

We can also derive instances of constructor classes in a similar
way. For example, suppose we have implemented state and failure monad
transformers, such that

<programlisting>
  instance Monad m => Monad (State s m)
  instance Monad m => Monad (Failure m)
</programlisting>
In Haskell 98, we can define a parsing monad by
<programlisting>
  type Parser tok m a = State [tok] (Failure m) a
</programlisting>

which is automatically a monad thanks to the instance declarations
above. With the extension, we can make the parser type abstract,
without needing to write an instance of class <literal>Monad</literal>, via

<programlisting>
  newtype Parser tok m a = Parser (State [tok] (Failure m) a)
                         deriving Monad
</programlisting>
In this case the derived instance declaration is of the form
<programlisting>
  instance Monad (State [tok] (Failure m)) => Monad (Parser tok m)
</programlisting>

Notice that, since <literal>Monad</literal> is a constructor class, the
instance is a <emphasis>partial application</emphasis> of the new type, not the
entire left hand side. We can imagine that the type declaration is
"eta-converted" to generate the context of the instance
declaration.
</para>
<para>

We can even derive instances of multi-parameter classes, provided the
newtype is the last class parameter. In this case, a ``partial
application'' of the class appears in the <literal>deriving</literal>
clause. For example, given the class

<programlisting>
  class StateMonad s m | m -> s where ...
  instance Monad m => StateMonad s (State s m) where ...
</programlisting>
then we can derive an instance of <literal>StateMonad</literal> for <literal>Parser</literal>s by
<programlisting>
  newtype Parser tok m a = Parser (State [tok] (Failure m) a)
                         deriving (Monad, StateMonad [tok])
</programlisting>

The derived instance is obtained by completing the application of the
class to the new type:

<programlisting>
  instance StateMonad [tok] (State [tok] (Failure m)) =>
           StateMonad [tok] (Parser tok m)
</programlisting>
</para>
<para>

As a result of this extension, all derived instances in newtype
 declarations are treated uniformly (and implemented just by reusing
the dictionary for the representation type), <emphasis>except</emphasis>
<literal>Show</literal> and <literal>Read</literal>, which really behave differently for
the newtype and its representation.
</para>
</sect3>

<sect3> <title> A more precise specification </title>
<para>
Derived instance declarations are constructed as follows. Consider the
declaration (after expansion of any type synonyms)

<programlisting>
  newtype T v1...vn = T' (t vk+1...vn) deriving (c1...cm)
</programlisting>

where
 <itemizedlist>
<listitem><para>
  The <literal>ci</literal> are partial applications of
  classes of the form <literal>C t1'...tj'</literal>, where the arity of <literal>C</literal>
  is exactly <literal>j+1</literal>.  That is, <literal>C</literal> lacks exactly one type argument.
</para></listitem>
<listitem><para>
  The <literal>k</literal> is chosen so that <literal>ci (T v1...vk)</literal> is well-kinded.
</para></listitem>
<listitem><para>
  The type <literal>t</literal> is an arbitrary type.
</para></listitem>
<listitem><para>
  The type variables <literal>vk+1...vn</literal> do not occur in <literal>t</literal>,
  nor in the <literal>ci</literal>, and
</para></listitem>
<listitem><para>
  None of the <literal>ci</literal> is <literal>Read</literal>, <literal>Show</literal>,
		<literal>Typeable</literal>, or <literal>Data</literal>.  These classes
		should not "look through" the type or its constructor.  You can still
		derive these classes for a newtype, but it happens in the usual way, not
		via this new mechanism.
</para></listitem>
</itemizedlist>
Then, for each <literal>ci</literal>, the derived instance
declaration is:
<programlisting>
  instance ci t => ci (T v1...vk)
</programlisting>
As an example which does <emphasis>not</emphasis> work, consider
<programlisting>
  newtype NonMonad m s = NonMonad (State s m s) deriving Monad
</programlisting>
Here we cannot derive the instance
<programlisting>
  instance Monad (State s m) => Monad (NonMonad m)
</programlisting>

because the type variable <literal>s</literal> occurs in <literal>State s m</literal>,
and so cannot be "eta-converted" away. It is a good thing that this
<literal>deriving</literal> clause is rejected, because <literal>NonMonad m</literal> is
not, in fact, a monad --- for the same reason. Try defining
<literal>>>=</literal> with the correct type: you won't be able to.
</para>
<para>

Notice also that the <emphasis>order</emphasis> of class parameters becomes
important, since we can only derive instances for the last one. If the
<literal>StateMonad</literal> class above were instead defined as

<programlisting>
  class StateMonad m s | m -> s where ...
</programlisting>

then we would not have been able to derive an instance for the
<literal>Parser</literal> type above. We hypothesise that multi-parameter
classes usually have one "main" parameter for which deriving new
instances is most interesting.
</para>
<para>Lastly, all of this applies only for classes other than
<literal>Read</literal>, <literal>Show</literal>, <literal>Typeable</literal>,
and <literal>Data</literal>, for which the built-in derivation applies (section
4.3.3. of the Haskell Report).
(For the standard classes <literal>Eq</literal>, <literal>Ord</literal>,
<literal>Ix</literal>, and <literal>Bounded</literal> it is immaterial whether
the standard method is used or the one described here.)
</para>
</sect3>
</sect2>
</sect1>


<!-- TYPE SYSTEM EXTENSIONS -->
<sect1 id="type-class-extensions">
<title>Class and instances declarations</title>

<sect2 id="multi-param-type-classes">
<title>Class declarations</title>

<para>
This section, and the next one, documents GHC's type-class extensions.
There's lots of background in the paper <ulink
url="http://research.microsoft.com/~simonpj/Papers/type-class-design-space/">Type
classes: exploring the design space</ulink> (Simon Peyton Jones, Mark
Jones, Erik Meijer).
</para>

<sect3>
<title>Multi-parameter type classes</title>
<para>
Multi-parameter type classes are permitted, with flag <option>-XMultiParamTypeClasses</option>.
For example:


<programlisting>
  class Collection c a where
    union :: c a -> c a -> c a
    ...etc.
</programlisting>

</para>
</sect3>

<sect3 id="superclass-rules">
<title>The superclasses of a class declaration</title>

<para>
In Haskell 98 the context of a class declaration (which introduces superclasses)
must be simple; that is, each predicate must consist of a class applied to
type variables.  The flag <option>-XFlexibleContexts</option>
(<xref linkend="flexible-contexts"/>)
lifts this restriction,
so that the only restriction on the context in a class declaration is
that the class hierarchy must be acyclic.  So these class declarations are OK:


<programlisting>
  class Functor (m k) => FiniteMap m k where
    ...

  class (Monad m, Monad (t m)) => Transform t m where
    lift :: m a -> (t m) a
</programlisting>


</para>
<para>
As in Haskell 98, The class hierarchy must be acyclic.  However, the definition
of "acyclic" involves only the superclass relationships.  For example,
this is OK:


<programlisting>
  class C a where {
    op :: D b => a -> b -> b
  }

  class C a => D a where { ... }
</programlisting>


Here, <literal>C</literal> is a superclass of <literal>D</literal>, but it's OK for a
class operation <literal>op</literal> of <literal>C</literal> to mention <literal>D</literal>.  (It
would not be OK for <literal>D</literal> to be a superclass of <literal>C</literal>.)
</para>
<para>
With the extension that adds a <link linkend="constraint-kind">kind of constraints</link>,
you can write more exotic superclass definitions. The superclass cycle check is even more
liberal in these case. For example, this is OK:

<programlisting>
  class A cls c where
    meth :: cls c => c -> c

  class A B c => B c where
</programlisting>

A superclass context for a class <literal>C</literal> is allowed if, after expanding
type synonyms to their right-hand-sides, and uses of classes (other than <literal>C</literal>)
to their superclasses, <literal>C</literal> does not occur syntactically in the context.
</para>
</sect3>




<sect3 id="class-method-types">
<title>Class method types</title>

<para>
Haskell 98 prohibits class method types to mention constraints on the
class type variable, thus:
<programlisting>
  class Seq s a where
    fromList :: [a] -> s a
    elem     :: Eq a => a -> s a -> Bool
</programlisting>
The type of <literal>elem</literal> is illegal in Haskell 98, because it
contains the constraint <literal>Eq a</literal>, constrains only the
class type variable (in this case <literal>a</literal>).
GHC lifts this restriction (flag <option>-XConstrainedClassMethods</option>).
</para>


</sect3>


<sect3 id="class-default-signatures">
<title>Default method signatures</title>

<para>
Haskell 98 allows you to define a default implementation when declaring a class:
<programlisting>
  class Enum a where
    enum :: [a]
    enum = []
</programlisting>
The type of the <literal>enum</literal> method is <literal>[a]</literal>, and
this is also the type of the default method. You can lift this restriction
and give another type to the default method using the flag
<option>-XDefaultSignatures</option>. For instance, if you have written a
generic implementation of enumeration in a class <literal>GEnum</literal>
with method <literal>genum</literal> in terms of <literal>GHC.Generics</literal>,
you can specify a default method that uses that generic implementation:
<programlisting>
  class Enum a where
    enum :: [a]
    default enum :: (Generic a, GEnum (Rep a)) => [a]
    enum = map to genum
</programlisting>
We reuse the keyword <literal>default</literal> to signal that a signature
applies to the default method only; when defining instances of the
<literal>Enum</literal> class, the original type <literal>[a]</literal> of
<literal>enum</literal> still applies. When giving an empty instance, however,
the default implementation <literal>map to0 genum</literal> is filled-in,
and type-checked with the type
<literal>(Generic a, GEnum (Rep a)) => [a]</literal>.
</para>

<para>
We use default signatures to simplify generic programming in GHC
(<xref linkend="generic-programming"/>).
</para>


</sect3>
</sect2>

<sect2 id="functional-dependencies">
<title>Functional dependencies
</title>

<para> Functional dependencies are implemented as described by Mark Jones
in &ldquo;<ulink url="http://citeseer.ist.psu.edu/jones00type.html">Type Classes with Functional Dependencies</ulink>&rdquo;, Mark P. Jones,
In Proceedings of the 9th European Symposium on Programming,
ESOP 2000, Berlin, Germany, March 2000, Springer-Verlag LNCS 1782,
.
</para>
<para>
Functional dependencies are introduced by a vertical bar in the syntax of a
class declaration;  e.g.
<programlisting>
  class (Monad m) => MonadState s m | m -> s where ...

  class Foo a b c | a b -> c where ...
</programlisting>
There should be more documentation, but there isn't (yet).  Yell if you need it.
</para>

<sect3><title>Rules for functional dependencies </title>
<para>
In a class declaration, all of the class type variables must be reachable (in the sense
mentioned in <xref linkend="flexible-contexts"/>)
from the free variables of each method type.
For example:

<programlisting>
  class Coll s a where
    empty  :: s
    insert :: s -> a -> s
</programlisting>

is not OK, because the type of <literal>empty</literal> doesn't mention
<literal>a</literal>.  Functional dependencies can make the type variable
reachable:
<programlisting>
  class Coll s a | s -> a where
    empty  :: s
    insert :: s -> a -> s
</programlisting>

Alternatively <literal>Coll</literal> might be rewritten

<programlisting>
  class Coll s a where
    empty  :: s a
    insert :: s a -> a -> s a
</programlisting>


which makes the connection between the type of a collection of
<literal>a</literal>'s (namely <literal>(s a)</literal>) and the element type <literal>a</literal>.
Occasionally this really doesn't work, in which case you can split the
class like this:


<programlisting>
  class CollE s where
    empty  :: s

  class CollE s => Coll s a where
    insert :: s -> a -> s
</programlisting>
</para>
</sect3>


<sect3>
<title>Background on functional dependencies</title>

<para>The following description of the motivation and use of functional dependencies is taken
from the Hugs user manual, reproduced here (with minor changes) by kind
permission of Mark Jones.
</para>
<para>
Consider the following class, intended as part of a
library for collection types:
<programlisting>
   class Collects e ce where
       empty  :: ce
       insert :: e -> ce -> ce
       member :: e -> ce -> Bool
</programlisting>
The type variable e used here represents the element type, while ce is the type
of the container itself. Within this framework, we might want to define
instances of this class for lists or characteristic functions (both of which
can be used to represent collections of any equality type), bit sets (which can
be used to represent collections of characters), or hash tables (which can be
used to represent any collection whose elements have a hash function). Omitting
standard implementation details, this would lead to the following declarations:
<programlisting>
   instance Eq e => Collects e [e] where ...
   instance Eq e => Collects e (e -> Bool) where ...
   instance Collects Char BitSet where ...
   instance (Hashable e, Collects a ce)
              => Collects e (Array Int ce) where ...
</programlisting>
All this looks quite promising; we have a class and a range of interesting
implementations. Unfortunately, there are some serious problems with the class
declaration. First, the empty function has an ambiguous type:
<programlisting>
   empty :: Collects e ce => ce
</programlisting>
By "ambiguous" we mean that there is a type variable e that appears on the left
of the <literal>=&gt;</literal> symbol, but not on the right. The problem with
this is that, according to the theoretical foundations of Haskell overloading,
we cannot guarantee a well-defined semantics for any term with an ambiguous
type.
</para>
<para>
We can sidestep this specific problem by removing the empty member from the
class declaration. However, although the remaining members, insert and member,
do not have ambiguous types, we still run into problems when we try to use
them. For example, consider the following two functions:
<programlisting>
   f x y = insert x . insert y
   g     = f True 'a'
</programlisting>
for which GHC infers the following types:
<programlisting>
   f :: (Collects a c, Collects b c) => a -> b -> c -> c
   g :: (Collects Bool c, Collects Char c) => c -> c
</programlisting>
Notice that the type for f allows the two parameters x and y to be assigned
different types, even though it attempts to insert each of the two values, one
after the other, into the same collection. If we're trying to model collections
that contain only one type of value, then this is clearly an inaccurate
type. Worse still, the definition for g is accepted, without causing a type
error. As a result, the error in this code will not be flagged at the point
where it appears. Instead, it will show up only when we try to use g, which
might even be in a different module.
</para>

<sect4><title>An attempt to use constructor classes</title>

<para>
Faced with the problems described above, some Haskell programmers might be
tempted to use something like the following version of the class declaration:
<programlisting>
   class Collects e c where
      empty  :: c e
      insert :: e -> c e -> c e
      member :: e -> c e -> Bool
</programlisting>
The key difference here is that we abstract over the type constructor c that is
used to form the collection type c e, and not over that collection type itself,
represented by ce in the original class declaration. This avoids the immediate
problems that we mentioned above: empty has type <literal>Collects e c => c
e</literal>, which is not ambiguous.
</para>
<para>
The function f from the previous section has a more accurate type:
<programlisting>
   f :: (Collects e c) => e -> e -> c e -> c e
</programlisting>
The function g from the previous section is now rejected with a type error as
we would hope because the type of f does not allow the two arguments to have
different types.
This, then, is an example of a multiple parameter class that does actually work
quite well in practice, without ambiguity problems.
There is, however, a catch. This version of the Collects class is nowhere near
as general as the original class seemed to be: only one of the four instances
for <literal>Collects</literal>
given above can be used with this version of Collects because only one of
them---the instance for lists---has a collection type that can be written in
the form c e, for some type constructor c, and element type e.
</para>
</sect4>

<sect4><title>Adding functional dependencies</title>

<para>
To get a more useful version of the Collects class, Hugs provides a mechanism
that allows programmers to specify dependencies between the parameters of a
multiple parameter class (For readers with an interest in theoretical
foundations and previous work: The use of dependency information can be seen
both as a generalization of the proposal for `parametric type classes' that was
put forward by Chen, Hudak, and Odersky, or as a special case of Mark Jones's
later framework for "improvement" of qualified types. The
underlying ideas are also discussed in a more theoretical and abstract setting
in a manuscript [implparam], where they are identified as one point in a
general design space for systems of implicit parameterization.).

To start with an abstract example, consider a declaration such as:
<programlisting>
   class C a b where ...
</programlisting>
which tells us simply that C can be thought of as a binary relation on types
(or type constructors, depending on the kinds of a and b). Extra clauses can be
included in the definition of classes to add information about dependencies
between parameters, as in the following examples:
<programlisting>
   class D a b | a -> b where ...
   class E a b | a -> b, b -> a where ...
</programlisting>
The notation <literal>a -&gt; b</literal> used here between the | and where
symbols --- not to be
confused with a function type --- indicates that the a parameter uniquely
determines the b parameter, and might be read as "a determines b." Thus D is
not just a relation, but actually a (partial) function. Similarly, from the two
dependencies that are included in the definition of E, we can see that E
represents a (partial) one-one mapping between types.
</para>
<para>
More generally, dependencies take the form <literal>x1 ... xn -&gt; y1 ... ym</literal>,
where x1, ..., xn, and y1, ..., yn are type variables with n&gt;0 and
m&gt;=0, meaning that the y parameters are uniquely determined by the x
parameters. Spaces can be used as separators if more than one variable appears
on any single side of a dependency, as in <literal>t -&gt; a b</literal>. Note that a class may be
annotated with multiple dependencies using commas as separators, as in the
definition of E above. Some dependencies that we can write in this notation are
redundant, and will be rejected because they don't serve any useful
purpose, and may instead indicate an error in the program. Examples of
dependencies like this include  <literal>a -&gt; a </literal>,
<literal>a -&gt; a a </literal>,
<literal>a -&gt; </literal>, etc. There can also be
some redundancy if multiple dependencies are given, as in
<literal>a-&gt;b</literal>,
 <literal>b-&gt;c </literal>,  <literal>a-&gt;c </literal>, and
in which some subset implies the remaining dependencies. Examples like this are
not treated as errors. Note that dependencies appear only in class
declarations, and not in any other part of the language. In particular, the
syntax for instance declarations, class constraints, and types is completely
unchanged.
</para>
<para>
By including dependencies in a class declaration, we provide a mechanism for
the programmer to specify each multiple parameter class more precisely. The
compiler, on the other hand, is responsible for ensuring that the set of
instances that are in scope at any given point in the program is consistent
with any declared dependencies. For example, the following pair of instance
declarations cannot appear together in the same scope because they violate the
dependency for D, even though either one on its own would be acceptable:
<programlisting>
   instance D Bool Int where ...
   instance D Bool Char where ...
</programlisting>
Note also that the following declaration is not allowed, even by itself:
<programlisting>
   instance D [a] b where ...
</programlisting>
The problem here is that this instance would allow one particular choice of [a]
to be associated with more than one choice for b, which contradicts the
dependency specified in the definition of D. More generally, this means that,
in any instance of the form:
<programlisting>
   instance D t s where ...
</programlisting>
for some particular types t and s, the only variables that can appear in s are
the ones that appear in t, and hence, if the type t is known, then s will be
uniquely determined.
</para>
<para>
The benefit of including dependency information is that it allows us to define
more general multiple parameter classes, without ambiguity problems, and with
the benefit of more accurate types. To illustrate this, we return to the
collection class example, and annotate the original definition of <literal>Collects</literal>
with a simple dependency:
<programlisting>
   class Collects e ce | ce -> e where
      empty  :: ce
      insert :: e -> ce -> ce
      member :: e -> ce -> Bool
</programlisting>
The dependency <literal>ce -&gt; e</literal> here specifies that the type e of elements is uniquely
determined by the type of the collection ce. Note that both parameters of
Collects are of kind *; there are no constructor classes here. Note too that
all of the instances of Collects that we gave earlier can be used
together with this new definition.
</para>
<para>
What about the ambiguity problems that we encountered with the original
definition? The empty function still has type Collects e ce => ce, but it is no
longer necessary to regard that as an ambiguous type: Although the variable e
does not appear on the right of the => symbol, the dependency for class
Collects tells us that it is uniquely determined by ce, which does appear on
the right of the => symbol. Hence the context in which empty is used can still
give enough information to determine types for both ce and e, without
ambiguity. More generally, we need only regard a type as ambiguous if it
contains a variable on the left of the => that is not uniquely determined
(either directly or indirectly) by the variables on the right.
</para>
<para>
Dependencies also help to produce more accurate types for user defined
functions, and hence to provide earlier detection of errors, and less cluttered
types for programmers to work with. Recall the previous definition for a
function f:
<programlisting>
   f x y = insert x y = insert x . insert y
</programlisting>
for which we originally obtained a type:
<programlisting>
   f :: (Collects a c, Collects b c) => a -> b -> c -> c
</programlisting>
Given the dependency information that we have for Collects, however, we can
deduce that a and b must be equal because they both appear as the second
parameter in a Collects constraint with the same first parameter c. Hence we
can infer a shorter and more accurate type for f:
<programlisting>
   f :: (Collects a c) => a -> a -> c -> c
</programlisting>
In a similar way, the earlier definition of g will now be flagged as a type error.
</para>
<para>
Although we have given only a few examples here, it should be clear that the
addition of dependency information can help to make multiple parameter classes
more useful in practice, avoiding ambiguity problems, and allowing more general
sets of instance declarations.
</para>
</sect4>
</sect3>
</sect2>

<sect2 id="instance-decls">
<title>Instance declarations</title>

<para>An instance declaration has the form
<screen>
  instance ( <replaceable>assertion</replaceable><subscript>1</subscript>, ..., <replaceable>assertion</replaceable><subscript>n</subscript>) =&gt; <replaceable>class</replaceable> <replaceable>type</replaceable><subscript>1</subscript> ... <replaceable>type</replaceable><subscript>m</subscript> where ...
</screen>
The part before the "<literal>=&gt;</literal>" is the
<emphasis>context</emphasis>, while the part after the
"<literal>=&gt;</literal>" is the <emphasis>head</emphasis> of the instance declaration.
</para>

<sect3 id="flexible-instance-head">
<title>Relaxed rules for the instance head</title>

<para>
In Haskell 98 the head of an instance declaration
must be of the form <literal>C (T a1 ... an)</literal>, where
<literal>C</literal> is the class, <literal>T</literal> is a data type constructor,
and the <literal>a1 ... an</literal> are distinct type variables.
GHC relaxes these rules in two ways.
<itemizedlist>
<listitem>
<para>
The <option>-XFlexibleInstances</option> flag allows the head of the instance
declaration to mention arbitrary nested types.
For example, this becomes a legal instance declaration
<programlisting>
  instance C (Maybe Int) where ...
</programlisting>
See also the <link linkend="instance-overlap">rules on overlap</link>.
</para></listitem>
<listitem><para>
With the <option>-XTypeSynonymInstances</option> flag, instance heads may use type
synonyms. As always, using a type synonym is just shorthand for
writing the RHS of the type synonym definition.  For example:


<programlisting>
  type Point = (Int,Int)
  instance C Point   where ...
  instance C [Point] where ...
</programlisting>


is legal.  However, if you added


<programlisting>
  instance C (Int,Int) where ...
</programlisting>


as well, then the compiler will complain about the overlapping
(actually, identical) instance declarations.  As always, type synonyms
must be fully applied.  You cannot, for example, write:

<programlisting>
  type P a = [[a]]
  instance Monad P where ...
</programlisting>

</para></listitem>
</itemizedlist>
</para>
</sect3>

<sect3 id="instance-rules">
<title>Relaxed rules for instance contexts</title>

<para>In Haskell 98, the assertions in the context of the instance declaration
must be of the form <literal>C a</literal> where <literal>a</literal>
is a type variable that occurs in the head.
</para>

<para>
The <option>-XFlexibleContexts</option> flag relaxes this rule, as well
as the corresponding rule for type signatures (see <xref linkend="flexible-contexts"/>).
With this flag the context of the instance declaration can each consist of arbitrary
(well-kinded) assertions <literal>(C t1 ... tn)</literal> subject only to the
following rules:
<orderedlist>
<listitem><para>
The Paterson Conditions: for each assertion in the context
<orderedlist>
<listitem><para>No type variable has more occurrences in the assertion than in the head</para></listitem>
<listitem><para>The assertion has fewer constructors and variables (taken together
      and counting repetitions) than the head</para></listitem>
</orderedlist>
</para></listitem>

<listitem><para>The Coverage Condition.  For each functional dependency,
<replaceable>tvs</replaceable><subscript>left</subscript> <literal>-&gt;</literal>
<replaceable>tvs</replaceable><subscript>right</subscript>,  of the class,
every type variable in
S(<replaceable>tvs</replaceable><subscript>right</subscript>) must appear in
S(<replaceable>tvs</replaceable><subscript>left</subscript>), where S is the
substitution mapping each type variable in the class declaration to the
corresponding type in the instance declaration.
</para></listitem>
</orderedlist>
These restrictions ensure that context reduction terminates: each reduction
step makes the problem smaller by at least one
constructor.  Both the Paterson Conditions and the Coverage Condition are lifted
if you give the <option>-XUndecidableInstances</option>
flag (<xref linkend="undecidable-instances"/>).
You can find lots of background material about the reason for these
restrictions in the paper <ulink
url="http://research.microsoft.com/%7Esimonpj/papers/fd%2Dchr/">
Understanding functional dependencies via Constraint Handling Rules</ulink>.
</para>
<para>
For example, these are OK:
<programlisting>
  instance C Int [a]          -- Multiple parameters
  instance Eq (S [a])         -- Structured type in head

      -- Repeated type variable in head
  instance C4 a a => C4 [a] [a]
  instance Stateful (ST s) (MutVar s)

      -- Head can consist of type variables only
  instance C a
  instance (Eq a, Show b) => C2 a b

      -- Non-type variables in context
  instance Show (s a) => Show (Sized s a)
  instance C2 Int a => C3 Bool [a]
  instance C2 Int a => C3 [a] b
</programlisting>
But these are not:
<programlisting>
      -- Context assertion no smaller than head
  instance C a => C a where ...
      -- (C b b) has more occurrences of b than the head
  instance C b b => Foo [b] where ...
</programlisting>
</para>

<para>
The same restrictions apply to instances generated by
<literal>deriving</literal> clauses.  Thus the following is accepted:
<programlisting>
  data MinHeap h a = H a (h a)
    deriving (Show)
</programlisting>
because the derived instance
<programlisting>
  instance (Show a, Show (h a)) => Show (MinHeap h a)
</programlisting>
conforms to the above rules.
</para>

<para>
A useful idiom permitted by the above rules is as follows.
If one allows overlapping instance declarations then it's quite
convenient to have a "default instance" declaration that applies if
something more specific does not:
<programlisting>
  instance C a where
    op = ... -- Default
</programlisting>
</para>
</sect3>

<sect3 id="undecidable-instances">
<title>Undecidable instances</title>

<para>
Sometimes even the rules of <xref linkend="instance-rules"/> are too onerous.
For example, sometimes you might want to use the following to get the
effect of a "class synonym":
<programlisting>
  class (C1 a, C2 a, C3 a) => C a where { }

  instance (C1 a, C2 a, C3 a) => C a where { }
</programlisting>
This allows you to write shorter signatures:
<programlisting>
  f :: C a => ...
</programlisting>
instead of
<programlisting>
  f :: (C1 a, C2 a, C3 a) => ...
</programlisting>
The restrictions on functional dependencies (<xref
linkend="functional-dependencies"/>) are particularly troublesome.
It is tempting to introduce type variables in the context that do not appear in
the head, something that is excluded by the normal rules. For example:
<programlisting>
  class HasConverter a b | a -> b where
     convert :: a -> b

  data Foo a = MkFoo a

  instance (HasConverter a b,Show b) => Show (Foo a) where
     show (MkFoo value) = show (convert value)
</programlisting>
This is dangerous territory, however. Here, for example, is a program that would make the
typechecker loop:
<programlisting>
  class D a
  class F a b | a->b
  instance F [a] [[a]]
  instance (D c, F a c) => D [a]   -- 'c' is not mentioned in the head
</programlisting>
Similarly, it can be tempting to lift the coverage condition:
<programlisting>
  class Mul a b c | a b -> c where
  	(.*.) :: a -> b -> c

  instance Mul Int Int Int where (.*.) = (*)
  instance Mul Int Float Float where x .*. y = fromIntegral x * y
  instance Mul a b c => Mul a [b] [c] where x .*. v = map (x.*.) v
</programlisting>
The third instance declaration does not obey the coverage condition;
and indeed the (somewhat strange) definition:
<programlisting>
  f = \ b x y -> if b then x .*. [y] else y
</programlisting>
makes instance inference go into a loop, because it requires the constraint
<literal>(Mul a [b] b)</literal>.
</para>
<para>
Nevertheless, GHC allows you to experiment with more liberal rules.  If you use
the experimental flag <option>-XUndecidableInstances</option>
<indexterm><primary>-XUndecidableInstances</primary></indexterm>,
both the Paterson Conditions and the Coverage Condition
(described in <xref linkend="instance-rules"/>) are lifted.  Termination is ensured by having a
fixed-depth recursion stack.  If you exceed the stack depth you get a
sort of backtrace, and the opportunity to increase the stack depth
with <option>-fcontext-stack=</option><emphasis>N</emphasis>.
</para>

</sect3>


<sect3 id="instance-overlap">
<title>Overlapping instances</title>
<para>
In general, <emphasis>GHC requires that that it be unambiguous which instance
declaration
should be used to resolve a type-class constraint</emphasis>. This behaviour
can be modified by two flags: <option>-XOverlappingInstances</option>
<indexterm><primary>-XOverlappingInstances
</primary></indexterm>
and <option>-XIncoherentInstances</option>
<indexterm><primary>-XIncoherentInstances
</primary></indexterm>, as this section discusses.  Both these
flags are dynamic flags, and can be set on a per-module basis, using
an <literal>OPTIONS_GHC</literal> pragma if desired (<xref linkend="source-file-options"/>).</para>
<para>
When GHC tries to resolve, say, the constraint <literal>C Int Bool</literal>,
it tries to match every instance declaration against the
constraint,
by instantiating the head of the instance declaration.  For example, consider
these declarations:
<programlisting>
  instance context1 => C Int a     where ...  -- (A)
  instance context2 => C a   Bool  where ...  -- (B)
  instance context3 => C Int [a]   where ...  -- (C)
  instance context4 => C Int [Int] where ...  -- (D)
</programlisting>
The instances (A) and (B) match the constraint <literal>C Int Bool</literal>,
but (C) and (D) do not.  When matching, GHC takes
no account of the context of the instance declaration
(<literal>context1</literal> etc).
GHC's default behaviour is that <emphasis>exactly one instance must match the
constraint it is trying to resolve</emphasis>.
It is fine for there to be a <emphasis>potential</emphasis> of overlap (by
including both declarations (A) and (B), say); an error is only reported if a
particular constraint matches more than one.
</para>

<para>
The <option>-XOverlappingInstances</option> flag instructs GHC to allow
more than one instance to match, provided there is a most specific one.  For
example, the constraint <literal>C Int [Int]</literal> matches instances (A),
(C) and (D), but the last is more specific, and hence is chosen.  If there is no
most-specific match, the program is rejected.
</para>
<para>
However, GHC is conservative about committing to an overlapping instance.  For example:
<programlisting>
  f :: [b] -> [b]
  f x = ...
</programlisting>
Suppose that from the RHS of <literal>f</literal> we get the constraint
<literal>C Int [b]</literal>.  But
GHC does not commit to instance (C), because in a particular
call of <literal>f</literal>, <literal>b</literal> might be instantiate
to <literal>Int</literal>, in which case instance (D) would be more specific still.
So GHC rejects the program.
(If you add the flag <option>-XIncoherentInstances</option>,
GHC will instead pick (C), without complaining about
the problem of subsequent instantiations.)
</para>
<para>
Notice that we gave a type signature to <literal>f</literal>, so GHC had to
<emphasis>check</emphasis> that <literal>f</literal> has the specified type.
Suppose instead we do not give a type signature, asking GHC to <emphasis>infer</emphasis>
it instead.  In this case, GHC will refrain from
simplifying the constraint <literal>C Int [b]</literal> (for the same reason
as before) but, rather than rejecting the program, it will infer the type
<programlisting>
  f :: C Int [b] => [b] -> [b]
</programlisting>
That postpones the question of which instance to pick to the
call site for <literal>f</literal>
by which time more is known about the type <literal>b</literal>.
You can write this type signature yourself if you use the
<link linkend="flexible-contexts"><option>-XFlexibleContexts</option></link>
flag.
</para>
<para>
Exactly the same situation can arise in instance declarations themselves.  Suppose we have
<programlisting>
  class Foo a where
     f :: a -> a
  instance Foo [b] where
     f x = ...
</programlisting>
and, as before, the constraint <literal>C Int [b]</literal> arises from <literal>f</literal>'s
right hand side.  GHC will reject the instance, complaining as before that it does not know how to resolve
the constraint <literal>C Int [b]</literal>, because it matches more than one instance
declaration.  The solution is to postpone the choice by adding the constraint to the context
of the instance declaration, thus:
<programlisting>
  instance C Int [b] => Foo [b] where
     f x = ...
</programlisting>
(You need <link linkend="instance-rules"><option>-XFlexibleInstances</option></link> to do this.)
</para>
<para>
Warning: overlapping instances must be used with care.  They
can give rise to incoherence (i.e. different instance choices are made
in different parts of the program) even without <option>-XIncoherentInstances</option>. Consider:
<programlisting>
{-# LANGUAGE OverlappingInstances #-}
module Help where

    class MyShow a where
      myshow :: a -> String

    instance MyShow a => MyShow [a] where
      myshow xs = concatMap myshow xs

    showHelp :: MyShow a => [a] -> String
    showHelp xs = myshow xs

{-# LANGUAGE FlexibleInstances, OverlappingInstances #-}
module Main where
    import Help

    data T = MkT

    instance MyShow T where
      myshow x = "Used generic instance"

    instance MyShow [T] where
      myshow xs = "Used more specific instance"

    main = do { print (myshow [MkT]); print (showHelp [MkT]) }
</programlisting>
In function <literal>showHelp</literal> GHC sees no overlapping
instances, and so uses the <literal>MyShow [a]</literal> instance
without complaint.  In the call to <literal>myshow</literal> in <literal>main</literal>,
GHC resolves the <literal>MyShow [T]</literal> constraint using the overlapping
instance declaration in module <literal>Main</literal>. As a result,
the program prints
<programlisting>
  "Used more specific instance"
  "Used generic instance"
</programlisting>
(An alternative possible behaviour, not currently implemented,
would be to reject module <literal>Help</literal>
on the grounds that a later instance declaration might overlap the local one.)
</para>
<para>
The willingness to be overlapped or incoherent is a property of
the <emphasis>instance declaration</emphasis> itself, controlled by the
presence or otherwise of the <option>-XOverlappingInstances</option>
and <option>-XIncoherentInstances</option> flags when that module is
being defined.  Specifically, during the lookup process:
<itemizedlist>
<listitem><para>
If the constraint being looked up matches two instance declarations IA and IB,
and
<itemizedlist>
<listitem><para>IB is a substitution instance of IA (but not vice versa);
that is, IB is strictly more specific than IA</para></listitem>
<listitem><para>either IA or IB was compiled with <option>-XOverlappingInstances</option></para></listitem>
</itemizedlist>
then the less-specific instance IA is ignored.
</para></listitem>
<listitem><para>
Suppose an instance declaration does not match the constraint being looked up, but
does <emphasis>unify</emphasis> with it, so that it might match when the constraint is further
instantiated.  Usually GHC will regard this as a reason for not committing to
some other constraint.  But if the instance declaration was compiled with
<option>-XIncoherentInstances</option>, GHC will skip the "does-it-unify?"
check for that declaration.
</para></listitem>
</itemizedlist>
These rules make it possible for a library author to design a library that relies on
overlapping instances without the library client having to know.
</para>
<para>The <option>-XIncoherentInstances</option> flag implies the
<option>-XOverlappingInstances</option> flag, but not vice versa.
</para>
</sect3>



</sect2>

<sect2 id="overloaded-strings">
<title>Overloaded string literals
</title>

<para>
GHC supports <emphasis>overloaded string literals</emphasis>.  Normally a
string literal has type <literal>String</literal>, but with overloaded string
literals enabled (with <literal>-XOverloadedStrings</literal>)
 a string literal has type <literal>(IsString a) => a</literal>.
</para>
<para>
  This means that the usual string syntax can be used, e.g.,
  for <literal>ByteString</literal>, <literal>Text</literal>,
and other variations of string like types.  String literals behave very much
like integer literals, i.e., they can be used in both expressions and patterns.
If used in a pattern the literal with be replaced by an equality test, in the same
way as an integer literal is.
</para>
<para>
The class <literal>IsString</literal> is defined as:
<programlisting>
class IsString a where
    fromString :: String -> a
</programlisting>
The only predefined instance is the obvious one to make strings work as usual:
<programlisting>
instance IsString [Char] where
    fromString cs = cs
</programlisting>
The class <literal>IsString</literal> is not in scope by default.  If you want to mention
it explicitly (for example, to give an instance declaration for it), you can import it
from module <literal>GHC.Exts</literal>.
</para>
<para>
Haskell's defaulting mechanism is extended to cover string literals, when <option>-XOverloadedStrings</option> is specified.
Specifically:
<itemizedlist>
<listitem><para>
Each type in a default declaration must be an
instance of <literal>Num</literal> <emphasis>or</emphasis> of <literal>IsString</literal>.
</para></listitem>

<listitem><para>
The standard defaulting rule (<ulink url="http://www.haskell.org/onlinereport/decls.html#sect4.3.4">Haskell Report, Section 4.3.4</ulink>)
is extended thus: defaulting applies when all the unresolved constraints involve standard classes
<emphasis>or</emphasis> <literal>IsString</literal>; and at least one is a numeric class
<emphasis>or</emphasis> <literal>IsString</literal>.
</para></listitem>
</itemizedlist>
</para>
<para>
A small example:
<programlisting>
module Main where

import GHC.Exts( IsString(..) )

newtype MyString = MyString String deriving (Eq, Show)
instance IsString MyString where
    fromString = MyString

greet :: MyString -> MyString
greet "hello" = "world"
greet other = other

main = do
    print $ greet "hello"
    print $ greet "fool"
</programlisting>
</para>
<para>
Note that deriving <literal>Eq</literal> is necessary for the pattern matching
to work since it gets translated into an equality comparison.
</para>
</sect2>

</sect1>

<sect1 id="type-families">
<title>Type families</title>

<para>
  <firstterm>Indexed type families</firstterm> are a new GHC extension to
  facilitate type-level
  programming. Type families are a generalisation of <firstterm>associated
  data types</firstterm>
  (&ldquo;<ulink url="http://www.cse.unsw.edu.au/~chak/papers/CKPM05.html">Associated
  Types with Class</ulink>&rdquo;, M. Chakravarty, G. Keller, S. Peyton Jones,
  and S. Marlow. In Proceedings of &ldquo;The 32nd Annual ACM SIGPLAN-SIGACT
     Symposium on Principles of Programming Languages (POPL'05)&rdquo;, pages
  1-13, ACM Press, 2005) and <firstterm>associated type synonyms</firstterm>
  (&ldquo;<ulink url="http://www.cse.unsw.edu.au/~chak/papers/CKP05.html">Type
  Associated Type Synonyms</ulink>&rdquo;. M. Chakravarty, G. Keller, and
  S. Peyton Jones.
  In Proceedings of &ldquo;The Tenth ACM SIGPLAN International Conference on
  Functional Programming&rdquo;, ACM Press, pages 241-253, 2005).  Type families
  themselves are described in the paper &ldquo;<ulink
  url="http://www.cse.unsw.edu.au/~chak/papers/SPCS08.html">Type
  Checking with Open Type Functions</ulink>&rdquo;, T. Schrijvers,
  S. Peyton-Jones,
  M. Chakravarty, and M. Sulzmann, in Proceedings of &ldquo;ICFP 2008: The
  13th ACM SIGPLAN International Conference on Functional
  Programming&rdquo;, ACM Press, pages 51-62, 2008. Type families
  essentially provide type-indexed data types and named functions on types,
  which are useful for generic programming and highly parameterised library
  interfaces as well as interfaces with enhanced static information, much like
  dependent types. They might also be regarded as an alternative to functional
  dependencies, but provide a more functional style of type-level programming
  than the relational style of functional dependencies.
</para>
<para>
  Indexed type families, or type families for short, are type constructors that
  represent sets of types. Set members are denoted by supplying the type family
  constructor with type parameters, which are called <firstterm>type
  indices</firstterm>. The
  difference between vanilla parametrised type constructors and family
  constructors is much like between parametrically polymorphic functions and
  (ad-hoc polymorphic) methods of type classes. Parametric polymorphic functions
  behave the same at all type instances, whereas class methods can change their
  behaviour in dependence on the class type parameters. Similarly, vanilla type
  constructors imply the same data representation for all type instances, but
  family constructors can have varying representation types for varying type
  indices.
</para>
<para>
  Indexed type families come in two flavours: <firstterm>data
    families</firstterm> and <firstterm>type synonym
    families</firstterm>. They are the indexed family variants of algebraic
  data types and type synonyms, respectively. The instances of data families
  can be data types and newtypes.
</para>
<para>
  Type families are enabled by the flag <option>-XTypeFamilies</option>.
  Additional information on the use of type families in GHC is available on
  <ulink url="http://www.haskell.org/haskellwiki/GHC/Indexed_types">the
  Haskell wiki page on type families</ulink>.
</para>

<sect2 id="data-families">
  <title>Data families</title>

  <para>
    Data families appear in two flavours: (1) they can be defined on the
    toplevel
    or (2) they can appear inside type classes (in which case they are known as
    associated types). The former is the more general variant, as it lacks the
    requirement for the type-indexes to coincide with the class
    parameters. However, the latter can lead to more clearly structured code and
    compiler warnings if some type instances were - possibly accidentally -
    omitted. In the following, we always discuss the general toplevel form first
    and then cover the additional constraints placed on associated types.
  </para>

  <sect3 id="data-family-declarations">
    <title>Data family declarations</title>

    <para>
      Indexed data families are introduced by a signature, such as
<programlisting>
data family GMap k :: * -> *
</programlisting>
      The special <literal>family</literal> distinguishes family from standard
      data declarations.  The result kind annotation is optional and, as
      usual, defaults to <literal>*</literal> if omitted.  An example is
<programlisting>
data family Array e
</programlisting>
      Named arguments can also be given explicit kind signatures if needed.
      Just as with
      [http://www.haskell.org/ghc/docs/latest/html/users_guide/gadt.html GADT
      declarations] named arguments are entirely optional, so that we can
      declare <literal>Array</literal> alternatively with
<programlisting>
data family Array :: * -> *
</programlisting>
    </para>
    </sect3>

  <sect3 id="data-instance-declarations">
    <title>Data instance declarations</title>

    <para>
      Instance declarations of data and newtype families are very similar to
      standard data and newtype declarations.  The only two differences are
      that the keyword <literal>data</literal> or <literal>newtype</literal>
      is followed by <literal>instance</literal> and that some or all of the
      type arguments can be non-variable types, but may not contain forall
      types or type synonym families.  However, data families are generally
      allowed in type parameters, and type synonyms are allowed as long as
      they are fully applied and expand to a type that is itself admissible -
      exactly as this is required for occurrences of type synonyms in class
      instance parameters.  For example, the <literal>Either</literal>
      instance for <literal>GMap</literal> is
<programlisting>
data instance GMap (Either a b) v = GMapEither (GMap a v) (GMap b v)
</programlisting>
      In this example, the declaration has only one variant.  In general, it
      can be any number.
    </para>
    <para>
      Data and newtype instance declarations are only permitted when an
      appropriate family declaration is in scope - just as a class instance declaration
      requires the class declaration to be visible.  Moreover, each instance
      declaration has to conform to the kind determined by its family
      declaration.  This implies that the number of parameters of an instance
      declaration matches the arity determined by the kind of the family.
    </para>
    <para>
      A data family instance declaration can use the full expressiveness of
      ordinary <literal>data</literal> or <literal>newtype</literal> declarations:
      <itemizedlist>
      <listitem><para> Although, a data family is <emphasis>introduced</emphasis> with
      the keyword "<literal>data</literal>", a data family <emphasis>instance</emphasis> can
      use either <literal>data</literal> or <literal>newtype</literal>. For example:
<programlisting>
data family T a
data    instance T Int  = T1 Int | T2 Bool
newtype instance T Char = TC Bool
</programlisting>
      </para></listitem>
      <listitem><para> A <literal>data instance</literal> can use GADT syntax for the data constructors,
      and indeed can define a GADT.  For example:
<programlisting>
data family G a b
data instance G [a] b where
   G1 :: c -> G [Int] b
   G2 :: G [a] Bool
</programlisting>
      </para></listitem>
      <listitem><para> You can use a <literal>deriving</literal> clause on a
      <literal>data instance</literal> or <literal>newtype instance</literal>
      declaration.
      </para></listitem>
      </itemizedlist>
    </para>

    <para>
      Even if type families are defined as toplevel declarations, functions
      that perform different computations for different family instances may still
      need to be defined as methods of type classes.  In particular, the
      following is not possible:
<programlisting>
data family T a
data instance T Int  = A
data instance T Char = B
foo :: T a -> Int
foo A = 1             -- WRONG: These two equations together...
foo B = 2             -- ...will produce a type error.
</programlisting>
Instead, you would have to write <literal>foo</literal> as a class operation, thus:
<programlisting>
class Foo a where
  foo :: T a -> Int
instance Foo Int where
  foo A = 1
instance Foo Char where
  foo B = 2
</programlisting>
      (Given the functionality provided by GADTs (Generalised Algebraic Data
      Types), it might seem as if a definition, such as the above, should be
      feasible.  However, type families are - in contrast to GADTs - are
      <emphasis>open;</emphasis> i.e., new instances can always be added,
      possibly in other
      modules.  Supporting pattern matching across different data instances
      would require a form of extensible case construct.)
    </para>
    </sect3>

    <sect3 id="data-family-overlap">
      <title>Overlap of data instances</title>
      <para>
	The instance declarations of a data family used in a single program
	may not overlap at all, independent of whether they are associated or
	not.  In contrast to type class instances, this is not only a matter
	of consistency, but one of type safety.
      </para>
  </sect3>
</sect2>

<sect2 id="synonym-families">
  <title>Synonym families</title>

  <para>
    Type families appear in two flavours: (1) they can be defined on the
    toplevel or (2) they can appear inside type classes (in which case they
    are known as associated type synonyms).  The former is the more general
    variant, as it lacks the requirement for the type-indexes to coincide with
    the class parameters.  However, the latter can lead to more clearly
    structured code and compiler warnings if some type instances were -
    possibly accidentally - omitted.  In the following, we always discuss the
    general toplevel form first and then cover the additional constraints
    placed on associated types.
  </para>

  <sect3 id="type-family-declarations">
    <title>Type family declarations</title>

    <para>
      Indexed type families are introduced by a signature, such as
<programlisting>
type family Elem c :: *
</programlisting>
      The special <literal>family</literal> distinguishes family from standard
      type declarations.  The result kind annotation is optional and, as
      usual, defaults to <literal>*</literal> if omitted.  An example is
<programlisting>
type family Elem c
</programlisting>
      Parameters can also be given explicit kind signatures if needed.  We
      call the number of parameters in a type family declaration, the family's
      arity, and all applications of a type family must be fully saturated
      w.r.t. to that arity.  This requirement is unlike ordinary type synonyms
      and it implies that the kind of a type family is not sufficient to
      determine a family's arity, and hence in general, also insufficient to
      determine whether a type family application is well formed.  As an
      example, consider the following declaration:
<programlisting>
type family F a b :: * -> *   -- F's arity is 2,
                              -- although its overall kind is * -> * -> * -> *
</programlisting>
      Given this declaration the following are examples of well-formed and
      malformed types:
<programlisting>
F Char [Int]       -- OK!  Kind: * -> *
F Char [Int] Bool  -- OK!  Kind: *
F IO Bool          -- WRONG: kind mismatch in the first argument
F Bool             -- WRONG: unsaturated application
</programlisting>
      </para>
    </sect3>

  <sect3 id="type-instance-declarations">
    <title>Type instance declarations</title>
    <para>
      Instance declarations of type families are very similar to standard type
      synonym declarations.  The only two differences are that the
      keyword <literal>type</literal> is followed
      by <literal>instance</literal> and that some or all of the type
      arguments can be non-variable types, but may not contain forall types or
      type synonym families. However, data families are generally allowed, and
      type synonyms are allowed as long as they are fully applied and expand
      to a type that is admissible - these are the exact same requirements as
      for data instances.  For example, the <literal>[e]</literal> instance
      for <literal>Elem</literal> is
<programlisting>
type instance Elem [e] = e
</programlisting>
    </para>
    <para>
      Type family instance declarations are only legitimate when an
      appropriate family declaration is in scope - just like class instances
      require the class declaration to be visible.  Moreover, each instance
      declaration has to conform to the kind determined by its family
      declaration, and the number of type parameters in an instance
      declaration must match the number of type parameters in the family
      declaration.   Finally, the right-hand side of a type instance must be a
      monotype (i.e., it may not include foralls) and after the expansion of
      all saturated vanilla type synonyms, no synonyms, except family synonyms
      may remain.  Here are some examples of admissible and illegal type
      instances:
<programlisting>
type family F a :: *
type instance F [Int]              = Int         -- OK!
type instance F String             = Char        -- OK!
type instance F (F a)              = a           -- WRONG: type parameter mentions a type family
type instance F (forall a. (a, b)) = b           -- WRONG: a forall type appears in a type parameter
type instance F Float              = forall a.a  -- WRONG: right-hand side may not be a forall type

type family G a b :: * -> *
type instance G Int            = (,)     -- WRONG: must be two type parameters
type instance G Int Char Float = Double  -- WRONG: must be two type parameters
</programlisting>
    </para>
    </sect3>
    <sect3 id="type-family-overlap">
      <title>Overlap of type synonym instances</title>
      <para>
	The instance declarations of a type family used in a single program
	may only overlap if the right-hand sides of the overlapping instances
	coincide for the overlapping types.  More formally, two instance
	declarations overlap if there is a substitution that makes the
	left-hand sides of the instances syntactically the same.  Whenever
	that is the case, the right-hand sides of the instances must also be
	syntactically equal under the same substitution.  This condition is
	independent of whether the type family is associated or not, and it is
	not only a matter of consistency, but one of type safety.
      </para>
      <para>
	Here are two example to illustrate the condition under which overlap
	is permitted.
<programlisting>
type instance F (a, Int) = [a]
type instance F (Int, b) = [b]   -- overlap permitted

type instance G (a, Int)  = [a]
type instance G (Char, a) = [a]  -- ILLEGAL overlap, as [Char] /= [Int]
</programlisting>
      </para>
    </sect3>

    <sect3 id="type-family-decidability">
      <title>Decidability of type synonym instances</title>
      <para>
	In order to guarantee that type inference in the presence of type
	families decidable, we need to place a number of additional
	restrictions on the formation of type instance declarations (c.f.,
	Definition 5 (Relaxed Conditions) of &ldquo;<ulink
        url="http://www.cse.unsw.edu.au/~chak/papers/SPCS08.html">Type
	  Checking with Open Type Functions</ulink>&rdquo;).  Instance
	  declarations have the general form
<programlisting>
type instance F t1 .. tn = t
</programlisting>
        where we require that for every type family application <literal>(G s1
        .. sm)</literal> in <literal>t</literal>,
	<orderedlist>
	  <listitem>
	    <para><literal>s1 .. sm</literal> do not contain any type family
	    constructors,</para>
	  </listitem>
	  <listitem>
	    <para>the total number of symbols (data type constructors and type
	    variables) in <literal>s1 .. sm</literal> is strictly smaller than
	    in <literal>t1 .. tn</literal>, and</para>
	  </listitem>
	  <listitem>
	    <para>for every type
	    variable <literal>a</literal>, <literal>a</literal> occurs
	    in <literal>s1 .. sm</literal> at most as often as in <literal>t1
	    .. tn</literal>.</para>
	  </listitem>
	</orderedlist>
	These restrictions are easily verified and ensure termination of type
	inference.  However, they are not sufficient to guarantee completeness
	of type inference in the presence of, so called, ''loopy equalities'',
	such as <literal>a ~ [F a]</literal>, where a recursive occurrence of
	a type variable is underneath a family application and data
	constructor application - see the above mentioned paper for details.
      </para>
      <para>
	If the option <option>-XUndecidableInstances</option> is passed to the
	compiler, the above restrictions are not enforced and it is on the
	programmer to ensure termination of the normalisation of type families
	during type inference.
      </para>
  </sect3>
  </sect2>


<sect2 id="assoc-decl">
<title>Associated data and type families</title>
<para>
A data or type synonym family can be declared as part of a type class, thus:
<programlisting>
class GMapKey k where
  data GMap k :: * -> *
  ...

class Collects ce where
  type Elem ce :: *
  ...
</programlisting>
When doing so, we drop the "<literal>family</literal>" keyword.
</para>
<para>
	The type parameters must all be type variables, of course,
        and some (but not necessarily all) of then can be the class
        parameters. Each class parameter may
	only be used at most once per associated type, but some may be omitted
	and they may be in an order other than in the class head.  Hence, the
	following contrived example is admissible:
<programlisting>
  class C a b c where
    type T c a x :: *
</programlisting>
        Here <literal>c</literal> and <literal>a</literal> are class parameters,
        but the type is also indexed on a third parameter <literal>x</literal>.
      </para>

    <sect3 id="assoc-data-inst">
      <title>Associated instances</title>
      <para>
	When an associated data or type synonym family instance is declared within a type
	class instance, we drop the <literal>instance</literal> keyword in the
	family instance:
<programlisting>
instance (GMapKey a, GMapKey b) => GMapKey (Either a b) where
  data GMap (Either a b) v = GMapEither (GMap a v) (GMap b v)
  ...

instance (Eq (Elem [e])) => Collects ([e]) where
  type Elem [e] = e
  ...
</programlisting>
        The most important point about associated family instances is that the
        type indexes corresponding to class parameters must be identical to
        the type given in the instance head; here this is the first argument
        of <literal>GMap</literal>, namely <literal>Either a b</literal>,
        which coincides with the only class parameter.
      </para>
      <para>
	Instances for an associated family can only appear as part of
	instance declarations of the class in which the family was declared -
	just as with the equations of the methods of a class.  Also in
	correspondence to how methods are handled, declarations of associated
	types can be omitted in class instances.  If an associated family
	instance is omitted, the corresponding instance type is not inhabited;
	i.e., only diverging expressions, such
	as <literal>undefined</literal>, can assume the type.
      </para>
      <para>
        Although it is unusual, there can be <emphasis>multiple</emphasis>
        instances for an associated family in a single instance declaration.
        For example, this is legitimate:
<programlisting>
instance GMapKey Flob where
  data GMap Flob [v] = G1 v
  data GMap Flob Int = G2 Int
  ...
</programlisting>
        Here we give two data instance declarations, one in which the last
        parameter is <literal>[v]</literal>, and one for which it is <literal>Int</literal>.
        Since you cannot give any <emphasis>subsequent</emphasis> instances for
        <literal>(GMap Flob ...)</literal>, this facility is most useful when
        the free indexed parameter is of a kind with a finite number of alternatives
        (unlike <literal>*</literal>).
      </para>
    </sect3>

    <sect3 id="assoc-decl-defs">
    <title>Associated type synonym defaults</title>
      <para>
        It is possible for the class defining the associated type to specify a
        default for associated type instances. So for example, this is OK:
<programlisting>
class IsBoolMap v where
  type Key v
  type Key v = Int

  lookupKey :: Key v -> v -> Maybe Bool

instance IsBoolMap [(Int, Bool)] where
  lookupKey = lookup
</programlisting>

There can also be multiple defaults for a single type, as long as they do not
overlap:
<programlisting>
class C a where
  type F a b
  type F a Int  = Bool
  type F a Bool = Int
</programlisting>

A default declaration is not permitted for an associated
<emphasis>data</emphasis> type.
      </para>
    </sect3>

    <sect3 id="scoping-class-params">
      <title>Scoping of class parameters</title>
      <para>
	The visibility of class
	parameters in the right-hand side of associated family instances
	depends <emphasis>solely</emphasis> on the parameters of the
	family.  As an example, consider the simple class declaration
<programlisting>
class C a b where
  data T a
</programlisting>
        Only one of the two class parameters is a parameter to the data
        family.  Hence, the following instance declaration is invalid:
<programlisting>
instance C [c] d where
  data T [c] = MkT (c, d)    -- WRONG!!  'd' is not in scope
</programlisting>
        Here, the right-hand side of the data instance mentions the type
        variable <literal>d</literal> that does not occur in its left-hand
        side.  We cannot admit such data instances as they would compromise
        type safety.
      </para>
    </sect3>
  </sect2>

  <sect2 id="data-family-import-export">
    <title>Import and export</title>

    <para>
The rules for export lists
(Haskell Report
   <ulink url="http://www.haskell.org/onlinereport/modules.html#sect5.2">Section 5.2</ulink>)
needs adjustment for type families:
<itemizedlist>
<listitem><para>
  The form <literal>T(..)</literal>, where <literal>T</literal>
  is a data family, names the family <literal>T</literal> and all the in-scope
  constructors (whether in scope qualified or unqualified) that are data
  instances of <literal>T</literal>.
  </para></listitem>
<listitem><para>
  The form <literal>T(.., ci, .., fj, ..)</literal>, where <literal>T</literal> is
  a data family, names <literal>T</literal> and the specified constructors <literal>ci</literal>
  and fields <literal>fj</literal> as usual. The constructors and field names must
  belong to some data instance of <literal>T</literal>, but are not required to belong
  to the <emphasis>same</emphasis> instance.
  </para></listitem>
<listitem><para>
  The form <literal>C(..)</literal>, where <literal>C</literal>
  is a class, names the class <literal>C</literal> and all its methods
  <emphasis>and associated types</emphasis>.
  </para></listitem>
<listitem><para>
  The form <literal>C(.., mi, .., type Tj, ..)</literal>, where <literal>C</literal> is a class,
  names the class <literal>C</literal>, and the specified methods <literal>mi</literal>
  and associated types <literal>Tj</literal>. The types need a keyword "<literal>type</literal>"
  to distinguish them from data constructors.
  </para></listitem>
</itemizedlist>
</para>

    <sect3 id="data-family-impexp-examples">
      <title>Examples</title>
      <para>
	Recall our running <literal>GMapKey</literal> class example:
<programlisting>
class GMapKey k where
  data GMap k :: * -> *
  insert :: GMap k v -> k -> v -> GMap k v
  lookup :: GMap k v -> k -> Maybe v
  empty  :: GMap k v

instance (GMapKey a, GMapKey b) => GMapKey (Either a b) where
  data GMap (Either a b) v = GMapEither (GMap a v) (GMap b v)
  ...method declarations...
</programlisting>
Here are some export lists and their meaning:
	<itemizedlist>
	  <listitem>
	    <para><literal>module GMap( GMapKey )</literal>: Exports
	      just the class name.</para>
	  </listitem>
	  <listitem>
	    <para><literal>module GMap( GMapKey(..) )</literal>:
	      Exports the class, the associated type <literal>GMap</literal>
	      and the member
	      functions <literal>empty</literal>, <literal>lookup</literal>,
	      and <literal>insert</literal>.  The data constructors of <literal>GMap</literal>
              (in this case <literal>GMapEither</literal>) are not exported.</para>
	  </listitem>
	  <listitem>
	    <para><literal>module GMap( GMapKey( type GMap, empty, lookup, insert ) )</literal>:
              Same as the previous item. Note the "<literal>type</literal>" keyword.</para>
	  </listitem>
	  <listitem>
	    <para><literal>module GMap( GMapKey(..), GMap(..) )</literal>:
              Same as previous item, but also exports all the data
	      constructors for <literal>GMap</literal>, namely <literal>GMapEither</literal>.
	      </para>
	  </listitem>
	  <listitem>
	    <para><literal>module GMap ( GMapKey( empty, lookup, insert), GMap(..) )</literal>:
              Same as previous item.</para>
	  </listitem>
	  <listitem>
	    <para><literal>module GMap ( GMapKey, empty, lookup, insert, GMap(..) )</literal>:
              Same as previous item.</para>
	  </listitem>
	</itemizedlist>
      </para>
      <para>
Two things to watch out for:
  <itemizedlist>
      <listitem><para>
        You cannot write <literal>GMapKey(type GMap(..))</literal> &mdash; i.e.,
	sub-component specifications cannot be nested.  To
	specify <literal>GMap</literal>'s data constructors, you have to list
	it separately.
      </para></listitem>
      <listitem><para>
  Consider this example:
<programlisting>
  module X where
    data family D

  module Y where
    import X
    data instance D Int = D1 | D2
</programlisting>
    Module Y exports all the entities defined in Y, namely the data constructors <literal>D1</literal>
    and <literal>D2</literal>, <emphasis>but not the data family <literal>D</literal></emphasis>.
    That (annoyingly) means that you cannot selectively import Y selectively,
    thus "<literal>import Y( D(D1,D2) )</literal>", because Y does not export <literal>D</literal>.
    Instead you should list the exports explicitly, thus:
<programlisting>
     module Y( D(..) ) where ...
or   module Y( module Y, D ) where ...
</programlisting>
      </para></listitem>
  </itemizedlist>
</para>
</sect3>

    <sect3 id="data-family-impexp-instances">
      <title>Instances</title>
      <para>
	Family instances are implicitly exported, just like class instances.
	However, this applies only to the heads of instances, not to the data
	constructors an instance defines.
      </para>
    </sect3>

  </sect2>

  <sect2 id="ty-fams-in-instances">
    <title>Type families and instance declarations</title>

    <para>Type families require us to extend the rules for
      the form of instance heads, which are given
      in <xref linkend="flexible-instance-head"/>.
      Specifically:
<itemizedlist>
 <listitem><para>Data type families may appear in an instance head</para></listitem>
 <listitem><para>Type synonym families may not appear (at all) in an instance head</para></listitem>
</itemizedlist>
The reason for the latter restriction is that there is no way to check for instance
matching. Consider
<programlisting>
   type family F a
   type instance F Bool = Int

   class C a

   instance C Int
   instance C (F a)
</programlisting>
Now a constraint <literal>(C (F Bool))</literal> would match both instances.
The situation is especially bad because the type instance for <literal>F Bool</literal>
might be in another module, or even in a module that is not yet written.
</para>
<para>
However, type class instances of instances of data families can be defined
much like any other data type. For example, we can say
<programlisting>
data instance T Int = T1 Int | T2 Bool
instance Eq (T Int) where
  (T1 i) == (T1 j) = i==j
  (T2 i) == (T2 j) = i==j
  _      == _      = False
</programlisting>
	Note that class instances are always for
	particular <emphasis>instances</emphasis> of a data family and never
	for an entire family as a whole.  This is for essentially the same
	reasons that we cannot define a toplevel function that performs
	pattern matching on the data constructors
	of <emphasis>different</emphasis> instances of a single type family.
	It would require a form of extensible case construct.
      </para>
<para>
Data instance declarations can also
	have <literal>deriving</literal> clauses.  For example, we can write
<programlisting>
data GMap () v = GMapUnit (Maybe v)
               deriving Show
</programlisting>
        which implicitly defines an instance of the form
<programlisting>
instance Show v => Show (GMap () v) where ...
</programlisting>
      </para>

</sect2>

</sect1>

<sect1 id="kind-polymorphism-and-promotion">
<title>Kind polymorphism and promotion</title>

<para>
Standard Haskell has a rich type language. Types classify terms and serve to
avoid many common programming mistakes. The kind language, however, is
relatively simple, distinguishing only lifted types (kind <literal>*</literal>),
type constructors (eg. kind <literal>* -> * -> *</literal>), and unlifted
types (<xref linkend="glasgow-unboxed"/>). In particular when using advanced
type system features, such as type families (<xref linkend="type-families"/>)
or GADTs (<xref linkend="gadt"/>), this simple kind system is insufficient,
and fails to prevent simple errors. Consider the example of type-level natural
numbers, and length-indexed vectors:
<programlisting>
data Ze
data Su n

data Vec :: * -> * -> * where
  Nil  :: Vec a Ze
  Cons :: a -> Vec a n -> Vec a (Su n)
</programlisting>
The kind of <literal>Vec</literal> is <literal>* -> * -> *</literal>. This means
that eg. <literal>Vec Int Char</literal> is a well-kinded type, even though this
is not what we intend when defining length-indexed vectors.
</para>

<para>
With the flags <option>-XPolyKinds</option> and <option>-XDataKinds</option>,
users get access to a richer kind language.
<option>-XPolyKinds</option> enables kind polymorphism, while
<option>-XDataKinds</option> enables user defined kinds through datatype
promotion. With <option>-XDataKinds</option>, the example above can then be
rewritten to:
<programlisting>
data Nat = Ze | Su Nat

data Vec :: * -> Nat -> * where
  Nil  :: Vec a Ze
  Cons :: a -> Vec a n -> Vec a (Su n)
</programlisting>
With the improved kind of <literal>Vec</literal>, things like
<literal>Vec Int Char</literal> are now ill-kinded, and GHC will report an
error.
</para>

<para>
In this section we show a few examples of how to make use of the new kind
system. This extension is described in more detail in the paper
<ulink url="http://dreixel.net/research/pdf/ghp.pdf">Giving Haskell a
Promotion</ulink>, which appeared at TLDI 2012.
</para>

<sect2 id="kind-polymorphism">
<title>Kind polymorphism</title>
<para>
Currently there is a lot of code duplication in the way Typeable is implemented
(<xref linkend="deriving-typeable"/>):
<programlisting>
class Typeable (t :: *) where
  typeOf :: t -> TypeRep

class Typeable1 (t :: * -> *) where
  typeOf1 :: t a -> TypeRep

class Typeable2 (t :: * -> * -> *) where
  typeOf2 :: t a b -> TypeRep
</programlisting>
</para>

<para>
Kind polymorphism (with <option>-XPolyKinds</option>)
allows us to merge all these classes into one:
<programlisting>
data Proxy t = Proxy

class Typeable t where
  typeOf :: Proxy t -> TypeRep

instance Typeable Int  where typeOf _ = TypeRep
instance Typeable []   where typeOf _ = TypeRep
</programlisting>
Note that the datatype <literal>Proxy</literal> has kind
<literal>forall k. k -> *</literal> (inferred by GHC), and the new
<literal>Typeable</literal> class has kind
<literal>forall k. k -> Constraint</literal>.
</para>

<para>
There are some restrictions in the current implementation:
<itemizedlist>
 <listitem><para>You cannot (yet) explicitly abstract over kinds, or mention
 kind variables. So the following are all rejected:
<programlisting>
data D1 (t :: k)

data D2 :: k -> *

data D3 (k :: BOX)
</programlisting></para>
 </listitem>
 <listitem><para>The return kind of a type family is always defaulted to
 <literal>*</literal>. So the following is rejected:
<programlisting>
type family F a
type instance F Int = Maybe
</programlisting></para>
 </listitem>
</itemizedlist>
</para>

</sect2>

<sect2 id="promotion">
<title>Datatype promotion</title>
<para>
With <option>-XDataKinds</option>, GHC automatically promotes every suitable
datatype to be a kind, and its (value) constructors to be type constructors.
The following types
<programlisting>
data Nat = Ze | Su Nat

data List a = Nil | Cons a (List a)

data Pair a b = Pair a b
 
data Sum a b = L a | R b
</programlisting>
give rise to the following kinds and type constructors:
<programlisting>
Nat :: BOX
Ze :: Nat
Su :: Nat -> Nat

List k :: BOX
Nil  :: List k
Cons :: k -> List k -> List k

Pair k1 k2 :: BOX
Pair :: k1 -> k2 -> Pair k1 k2

Sum k1 k2 :: BOX
L :: k1 -> Sum k1 k2
R :: k2 -> Sum k1 k2
</programlisting>
Note that <literal>List</literal>, for instance, does not get kind
<literal>BOX -> BOX</literal>, because we do not further classify kinds; all
kinds have sort <literal>BOX</literal>.
</para>

<para>
The following restrictions apply to promotion:
<itemizedlist>
 <listitem><para>We only promote datatypes whose kinds are of the form
 <literal>* -> ... -> * -> *</literal>. In particular, we do not promote
 higher-kinded datatypes such as <literal>data Fix f = In (f (Fix f))</literal>,
 or datatypes whose kinds involve promoted types such as
 <literal>Vec :: * -> Nat -> *</literal>.</para></listitem>
 <listitem><para>We do not promote datatypes whose constructors are kind
 polymorphic, involve constraints, or use existential quantification.
 </para></listitem>
</itemizedlist>
</para>

<sect3 id="promotion-syntax">
<title>Distinguishing between types and constructors</title>
<para>
Since constructors and types share the same namespace, with promotion you can
get ambiguous type names:
<programlisting>
data P          -- 1

data Prom = P   -- 2

type T = P      -- 1 or promoted 2?
</programlisting>
In these cases, if you want to refer to the promoted constructor, you should
prefix its name with a quote:
<programlisting>
type T1 = P     -- 1

type T2 = 'P    -- promoted 2
</programlisting>
Note that promoted datatypes give rise to named kinds. Since these can never be
ambiguous, we do not allow quotes in kind names.
</para>
</sect3>

<sect3 id="promoted-lists-and-tuples">
<title>Promoted lists and tuples types</title>
<para>
Haskell's list and tuple types are natively promoted to kinds, and enjoy the
same convenient syntax at the type level, albeit prefixed with a quote:
<programlisting>
data HList :: [*] -> * where
  HNil  :: HList '[]
  HCons :: a -> HList t -> HList (a ': t)

data Tuple :: (*,*) -> * where
  Tuple :: a -> b -> Tuple '(a,b)
</programlisting>
Note that this requires <option>-XTypeOperators</option>.
</para>
</sect3>

</sect2>

<sect2 id="kind-polymorphism-limitations">
<title>Shortcomings of the current implementation</title>
<para>
For the release on GHC 7.4 we focused on getting the new kind-polymorphic core
to work with all existing programs (which do not make use of kind polymorphism).
Many things already work properly with <option>-XPolyKinds</option>, but we
expect that some things will not work. If you run into trouble, please
<link linkend="bug-reporting">report a bug</link>!
</para>
</sect2>

</sect1>

  <sect1 id="equality-constraints">
    <title>Equality constraints</title>
    <para>
      A type context can include equality constraints of the form <literal>t1 ~
      t2</literal>, which denote that the types <literal>t1</literal>
      and <literal>t2</literal> need to be the same.  In the presence of type
      families, whether two types are equal cannot generally be decided
      locally.  Hence, the contexts of function signatures may include
      equality constraints, as in the following example:
<programlisting>
sumCollects :: (Collects c1, Collects c2, Elem c1 ~ Elem c2) => c1 -> c2 -> c2
</programlisting>
      where we require that the element type of <literal>c1</literal>
      and <literal>c2</literal> are the same.  In general, the
      types <literal>t1</literal> and <literal>t2</literal> of an equality
      constraint may be arbitrary monotypes; i.e., they may not contain any
      quantifiers, independent of whether higher-rank types are otherwise
      enabled.
    </para>
    <para>
      Equality constraints can also appear in class and instance contexts.
      The former enable a simple translation of programs using functional
      dependencies into programs using family synonyms instead.  The general
      idea is to rewrite a class declaration of the form
<programlisting>
class C a b | a -> b
</programlisting>
      to
<programlisting>
class (F a ~ b) => C a b where
  type F a
</programlisting>
      That is, we represent every functional dependency (FD) <literal>a1 .. an
      -> b</literal> by an FD type family <literal>F a1 .. an</literal> and a
      superclass context equality <literal>F a1 .. an ~ b</literal>,
      essentially giving a name to the functional dependency.  In class
      instances, we define the type instances of FD families in accordance
      with the class head.  Method signatures are not affected by that
      process.
    </para>
  </sect1>

<sect1 id="constraint-kind">
<title>The <literal>Constraint</literal> kind</title>

<para>
	Normally, <emphasis>constraints</emphasis> (which appear in types to the left of the
	<literal>=></literal> arrow) have a very restricted syntax. They can only be:
	<itemizedlist>
		<listitem>
			<para>Class constraints, e.g. <literal>Show a</literal></para>
		</listitem>
		<listitem>
			<para><link linkend="implicit-parameters">Implicit parameter</link> constraints,
				  e.g. <literal>?x::Int</literal> (with the <option>-XImplicitParams</option> flag)</para>
		</listitem>
		<listitem>
			<para><link linkend="equality-constraints">Equality constraints</link>,
				  e.g. <literal>a ~ Int</literal> (with the <option>-XTypeFamilies</option> or
				  <option>-XGADTs</option> flag)</para>
		</listitem>
	</itemizedlist>
</para>

<para>
	With the <option>-XConstraintKinds</option> flag, GHC becomes more liberal in
	what it accepts as constraints in your program. To be precise, with this flag any
	<emphasis>type</emphasis> of the new kind <literal>Constraint</literal> can be used as a constraint.
	The following things have kind <literal>Constraint</literal>:

	<itemizedlist>
		<listitem>
			Anything which is already valid as a constraint without the flag: saturated applications to type classes,
			implicit parameter and equality constraints.
		</listitem>
		<listitem>
			Tuples, all of whose component types have kind <literal>Constraint</literal>. So for example the
			type <literal>(Show a, Ord a)</literal> is of kind <literal>Constraint</literal>.
		</listitem>
		<listitem>
			Anything whose form is not yet know, but the user has declared to have kind <literal>Constraint</literal>.
			So for example <literal>type Foo (f :: * -> Constraint) = forall b. f b => b -> b</literal> is allowed, as
			well as examples involving type families:
<programlisting>
type family Typ a b :: Constraint
type instance Typ Int  b = Show b
type instance Typ Bool b = Num b

func :: Typ a b => a -> b -> b
func = ...
</programlisting>
		</listitem>
	</itemizedlist>
</para>

<para>
	Note that because constraints are just handled as types of a particular kind, this extension allows type
	constraint synonyms:
</para>

<programlisting>
type Stringy a = (Read a, Show a)
foo :: Stringy a => a -> (String, String -> a)
foo x = (show x, read)
</programlisting>

<para>
	Presently, only standard constraints, tuples and type synonyms for those two sorts of constraint are
	permitted in instance contexts and superclasses (without extra flags). The reason is that permitting more general
	constraints can cause type checking to loop, as it would with these two programs:
</para>

<programlisting>
type family Clsish u a
type instance Clsish () a = Cls a
class Clsish () a => Cls a where
</programlisting>

<programlisting>
class OkCls a where

type family OkClsish u a
type instance OkClsish () a = OkCls a
instance OkClsish () a => OkCls a where
</programlisting>

<para>
   You may write programs that use exotic sorts of constraints in instance contexts and superclasses, but
   to do so you must use <option>-XUndecidableInstances</option> to signal that you don't mind if the type checker
   fails to terminate.
</para>

</sect1>

<sect1 id="other-type-extensions">
<title>Other type system extensions</title>

<sect2 id="explicit-foralls"><title>Explicit universal quantification (forall)</title>
<para>
Haskell type signatures are implicitly quantified.  When the language option <option>-XExplicitForAll</option>
is used, the keyword <literal>forall</literal>
allows us to say exactly what this means.  For example:
</para>
<para>
<programlisting>
        g :: b -> b
</programlisting>
means this:
<programlisting>
        g :: forall b. (b -> b)
</programlisting>
The two are treated identically.
</para>
<para>
Of course <literal>forall</literal> becomes a keyword; you can't use <literal>forall</literal> as
a type variable any more!
</para>
</sect2>


<sect2 id="flexible-contexts"><title>The context of a type signature</title>
<para>
The <option>-XFlexibleContexts</option> flag lifts the Haskell 98 restriction
that the type-class constraints in a type signature must have the
form <emphasis>(class type-variable)</emphasis> or
<emphasis>(class (type-variable type-variable ...))</emphasis>.
With <option>-XFlexibleContexts</option>
these type signatures are perfectly OK
<programlisting>
  g :: Eq [a] => ...
  g :: Ord (T a ()) => ...
</programlisting>
The flag <option>-XFlexibleContexts</option> also lifts the corresponding
restriction on class declarations (<xref linkend="superclass-rules"/>) and instance declarations
(<xref linkend="instance-rules"/>).
</para>

<para>
GHC imposes the following restrictions on the constraints in a type signature.
Consider the type:

<programlisting>
  forall tv1..tvn (c1, ...,cn) => type
</programlisting>

(Here, we write the "foralls" explicitly, although the Haskell source
language omits them; in Haskell 98, all the free type variables of an
explicit source-language type signature are universally quantified,
except for the class type variables in a class declaration.  However,
in GHC, you can give the foralls if you want.  See <xref linkend="explicit-foralls"/>).
</para>

<para>

<orderedlist>
<listitem>

<para>
 <emphasis>Each universally quantified type variable
<literal>tvi</literal> must be reachable from <literal>type</literal></emphasis>.

A type variable <literal>a</literal> is "reachable" if it appears
in the same constraint as either a type variable free in
<literal>type</literal>, or another reachable type variable.
A value with a type that does not obey
this reachability restriction cannot be used without introducing
ambiguity; that is why the type is rejected.
Here, for example, is an illegal type:


<programlisting>
  forall a. Eq a => Int
</programlisting>


When a value with this type was used, the constraint <literal>Eq tv</literal>
would be introduced where <literal>tv</literal> is a fresh type variable, and
(in the dictionary-translation implementation) the value would be
applied to a dictionary for <literal>Eq tv</literal>.  The difficulty is that we
can never know which instance of <literal>Eq</literal> to use because we never
get any more information about <literal>tv</literal>.
</para>
<para>
Note
that the reachability condition is weaker than saying that <literal>a</literal> is
functionally dependent on a type variable free in
<literal>type</literal> (see <xref
linkend="functional-dependencies"/>).  The reason for this is there
might be a "hidden" dependency, in a superclass perhaps.  So
"reachable" is a conservative approximation to "functionally dependent".
For example, consider:
<programlisting>
  class C a b | a -> b where ...
  class C a b => D a b where ...
  f :: forall a b. D a b => a -> a
</programlisting>
This is fine, because in fact <literal>a</literal> does functionally determine <literal>b</literal>
but that is not immediately apparent from <literal>f</literal>'s type.
</para>
</listitem>
<listitem>

<para>
 <emphasis>Every constraint <literal>ci</literal> must mention at least one of the
universally quantified type variables <literal>tvi</literal></emphasis>.

For example, this type is OK because <literal>C a b</literal> mentions the
universally quantified type variable <literal>b</literal>:


<programlisting>
  forall a. C a b => burble
</programlisting>


The next type is illegal because the constraint <literal>Eq b</literal> does not
mention <literal>a</literal>:


<programlisting>
  forall a. Eq b => burble
</programlisting>


The reason for this restriction is milder than the other one.  The
excluded types are never useful or necessary (because the offending
context doesn't need to be witnessed at this point; it can be floated
out).  Furthermore, floating them out increases sharing. Lastly,
excluding them is a conservative choice; it leaves a patch of
territory free in case we need it later.

</para>
</listitem>

</orderedlist>

</para>

</sect2>

<sect2 id="implicit-parameters">
<title>Implicit parameters</title>

<para> Implicit parameters are implemented as described in
"Implicit parameters: dynamic scoping with static types",
J Lewis, MB Shields, E Meijer, J Launchbury,
27th ACM Symposium on Principles of Programming Languages (POPL'00),
Boston, Jan 2000.
</para>

<para>(Most of the following, still rather incomplete, documentation is
due to Jeff Lewis.)</para>

<para>Implicit parameter support is enabled with the option
<option>-XImplicitParams</option>.</para>

<para>
A variable is called <emphasis>dynamically bound</emphasis> when it is bound by the calling
context of a function and <emphasis>statically bound</emphasis> when bound by the callee's
context. In Haskell, all variables are statically bound. Dynamic
binding of variables is a notion that goes back to Lisp, but was later
discarded in more modern incarnations, such as Scheme. Dynamic binding
can be very confusing in an untyped language, and unfortunately, typed
languages, in particular Hindley-Milner typed languages like Haskell,
only support static scoping of variables.
</para>
<para>
However, by a simple extension to the type class system of Haskell, we
can support dynamic binding. Basically, we express the use of a
dynamically bound variable as a constraint on the type. These
constraints lead to types of the form <literal>(?x::t') => t</literal>, which says "this
function uses a dynamically-bound variable <literal>?x</literal>
of type <literal>t'</literal>". For
example, the following expresses the type of a sort function,
implicitly parameterized by a comparison function named <literal>cmp</literal>.
<programlisting>
  sort :: (?cmp :: a -> a -> Bool) => [a] -> [a]
</programlisting>
The dynamic binding constraints are just a new form of predicate in the type class system.
</para>
<para>
An implicit parameter occurs in an expression using the special form <literal>?x</literal>,
where <literal>x</literal> is
any valid identifier (e.g. <literal>ord ?x</literal> is a valid expression).
Use of this construct also introduces a new
dynamic-binding constraint in the type of the expression.
For example, the following definition
shows how we can define an implicitly parameterized sort function in
terms of an explicitly parameterized <literal>sortBy</literal> function:
<programlisting>
  sortBy :: (a -> a -> Bool) -> [a] -> [a]

  sort   :: (?cmp :: a -> a -> Bool) => [a] -> [a]
  sort    = sortBy ?cmp
</programlisting>
</para>

<sect3>
<title>Implicit-parameter type constraints</title>
<para>
Dynamic binding constraints behave just like other type class
constraints in that they are automatically propagated. Thus, when a
function is used, its implicit parameters are inherited by the
function that called it. For example, our <literal>sort</literal> function might be used
to pick out the least value in a list:
<programlisting>
  least   :: (?cmp :: a -> a -> Bool) => [a] -> a
  least xs = head (sort xs)
</programlisting>
Without lifting a finger, the <literal>?cmp</literal> parameter is
propagated to become a parameter of <literal>least</literal> as well. With explicit
parameters, the default is that parameters must always be explicit
propagated. With implicit parameters, the default is to always
propagate them.
</para>
<para>
An implicit-parameter type constraint differs from other type class constraints in the
following way: All uses of a particular implicit parameter must have
the same type. This means that the type of <literal>(?x, ?x)</literal>
is <literal>(?x::a) => (a,a)</literal>, and not
<literal>(?x::a, ?x::b) => (a, b)</literal>, as would be the case for type
class constraints.
</para>

<para> You can't have an implicit parameter in the context of a class or instance
declaration.  For example, both these declarations are illegal:
<programlisting>
  class (?x::Int) => C a where ...
  instance (?x::a) => Foo [a] where ...
</programlisting>
Reason: exactly which implicit parameter you pick up depends on exactly where
you invoke a function. But the ``invocation'' of instance declarations is done
behind the scenes by the compiler, so it's hard to figure out exactly where it is done.
Easiest thing is to outlaw the offending types.</para>
<para>
Implicit-parameter constraints do not cause ambiguity.  For example, consider:
<programlisting>
   f :: (?x :: [a]) => Int -> Int
   f n = n + length ?x

   g :: (Read a, Show a) => String -> String
   g s = show (read s)
</programlisting>
Here, <literal>g</literal> has an ambiguous type, and is rejected, but <literal>f</literal>
is fine.  The binding for <literal>?x</literal> at <literal>f</literal>'s call site is
quite unambiguous, and fixes the type <literal>a</literal>.
</para>
</sect3>

<sect3>
<title>Implicit-parameter bindings</title>

<para>
An implicit parameter is <emphasis>bound</emphasis> using the standard
<literal>let</literal> or <literal>where</literal> binding forms.
For example, we define the <literal>min</literal> function by binding
<literal>cmp</literal>.
<programlisting>
  min :: [a] -> a
  min  = let ?cmp = (&lt;=) in least
</programlisting>
</para>
<para>
A group of implicit-parameter bindings may occur anywhere a normal group of Haskell
bindings can occur, except at top level.  That is, they can occur in a <literal>let</literal>
(including in a list comprehension, or do-notation, or pattern guards),
or a <literal>where</literal> clause.
Note the following points:
<itemizedlist>
<listitem><para>
An implicit-parameter binding group must be a
collection of simple bindings to implicit-style variables (no
function-style bindings, and no type signatures); these bindings are
neither polymorphic or recursive.
</para></listitem>
<listitem><para>
You may not mix implicit-parameter bindings with ordinary bindings in a
single <literal>let</literal>
expression; use two nested <literal>let</literal>s instead.
(In the case of <literal>where</literal> you are stuck, since you can't nest <literal>where</literal> clauses.)
</para></listitem>

<listitem><para>
You may put multiple implicit-parameter bindings in a
single binding group; but they are <emphasis>not</emphasis> treated
as a mutually recursive group (as ordinary <literal>let</literal> bindings are).
Instead they are treated as a non-recursive group, simultaneously binding all the implicit
parameter.  The bindings are not nested, and may be re-ordered without changing
the meaning of the program.
For example, consider:
<programlisting>
  f t = let { ?x = t; ?y = ?x+(1::Int) } in ?x + ?y
</programlisting>
The use of <literal>?x</literal> in the binding for <literal>?y</literal> does not "see"
the binding for <literal>?x</literal>, so the type of <literal>f</literal> is
<programlisting>
  f :: (?x::Int) => Int -> Int
</programlisting>
</para></listitem>
</itemizedlist>
</para>

</sect3>

<sect3><title>Implicit parameters and polymorphic recursion</title>

<para>
Consider these two definitions:
<programlisting>
  len1 :: [a] -> Int
  len1 xs = let ?acc = 0 in len_acc1 xs

  len_acc1 [] = ?acc
  len_acc1 (x:xs) = let ?acc = ?acc + (1::Int) in len_acc1 xs

  ------------

  len2 :: [a] -> Int
  len2 xs = let ?acc = 0 in len_acc2 xs

  len_acc2 :: (?acc :: Int) => [a] -> Int
  len_acc2 [] = ?acc
  len_acc2 (x:xs) = let ?acc = ?acc + (1::Int) in len_acc2 xs
</programlisting>
The only difference between the two groups is that in the second group
<literal>len_acc</literal> is given a type signature.
In the former case, <literal>len_acc1</literal> is monomorphic in its own
right-hand side, so the implicit parameter <literal>?acc</literal> is not
passed to the recursive call.  In the latter case, because <literal>len_acc2</literal>
has a type signature, the recursive call is made to the
<emphasis>polymorphic</emphasis> version, which takes <literal>?acc</literal>
as an implicit parameter.  So we get the following results in GHCi:
<programlisting>
  Prog> len1 "hello"
  0
  Prog> len2 "hello"
  5
</programlisting>
Adding a type signature dramatically changes the result!  This is a rather
counter-intuitive phenomenon, worth watching out for.
</para>
</sect3>

<sect3><title>Implicit parameters and monomorphism</title>

<para>GHC applies the dreaded Monomorphism Restriction (section 4.5.5 of the
Haskell Report) to implicit parameters.  For example, consider:
<programlisting>
 f :: Int -> Int
  f v = let ?x = 0     in
        let y = ?x + v in
        let ?x = 5     in
        y
</programlisting>
Since the binding for <literal>y</literal> falls under the Monomorphism
Restriction it is not generalised, so the type of <literal>y</literal> is
simply <literal>Int</literal>, not <literal>(?x::Int) => Int</literal>.
Hence, <literal>(f 9)</literal> returns result <literal>9</literal>.
If you add a type signature for <literal>y</literal>, then <literal>y</literal>
will get type <literal>(?x::Int) => Int</literal>, so the occurrence of
<literal>y</literal> in the body of the <literal>let</literal> will see the
inner binding of <literal>?x</literal>, so <literal>(f 9)</literal> will return
<literal>14</literal>.
</para>
</sect3>
</sect2>

    <!--   ======================= COMMENTED OUT ========================

    We intend to remove linear implicit parameters, so I'm at least removing
    them from the 6.6 user manual

<sect2 id="linear-implicit-parameters">
<title>Linear implicit parameters</title>
<para>
Linear implicit parameters are an idea developed by Koen Claessen,
Mark Shields, and Simon PJ.  They address the long-standing
problem that monads seem over-kill for certain sorts of problem, notably:
</para>
<itemizedlist>
<listitem> <para> distributing a supply of unique names </para> </listitem>
<listitem> <para> distributing a supply of random numbers </para> </listitem>
<listitem> <para> distributing an oracle (as in QuickCheck) </para> </listitem>
</itemizedlist>

<para>
Linear implicit parameters are just like ordinary implicit parameters,
except that they are "linear"; that is, they cannot be copied, and
must be explicitly "split" instead.  Linear implicit parameters are
written '<literal>%x</literal>' instead of '<literal>?x</literal>'.
(The '/' in the '%' suggests the split!)
</para>
<para>
For example:
<programlisting>
    import GHC.Exts( Splittable )

    data NameSupply = ...

    splitNS :: NameSupply -> (NameSupply, NameSupply)
    newName :: NameSupply -> Name

    instance Splittable NameSupply where
	split = splitNS


    f :: (%ns :: NameSupply) => Env -> Expr -> Expr
    f env (Lam x e) = Lam x' (f env e)
		    where
		      x'   = newName %ns
		      env' = extend env x x'
    ...more equations for f...
</programlisting>
Notice that the implicit parameter %ns is consumed
<itemizedlist>
<listitem> <para> once by the call to <literal>newName</literal> </para> </listitem>
<listitem> <para> once by the recursive call to <literal>f</literal> </para></listitem>
</itemizedlist>
</para>
<para>
So the translation done by the type checker makes
the parameter explicit:
<programlisting>
    f :: NameSupply -> Env -> Expr -> Expr
    f ns env (Lam x e) = Lam x' (f ns1 env e)
		       where
	 		 (ns1,ns2) = splitNS ns
			 x' = newName ns2
			 env = extend env x x'
</programlisting>
Notice the call to 'split' introduced by the type checker.
How did it know to use 'splitNS'?  Because what it really did
was to introduce a call to the overloaded function 'split',
defined by the class <literal>Splittable</literal>:
<programlisting>
	class Splittable a where
	  split :: a -> (a,a)
</programlisting>
The instance for <literal>Splittable NameSupply</literal> tells GHC how to implement
split for name supplies.  But we can simply write
<programlisting>
	g x = (x, %ns, %ns)
</programlisting>
and GHC will infer
<programlisting>
	g :: (Splittable a, %ns :: a) => b -> (b,a,a)
</programlisting>
The <literal>Splittable</literal> class is built into GHC.  It's exported by module
<literal>GHC.Exts</literal>.
</para>
<para>
Other points:
<itemizedlist>
<listitem> <para> '<literal>?x</literal>' and '<literal>%x</literal>'
are entirely distinct implicit parameters: you
  can use them together and they won't interfere with each other. </para>
</listitem>

<listitem> <para> You can bind linear implicit parameters in 'with' clauses. </para> </listitem>

<listitem> <para>You cannot have implicit parameters (whether linear or not)
  in the context of a class or instance declaration. </para></listitem>
</itemizedlist>
</para>

<sect3><title>Warnings</title>

<para>
The monomorphism restriction is even more important than usual.
Consider the example above:
<programlisting>
    f :: (%ns :: NameSupply) => Env -> Expr -> Expr
    f env (Lam x e) = Lam x' (f env e)
		    where
		      x'   = newName %ns
		      env' = extend env x x'
</programlisting>
If we replaced the two occurrences of x' by (newName %ns), which is
usually a harmless thing to do, we get:
<programlisting>
    f :: (%ns :: NameSupply) => Env -> Expr -> Expr
    f env (Lam x e) = Lam (newName %ns) (f env e)
		    where
		      env' = extend env x (newName %ns)
</programlisting>
But now the name supply is consumed in <emphasis>three</emphasis> places
(the two calls to newName,and the recursive call to f), so
the result is utterly different.  Urk!  We don't even have
the beta rule.
</para>
<para>
Well, this is an experimental change.  With implicit
parameters we have already lost beta reduction anyway, and
(as John Launchbury puts it) we can't sensibly reason about
Haskell programs without knowing their typing.
</para>

</sect3>

<sect3><title>Recursive functions</title>
<para>Linear implicit parameters can be particularly tricky when you have a recursive function
Consider
<programlisting>
        foo :: %x::T => Int -> [Int]
        foo 0 = []
        foo n = %x : foo (n-1)
</programlisting>
where T is some type in class Splittable.</para>
<para>
Do you get a list of all the same T's or all different T's
(assuming that split gives two distinct T's back)?
</para><para>
If you supply the type signature, taking advantage of polymorphic
recursion, you get what you'd probably expect.  Here's the
translated term, where the implicit param is made explicit:
<programlisting>
        foo x 0 = []
        foo x n = let (x1,x2) = split x
                  in x1 : foo x2 (n-1)
</programlisting>
But if you don't supply a type signature, GHC uses the Hindley
Milner trick of using a single monomorphic instance of the function
for the recursive calls. That is what makes Hindley Milner type inference
work.  So the translation becomes
<programlisting>
        foo x = let
                  foom 0 = []
                  foom n = x : foom (n-1)
                in
                foom
</programlisting>
Result: 'x' is not split, and you get a list of identical T's.  So the
semantics of the program depends on whether or not foo has a type signature.
Yikes!
</para><para>
You may say that this is a good reason to dislike linear implicit parameters
and you'd be right.  That is why they are an experimental feature.
</para>
</sect3>

</sect2>

================ END OF Linear Implicit Parameters commented out -->

<sect2 id="kinding">
<title>Explicitly-kinded quantification</title>

<para>
Haskell infers the kind of each type variable.  Sometimes it is nice to be able
to give the kind explicitly as (machine-checked) documentation,
just as it is nice to give a type signature for a function.  On some occasions,
it is essential to do so.  For example, in his paper "Restricted Data Types in Haskell" (Haskell Workshop 1999)
John Hughes had to define the data type:
<screen>
     data Set cxt a = Set [a]
                    | Unused (cxt a -> ())
</screen>
The only use for the <literal>Unused</literal> constructor was to force the correct
kind for the type variable <literal>cxt</literal>.
</para>
<para>
GHC now instead allows you to specify the kind of a type variable directly, wherever
a type variable is explicitly bound, with the flag <option>-XKindSignatures</option>.
</para>
<para>
This flag enables kind signatures in the following places:
<itemizedlist>
<listitem><para><literal>data</literal> declarations:
<screen>
  data Set (cxt :: * -> *) a = Set [a]
</screen></para></listitem>
<listitem><para><literal>type</literal> declarations:
<screen>
  type T (f :: * -> *) = f Int
</screen></para></listitem>
<listitem><para><literal>class</literal> declarations:
<screen>
  class (Eq a) => C (f :: * -> *) a where ...
</screen></para></listitem>
<listitem><para><literal>forall</literal>'s in type signatures:
<screen>
  f :: forall (cxt :: * -> *). Set cxt Int
</screen></para></listitem>
</itemizedlist>
</para>

<para>
The parentheses are required.  Some of the spaces are required too, to
separate the lexemes.  If you write <literal>(f::*->*)</literal> you
will get a parse error, because "<literal>::*->*</literal>" is a
single lexeme in Haskell.
</para>

<para>
As part of the same extension, you can put kind annotations in types
as well.  Thus:
<screen>
   f :: (Int :: *) -> Int
   g :: forall a. a -> (a :: *)
</screen>
The syntax is
<screen>
   atype ::= '(' ctype '::' kind ')
</screen>
The parentheses are required.
</para>
</sect2>


<sect2 id="universal-quantification">
<title>Arbitrary-rank polymorphism
</title>

<para>
GHC's type system supports <emphasis>arbitrary-rank</emphasis>
explicit universal quantification in
types.
For example, all the following types are legal:
<programlisting>
    f1 :: forall a b. a -> b -> a
    g1 :: forall a b. (Ord a, Eq  b) => a -> b -> a

    f2 :: (forall a. a->a) -> Int -> Int
    g2 :: (forall a. Eq a => [a] -> a -> Bool) -> Int -> Int

    f3 :: ((forall a. a->a) -> Int) -> Bool -> Bool

    f4 :: Int -> (forall a. a -> a)
</programlisting>
Here, <literal>f1</literal> and <literal>g1</literal> are rank-1 types, and
can be written in standard Haskell (e.g. <literal>f1 :: a->b->a</literal>).
The <literal>forall</literal> makes explicit the universal quantification that
is implicitly added by Haskell.
</para>
<para>
The functions <literal>f2</literal> and <literal>g2</literal> have rank-2 types;
the <literal>forall</literal> is on the left of a function arrow.  As <literal>g2</literal>
shows, the polymorphic type on the left of the function arrow can be overloaded.
</para>
<para>
The function <literal>f3</literal> has a rank-3 type;
it has rank-2 types on the left of a function arrow.
</para>
<para>
GHC has three flags to control higher-rank types:
<itemizedlist>
<listitem><para>
 <option>-XPolymorphicComponents</option>: data constructors (only) can have polymorphic argument types.
</para></listitem>
<listitem><para>
 <option>-XRank2Types</option>: any function (including data constructors) can have a rank-2 type.
</para></listitem>
<listitem><para>
 <option>-XRankNTypes</option>: any function (including data constructors) can have an arbitrary-rank type.
That is,  you can nest <literal>forall</literal>s
arbitrarily deep in function arrows.
In particular, a forall-type (also called a "type scheme"),
including an operational type class context, is legal:
<itemizedlist>
<listitem> <para> On the left or right (see <literal>f4</literal>, for example)
of a function arrow </para> </listitem>
<listitem> <para> As the argument of a constructor, or type of a field, in a data type declaration. For
example, any of the <literal>f1,f2,f3,g1,g2</literal> above would be valid
field type signatures.</para> </listitem>
<listitem> <para> As the type of an implicit parameter </para> </listitem>
<listitem> <para> In a pattern type signature (see <xref linkend="scoped-type-variables"/>) </para> </listitem>
</itemizedlist>
</para></listitem>
</itemizedlist>
</para>


<sect3 id="univ">
<title>Examples
</title>

<para>
In a <literal>data</literal> or <literal>newtype</literal> declaration one can quantify
the types of the constructor arguments.  Here are several examples:
</para>

<para>

<programlisting>
data T a = T1 (forall b. b -> b -> b) a

data MonadT m = MkMonad { return :: forall a. a -> m a,
                          bind   :: forall a b. m a -> (a -> m b) -> m b
                        }

newtype Swizzle = MkSwizzle (Ord a => [a] -> [a])
</programlisting>

</para>

<para>
The constructors have rank-2 types:
</para>

<para>

<programlisting>
T1 :: forall a. (forall b. b -> b -> b) -> a -> T a
MkMonad :: forall m. (forall a. a -> m a)
                  -> (forall a b. m a -> (a -> m b) -> m b)
                  -> MonadT m
MkSwizzle :: (Ord a => [a] -> [a]) -> Swizzle
</programlisting>

</para>

<para>
Notice that you don't need to use a <literal>forall</literal> if there's an
explicit context.  For example in the first argument of the
constructor <function>MkSwizzle</function>, an implicit "<literal>forall a.</literal>" is
prefixed to the argument type.  The implicit <literal>forall</literal>
quantifies all type variables that are not already in scope, and are
mentioned in the type quantified over.
</para>

<para>
As for type signatures, implicit quantification happens for non-overloaded
types too.  So if you write this:

<programlisting>
  data T a = MkT (Either a b) (b -> b)
</programlisting>

it's just as if you had written this:

<programlisting>
  data T a = MkT (forall b. Either a b) (forall b. b -> b)
</programlisting>

That is, since the type variable <literal>b</literal> isn't in scope, it's
implicitly universally quantified.  (Arguably, it would be better
to <emphasis>require</emphasis> explicit quantification on constructor arguments
where that is what is wanted.  Feedback welcomed.)
</para>

<para>
You construct values of types <literal>T1, MonadT, Swizzle</literal> by applying
the constructor to suitable values, just as usual.  For example,
</para>

<para>

<programlisting>
    a1 :: T Int
    a1 = T1 (\xy->x) 3

    a2, a3 :: Swizzle
    a2 = MkSwizzle sort
    a3 = MkSwizzle reverse

    a4 :: MonadT Maybe
    a4 = let r x = Just x
	     b m k = case m of
		       Just y -> k y
		       Nothing -> Nothing
         in
         MkMonad r b

    mkTs :: (forall b. b -> b -> b) -> a -> [T a]
    mkTs f x y = [T1 f x, T1 f y]
</programlisting>

</para>

<para>
The type of the argument can, as usual, be more general than the type
required, as <literal>(MkSwizzle reverse)</literal> shows.  (<function>reverse</function>
does not need the <literal>Ord</literal> constraint.)
</para>

<para>
When you use pattern matching, the bound variables may now have
polymorphic types.  For example:
</para>

<para>

<programlisting>
    f :: T a -> a -> (a, Char)
    f (T1 w k) x = (w k x, w 'c' 'd')

    g :: (Ord a, Ord b) => Swizzle -> [a] -> (a -> b) -> [b]
    g (MkSwizzle s) xs f = s (map f (s xs))

    h :: MonadT m -> [m a] -> m [a]
    h m [] = return m []
    h m (x:xs) = bind m x          $ \y ->
                 bind m (h m xs)   $ \ys ->
                 return m (y:ys)
</programlisting>

</para>

<para>
In the function <function>h</function> we use the record selectors <literal>return</literal>
and <literal>bind</literal> to extract the polymorphic bind and return functions
from the <literal>MonadT</literal> data structure, rather than using pattern
matching.
</para>
</sect3>

<sect3>
<title>Type inference</title>

<para>
In general, type inference for arbitrary-rank types is undecidable.
GHC uses an algorithm proposed by Odersky and Laufer ("Putting type annotations to work", POPL'96)
to get a decidable algorithm by requiring some help from the programmer.
We do not yet have a formal specification of "some help" but the rule is this:
</para>
<para>
<emphasis>For a lambda-bound or case-bound variable, x, either the programmer
provides an explicit polymorphic type for x, or GHC's type inference will assume
that x's type has no foralls in it</emphasis>.
</para>
<para>
What does it mean to "provide" an explicit type for x?  You can do that by
giving a type signature for x directly, using a pattern type signature
(<xref linkend="scoped-type-variables"/>), thus:
<programlisting>
     \ f :: (forall a. a->a) -> (f True, f 'c')
</programlisting>
Alternatively, you can give a type signature to the enclosing
context, which GHC can "push down" to find the type for the variable:
<programlisting>
     (\ f -> (f True, f 'c')) :: (forall a. a->a) -> (Bool,Char)
</programlisting>
Here the type signature on the expression can be pushed inwards
to give a type signature for f.  Similarly, and more commonly,
one can give a type signature for the function itself:
<programlisting>
     h :: (forall a. a->a) -> (Bool,Char)
     h f = (f True, f 'c')
</programlisting>
You don't need to give a type signature if the lambda bound variable
is a constructor argument.  Here is an example we saw earlier:
<programlisting>
    f :: T a -> a -> (a, Char)
    f (T1 w k) x = (w k x, w 'c' 'd')
</programlisting>
Here we do not need to give a type signature to <literal>w</literal>, because
it is an argument of constructor <literal>T1</literal> and that tells GHC all
it needs to know.
</para>

</sect3>


<sect3 id="implicit-quant">
<title>Implicit quantification</title>

<para>
GHC performs implicit quantification as follows.  <emphasis>At the top level (only) of
user-written types, if and only if there is no explicit <literal>forall</literal>,
GHC finds all the type variables mentioned in the type that are not already
in scope, and universally quantifies them.</emphasis>  For example, the following pairs are
equivalent:
<programlisting>
  f :: a -> a
  f :: forall a. a -> a

  g (x::a) = let
                h :: a -> b -> b
                h x y = y
             in ...
  g (x::a) = let
                h :: forall b. a -> b -> b
                h x y = y
             in ...
</programlisting>
</para>
<para>
Notice that GHC does <emphasis>not</emphasis> find the innermost possible quantification
point.  For example:
<programlisting>
  f :: (a -> a) -> Int
           -- MEANS
  f :: forall a. (a -> a) -> Int
           -- NOT
  f :: (forall a. a -> a) -> Int


  g :: (Ord a => a -> a) -> Int
           -- MEANS the illegal type
  g :: forall a. (Ord a => a -> a) -> Int
           -- NOT
  g :: (forall a. Ord a => a -> a) -> Int
</programlisting>
The latter produces an illegal type, which you might think is silly,
but at least the rule is simple.  If you want the latter type, you
can write your for-alls explicitly.  Indeed, doing so is strongly advised
for rank-2 types.
</para>
</sect3>
</sect2>


<sect2 id="impredicative-polymorphism">
<title>Impredicative polymorphism
</title>
<para>GHC supports <emphasis>impredicative polymorphism</emphasis>,
enabled with <option>-XImpredicativeTypes</option>.
This means
that you can call a polymorphic function at a polymorphic type, and
parameterise data structures over polymorphic types.  For example:
<programlisting>
  f :: Maybe (forall a. [a] -> [a]) -> Maybe ([Int], [Char])
  f (Just g) = Just (g [3], g "hello")
  f Nothing  = Nothing
</programlisting>
Notice here that the <literal>Maybe</literal> type is parameterised by the
<emphasis>polymorphic</emphasis> type <literal>(forall a. [a] ->
[a])</literal>.
</para>
<para>The technical details of this extension are described in the paper
<ulink url="http://research.microsoft.com/%7Esimonpj/papers/boxy/">Boxy types:
type inference for higher-rank types and impredicativity</ulink>,
which appeared at ICFP 2006.
</para>
</sect2>

<sect2 id="scoped-type-variables">
<title>Lexically scoped type variables
</title>

<para>
GHC supports <emphasis>lexically scoped type variables</emphasis>, without
which some type signatures are simply impossible to write. For example:
<programlisting>
f :: forall a. [a] -> [a]
f xs = ys ++ ys
     where
       ys :: [a]
       ys = reverse xs
</programlisting>
The type signature for <literal>f</literal> brings the type variable <literal>a</literal> into scope,
because of the explicit <literal>forall</literal> (<xref linkend="decl-type-sigs"/>).
The type variables bound by a <literal>forall</literal> scope over
the entire definition of the accompanying value declaration.
In this example, the type variable <literal>a</literal> scopes over the whole
definition of <literal>f</literal>, including over
the type signature for <varname>ys</varname>.
In Haskell 98 it is not possible to declare
a type for <varname>ys</varname>; a major benefit of scoped type variables is that
it becomes possible to do so.
</para>
<para>Lexically-scoped type variables are enabled by
<option>-XScopedTypeVariables</option>.  This flag implies <option>-XRelaxedPolyRec</option>.
</para>
<para>Note: GHC 6.6 contains substantial changes to the way that scoped type
variables work, compared to earlier releases.  Read this section
carefully!</para>

<sect3>
<title>Overview</title>

<para>The design follows the following principles
<itemizedlist>
<listitem><para>A scoped type variable stands for a type <emphasis>variable</emphasis>, and not for
a <emphasis>type</emphasis>. (This is a change from GHC's earlier
design.)</para></listitem>
<listitem><para>Furthermore, distinct lexical type variables stand for distinct
type variables.  This means that every programmer-written type signature
(including one that contains free scoped type variables) denotes a
<emphasis>rigid</emphasis> type; that is, the type is fully known to the type
checker, and no inference is involved.</para></listitem>
<listitem><para>Lexical type variables may be alpha-renamed freely, without
changing the program.</para></listitem>
</itemizedlist>
</para>
<para>
A <emphasis>lexically scoped type variable</emphasis> can be bound by:
<itemizedlist>
<listitem><para>A declaration type signature (<xref linkend="decl-type-sigs"/>)</para></listitem>
<listitem><para>An expression type signature (<xref linkend="exp-type-sigs"/>)</para></listitem>
<listitem><para>A pattern type signature (<xref linkend="pattern-type-sigs"/>)</para></listitem>
<listitem><para>Class and instance declarations (<xref linkend="cls-inst-scoped-tyvars"/>)</para></listitem>
</itemizedlist>
</para>
<para>
In Haskell, a programmer-written type signature is implicitly quantified over
its free type variables (<ulink
url="http://www.haskell.org/onlinereport/decls.html#sect4.1.2">Section
4.1.2</ulink>
of the Haskell Report).
Lexically scoped type variables affect this implicit quantification rules
as follows: any type variable that is in scope is <emphasis>not</emphasis> universally
quantified. For example, if type variable <literal>a</literal> is in scope,
then
<programlisting>
  (e :: a -> a)     means     (e :: a -> a)
  (e :: b -> b)     means     (e :: forall b. b->b)
  (e :: a -> b)     means     (e :: forall b. a->b)
</programlisting>
</para>


</sect3>


<sect3 id="decl-type-sigs">
<title>Declaration type signatures</title>
<para>A declaration type signature that has <emphasis>explicit</emphasis>
quantification (using <literal>forall</literal>) brings into scope the
explicitly-quantified
type variables, in the definition of the named function.  For example:
<programlisting>
  f :: forall a. [a] -> [a]
  f (x:xs) = xs ++ [ x :: a ]
</programlisting>
The "<literal>forall a</literal>" brings "<literal>a</literal>" into scope in
the definition of "<literal>f</literal>".
</para>
<para>This only happens if:
<itemizedlist>
<listitem><para> The quantification in <literal>f</literal>'s type
signature is explicit.  For example:
<programlisting>
  g :: [a] -> [a]
  g (x:xs) = xs ++ [ x :: a ]
</programlisting>
This program will be rejected, because "<literal>a</literal>" does not scope
over the definition of "<literal>g</literal>", so "<literal>x::a</literal>"
means "<literal>x::forall a. a</literal>" by Haskell's usual implicit
quantification rules.
</para></listitem>
<listitem><para> The signature gives a type for a function binding or a bare variable binding,
not a pattern binding.
For example:
<programlisting>
  f1 :: forall a. [a] -> [a]
  f1 (x:xs) = xs ++ [ x :: a ]   -- OK

  f2 :: forall a. [a] -> [a]
  f2 = \(x:xs) -> xs ++ [ x :: a ]   -- OK

  f3 :: forall a. [a] -> [a]
  Just f3 = Just (\(x:xs) -> xs ++ [ x :: a ])   -- Not OK!
</programlisting>
The binding for <literal>f3</literal> is a pattern binding, and so its type signature
does not bring <literal>a</literal> into scope.   However <literal>f1</literal> is a
function binding, and <literal>f2</literal> binds a bare variable; in both cases
the type signature brings <literal>a</literal> into scope.
</para></listitem>
</itemizedlist>
</para>
</sect3>

<sect3 id="exp-type-sigs">
<title>Expression type signatures</title>

<para>An expression type signature that has <emphasis>explicit</emphasis>
quantification (using <literal>forall</literal>) brings into scope the
explicitly-quantified
type variables, in the annotated expression.  For example:
<programlisting>
  f = runST ( (op >>= \(x :: STRef s Int) -> g x) :: forall s. ST s Bool )
</programlisting>
Here, the type signature <literal>forall s. ST s Bool</literal> brings the
type variable <literal>s</literal> into scope, in the annotated expression
<literal>(op >>= \(x :: STRef s Int) -> g x)</literal>.
</para>

</sect3>

<sect3 id="pattern-type-sigs">
<title>Pattern type signatures</title>
<para>
A type signature may occur in any pattern; this is a <emphasis>pattern type
signature</emphasis>.
For example:
<programlisting>
  -- f and g assume that 'a' is already in scope
  f = \(x::Int, y::a) -> x
  g (x::a) = x
  h ((x,y) :: (Int,Bool)) = (y,x)
</programlisting>
In the case where all the type variables in the pattern type signature are
already in scope (i.e. bound by the enclosing context), matters are simple: the
signature simply constrains the type of the pattern in the obvious way.
</para>
<para>
Unlike expression and declaration type signatures, pattern type signatures are not implicitly generalised.
The pattern in a <emphasis>pattern binding</emphasis> may only mention type variables
that are already in scope.  For example:
<programlisting>
  f :: forall a. [a] -> (Int, [a])
  f xs = (n, zs)
    where
      (ys::[a], n) = (reverse xs, length xs) -- OK
      zs::[a] = xs ++ ys                     -- OK

      Just (v::b) = ...  -- Not OK; b is not in scope
</programlisting>
Here, the pattern signatures for <literal>ys</literal> and <literal>zs</literal>
are fine, but the one for <literal>v</literal> is not because <literal>b</literal> is
not in scope.
</para>
<para>
However, in all patterns <emphasis>other</emphasis> than pattern bindings, a pattern
type signature may mention a type variable that is not in scope; in this case,
<emphasis>the signature brings that type variable into scope</emphasis>.
This is particularly important for existential data constructors.  For example:
<programlisting>
  data T = forall a. MkT [a]

  k :: T -> T
  k (MkT [t::a]) = MkT t3
                 where
                   t3::[a] = [t,t,t]
</programlisting>
Here, the pattern type signature <literal>(t::a)</literal> mentions a lexical type
variable that is not already in scope.  Indeed, it <emphasis>cannot</emphasis> already be in scope,
because it is bound by the pattern match.  GHC's rule is that in this situation
(and only then), a pattern type signature can mention a type variable that is
not already in scope; the effect is to bring it into scope, standing for the
existentially-bound type variable.
</para>
<para>
When a pattern type signature binds a type variable in this way, GHC insists that the
type variable is bound to a <emphasis>rigid</emphasis>, or fully-known, type variable.
This means that any user-written type signature always stands for a completely known type.
</para>
<para>
If all this seems a little odd, we think so too.  But we must have
<emphasis>some</emphasis> way to bring such type variables into scope, else we
could not name existentially-bound type variables in subsequent type signatures.
</para>
<para>
This is (now) the <emphasis>only</emphasis> situation in which a pattern type
signature is allowed to mention a lexical variable that is not already in
scope.
For example, both <literal>f</literal> and <literal>g</literal> would be
illegal if <literal>a</literal> was not already in scope.
</para>


</sect3>

<!-- ==================== Commented out part about result type signatures

<sect3 id="result-type-sigs">
<title>Result type signatures</title>

<para>
The result type of a function, lambda, or case expression alternative can be given a signature, thus:

<programlisting>
  {- f assumes that 'a' is already in scope -}
  f x y :: [a] = [x,y,x]

  g = \ x :: [Int] -> [3,4]

  h :: forall a. [a] -> a
  h xs = case xs of
	    (y:ys) :: a -> y
</programlisting>
The final <literal>:: [a]</literal> after the patterns of <literal>f</literal> gives the type of
the result of the function.  Similarly, the body of the lambda in the RHS of
<literal>g</literal> is <literal>[Int]</literal>, and the RHS of the case
alternative in <literal>h</literal> is <literal>a</literal>.
</para>
<para> A result type signature never brings new type variables into scope.</para>
<para>
There are a couple of syntactic wrinkles.  First, notice that all three
examples would parse quite differently with parentheses:
<programlisting>
  {- f assumes that 'a' is already in scope -}
  f x (y :: [a]) = [x,y,x]

  g = \ (x :: [Int]) -> [3,4]

  h :: forall a. [a] -> a
  h xs = case xs of
	    ((y:ys) :: a) -> y
</programlisting>
Now the signature is on the <emphasis>pattern</emphasis>; and
<literal>h</literal> would certainly be ill-typed (since the pattern
<literal>(y:ys)</literal> cannot have the type <literal>a</literal>.

Second, to avoid ambiguity, the type after the &ldquo;<literal>::</literal>&rdquo; in a result
pattern signature on a lambda or <literal>case</literal> must be atomic (i.e. a single
token or a parenthesised type of some sort).  To see why,
consider how one would parse this:
<programlisting>
  \ x :: a -> b -> x
</programlisting>
</para>
</sect3>

 -->

<sect3 id="cls-inst-scoped-tyvars">
<title>Class and instance declarations</title>
<para>

The type variables in the head of a <literal>class</literal> or <literal>instance</literal> declaration
scope over the methods defined in the <literal>where</literal> part.  For example:


<programlisting>
  class C a where
    op :: [a] -> a

    op xs = let ys::[a]
                ys = reverse xs
            in
            head ys
</programlisting>
</para>
</sect3>

</sect2>


<sect2 id="typing-binds">
<title>Generalised typing of mutually recursive bindings</title>

<para>
The Haskell Report specifies that a group of bindings (at top level, or in a
<literal>let</literal> or <literal>where</literal>) should be sorted into
strongly-connected components, and then type-checked in dependency order
(<ulink url="http://www.haskell.org/onlinereport/decls.html#sect4.5.1">Haskell
Report, Section 4.5.1</ulink>).
As each group is type-checked, any binders of the group that
have
an explicit type signature are put in the type environment with the specified
polymorphic type,
and all others are monomorphic until the group is generalised
(<ulink url="http://www.haskell.org/onlinereport/decls.html#sect4.5.2">Haskell Report, Section 4.5.2</ulink>).
</para>

<para>Following a suggestion of Mark Jones, in his paper
<ulink url="http://citeseer.ist.psu.edu/424440.html">Typing Haskell in
Haskell</ulink>,
GHC implements a more general scheme.  If <option>-XRelaxedPolyRec</option> is
specified:
<emphasis>the dependency analysis ignores references to variables that have an explicit
type signature</emphasis>.
As a result of this refined dependency analysis, the dependency groups are smaller, and more bindings will
typecheck.  For example, consider:
<programlisting>
  f :: Eq a =&gt; a -> Bool
  f x = (x == x) || g True || g "Yes"

  g y = (y &lt;= y) || f True
</programlisting>
This is rejected by Haskell 98, but under Jones's scheme the definition for
<literal>g</literal> is typechecked first, separately from that for
<literal>f</literal>,
because the reference to <literal>f</literal> in <literal>g</literal>'s right
hand side is ignored by the dependency analysis.  Then <literal>g</literal>'s
type is generalised, to get
<programlisting>
  g :: Ord a =&gt; a -> Bool
</programlisting>
Now, the definition for <literal>f</literal> is typechecked, with this type for
<literal>g</literal> in the type environment.
</para>

<para>
The same refined dependency analysis also allows the type signatures of
mutually-recursive functions to have different contexts, something that is illegal in
Haskell 98 (Section 4.5.2, last sentence).  With
<option>-XRelaxedPolyRec</option>
GHC only insists that the type signatures of a <emphasis>refined</emphasis> group have identical
type signatures; in practice this means that only variables bound by the same
pattern binding must have the same context.  For example, this is fine:
<programlisting>
  f :: Eq a =&gt; a -> Bool
  f x = (x == x) || g True

  g :: Ord a =&gt; a -> Bool
  g y = (y &lt;= y) || f True
</programlisting>
</para>
</sect2>

<sect2 id="mono-local-binds">
<title>Monomorphic local bindings</title>
<para>
We are actively thinking of simplifying GHC's type system, by <emphasis>not generalising local bindings</emphasis>.
The rationale is described in the paper
<ulink url="http://research.microsoft.com/~simonpj/papers/constraints/index.htm">Let should not be generalised</ulink>.
</para>
<para>
The experimental new behaviour is enabled by the flag <option>-XMonoLocalBinds</option>.  The effect is
that local (that is, non-top-level) bindings without a type signature are not generalised at all.  You can
think of it as an extreme (but much more predictable) version of the Monomorphism Restriction.
If you supply a type signature, then the flag has no effect.
</para>
</sect2>

</sect1>
<!-- ==================== End of type system extensions =================  -->

<!-- ====================== TEMPLATE HASKELL =======================  -->

<sect1 id="template-haskell">
<title>Template Haskell</title>

<para>Template Haskell allows you to do compile-time meta-programming in
Haskell.
The background to
the main technical innovations is discussed in "<ulink
url="http://research.microsoft.com/~simonpj/papers/meta-haskell/">
Template Meta-programming for Haskell</ulink>" (Proc Haskell Workshop 2002).
</para>
<para>
There is a Wiki page about
Template Haskell at <ulink url="http://www.haskell.org/haskellwiki/Template_Haskell">
http://www.haskell.org/haskellwiki/Template_Haskell</ulink>, and that is the best place to look for
further details.
You may also
consult the <ulink
url="http://www.haskell.org/ghc/docs/latest/html/libraries/index.html">online
Haskell library reference material</ulink>
(look for module <literal>Language.Haskell.TH</literal>).
Many changes to the original design are described in
      <ulink url="http://research.microsoft.com/~simonpj/papers/meta-haskell/notes2.ps">
Notes on Template Haskell version 2</ulink>.
Not all of these changes are in GHC, however.
</para>

<para> The first example from that paper is set out below (<xref linkend="th-example"/>)
as a worked example to help get you started.
</para>

<para>
The documentation here describes the realisation of Template Haskell in GHC.  It is not detailed enough to
understand Template Haskell; see the <ulink url="http://haskell.org/haskellwiki/Template_Haskell">
Wiki page</ulink>.
</para>

    <sect2>
      <title>Syntax</title>

      <para> Template Haskell has the following new syntactic
      constructions.  You need to use the flag
      <option>-XTemplateHaskell</option>
	<indexterm><primary><option>-XTemplateHaskell</option></primary>
      </indexterm>to switch these syntactic extensions on
      (<option>-XTemplateHaskell</option> is no longer implied by
      <option>-fglasgow-exts</option>).</para>

	<itemizedlist>
	      <listitem><para>
		  A splice is written <literal>$x</literal>, where <literal>x</literal> is an
		  identifier, or <literal>$(...)</literal>, where the "..." is an arbitrary expression.
		  There must be no space between the "$" and the identifier or parenthesis.  This use
		  of "$" overrides its meaning as an infix operator, just as "M.x" overrides the meaning
		  of "." as an infix operator.  If you want the infix operator, put spaces around it.
		  </para>
	      <para> A splice can occur in place of
		  <itemizedlist>
		    <listitem><para> an expression; the spliced expression must
		    have type <literal>Q Exp</literal></para></listitem>
		    <listitem><para> an type; the spliced expression must
		    have type <literal>Q Typ</literal></para></listitem>
		    <listitem><para> a list of top-level declarations; the spliced expression
                    must have type <literal>Q [Dec]</literal></para></listitem>
		    </itemizedlist>
            Note that pattern splices are not supported.
            Inside a splice you can only call functions defined in imported modules,
	    not functions defined elsewhere in the same module.</para></listitem>

	      <listitem><para>
		  A expression quotation is written in Oxford brackets, thus:
		  <itemizedlist>
		    <listitem><para> <literal>[| ... |]</literal>, or <literal>[e| ... |]</literal>,
                             where the "..." is an expression;
                             the quotation has type <literal>Q Exp</literal>.</para></listitem>
		    <listitem><para> <literal>[d| ... |]</literal>, where the "..." is a list of top-level declarations;
                             the quotation has type <literal>Q [Dec]</literal>.</para></listitem>
		    <listitem><para> <literal>[t| ... |]</literal>, where the "..." is a type;
                             the quotation has type <literal>Q Type</literal>.</para></listitem>
		    <listitem><para> <literal>[p| ... |]</literal>, where the "..." is a pattern;
                             the quotation has type <literal>Q Pat</literal>.</para></listitem>
		  </itemizedlist></para></listitem>

	      <listitem><para>
		  A quasi-quotation can appear in either a pattern context or an
		  expression context and is also written in Oxford brackets:
		  <itemizedlist>
		    <listitem><para> <literal>[<replaceable>varid</replaceable>| ... |]</literal>,
                        where the "..." is an arbitrary string; a full description of the
			quasi-quotation facility is given in <xref linkend="th-quasiquotation"/>.</para></listitem>
		  </itemizedlist></para></listitem>

	      <listitem><para>
		  A name can be quoted with either one or two prefix single quotes:
		  <itemizedlist>
		    <listitem><para> <literal>'f</literal> has type <literal>Name</literal>, and names the function <literal>f</literal>.
		  Similarly <literal>'C</literal> has type <literal>Name</literal> and names the data constructor <literal>C</literal>.
		  In general <literal>'</literal><replaceable>thing</replaceable> interprets <replaceable>thing</replaceable> in an expression context.
		     </para></listitem>
		    <listitem><para> <literal>''T</literal> has type <literal>Name</literal>, and names the type constructor  <literal>T</literal>.
		  That is, <literal>''</literal><replaceable>thing</replaceable> interprets <replaceable>thing</replaceable> in a type context.
		     </para></listitem>
		  </itemizedlist>
	          These <literal>Names</literal> can be used to construct Template Haskell expressions, patterns, declarations etc.  They
	          may also be given as an argument to the <literal>reify</literal> function.
	         </para>
		</listitem>

	      <listitem><para> You may omit the <literal>$(...)</literal> in a top-level declaration splice.
              Simply writing an expression (rather than a declaration) implies a splice.  For example, you can write
<programlisting>
module Foo where
import Bar

f x = x

$(deriveStuff 'f)   -- Uses the $(...) notation

g y = y+1

deriveStuff 'g      -- Omits the $(...)

h z = z-1
</programlisting>
            This abbreviation makes top-level declaration slices quieter and less intimidating.
	    </para></listitem>


	</itemizedlist>
(Compared to the original paper, there are many differences of detail.
The syntax for a declaration splice uses "<literal>$</literal>" not "<literal>splice</literal>".
The type of the enclosed expression must be  <literal>Q [Dec]</literal>, not  <literal>[Q Dec]</literal>.
Pattern splices and quotations are not implemented.)

</sect2>

<sect2>  <title> Using Template Haskell </title>
<para>
<itemizedlist>
    <listitem><para>
    The data types and monadic constructor functions for Template Haskell are in the library
    <literal>Language.Haskell.THSyntax</literal>.
    </para></listitem>

    <listitem><para>
    You can only run a function at compile time if it is imported from another module.  That is,
	    you can't define a function in a module, and call it from within a splice in the same module.
	    (It would make sense to do so, but it's hard to implement.)
   </para></listitem>

   <listitem><para>
   You can only run a function at compile time if it is imported
   from another module <emphasis>that is not part of a mutually-recursive group of modules
   that includes the module currently being compiled</emphasis>.  Furthermore, all of the modules of
   the mutually-recursive group must be reachable by non-SOURCE imports from the module where the
   splice is to be run.</para>
   <para>
   For example, when compiling module A,
   you can only run Template Haskell functions imported from B if B does not import A (directly or indirectly).
   The reason should be clear: to run B we must compile and run A, but we are currently type-checking A.
   </para></listitem>

    <listitem><para>
	    The flag <literal>-ddump-splices</literal> shows the expansion of all top-level splices as they happen.
   </para></listitem>
    <listitem><para>
	    If you are building GHC from source, you need at least a stage-2 bootstrap compiler to
	      run Template Haskell.  A stage-1 compiler will reject the TH constructs.  Reason: TH
	      compiles and runs a program, and then looks at the result.  So it's important that
	      the program it compiles produces results whose representations are identical to
	      those of the compiler itself.
   </para></listitem>
</itemizedlist>
</para>
<para> Template Haskell works in any mode (<literal>--make</literal>, <literal>--interactive</literal>,
	or file-at-a-time).  There used to be a restriction to the former two, but that restriction
	has been lifted.
</para>
</sect2>

<sect2 id="th-example">  <title> A Template Haskell Worked Example </title>
<para>To help you get over the confidence barrier, try out this skeletal worked example.
  First cut and paste the two modules below into "Main.hs" and "Printf.hs":</para>

<programlisting>

{- Main.hs -}
module Main where

-- Import our template "pr"
import Printf ( pr )

-- The splice operator $ takes the Haskell source code
-- generated at compile time by "pr" and splices it into
-- the argument of "putStrLn".
main = putStrLn ( $(pr "Hello") )


{- Printf.hs -}
module Printf where

-- Skeletal printf from the paper.
-- It needs to be in a separate module to the one where
-- you intend to use it.

-- Import some Template Haskell syntax
import Language.Haskell.TH

-- Describe a format string
data Format = D | S | L String

-- Parse a format string.  This is left largely to you
-- as we are here interested in building our first ever
-- Template Haskell program and not in building printf.
parse :: String -> [Format]
parse s   = [ L s ]

-- Generate Haskell source code from a parsed representation
-- of the format string.  This code will be spliced into
-- the module which calls "pr", at compile time.
gen :: [Format] -> Q Exp
gen [D]   = [| \n -> show n |]
gen [S]   = [| \s -> s |]
gen [L s] = stringE s

-- Here we generate the Haskell code for the splice
-- from an input format string.
pr :: String -> Q Exp
pr s = gen (parse s)
</programlisting>

<para>Now run the compiler (here we are a Cygwin prompt on Windows):
</para>
<programlisting>
$ ghc --make -XTemplateHaskell main.hs -o main.exe
</programlisting>

<para>Run "main.exe" and here is your output:</para>

<programlisting>
$ ./main
Hello
</programlisting>

</sect2>

<sect2>
<title>Using Template Haskell with Profiling</title>
<indexterm><primary>profiling</primary><secondary>with Template Haskell</secondary></indexterm>

<para>Template Haskell relies on GHC's built-in bytecode compiler and
interpreter to run the splice expressions.  The bytecode interpreter
runs the compiled expression on top of the same runtime on which GHC
itself is running; this means that the compiled code referred to by
the interpreted expression must be compatible with this runtime, and
in particular this means that object code that is compiled for
profiling <emphasis>cannot</emphasis> be loaded and used by a splice
expression, because profiled object code is only compatible with the
profiling version of the runtime.</para>

<para>This causes difficulties if you have a multi-module program
containing Template Haskell code and you need to compile it for
profiling, because GHC cannot load the profiled object code and use it
when executing the splices.  Fortunately GHC provides a workaround.
The basic idea is to compile the program twice:</para>

<orderedlist>
<listitem>
  <para>Compile the program or library first the normal way, without
  <option>-prof</option><indexterm><primary><option>-prof</option></primary></indexterm>.</para>
</listitem>
<listitem>
  <para>Then compile it again with <option>-prof</option>, and
  additionally use <option>-osuf
  p_o</option><indexterm><primary><option>-osuf</option></primary></indexterm>
  to name the object files differently (you can choose any suffix
  that isn't the normal object suffix here).  GHC will automatically
  load the object files built in the first step when executing splice
  expressions.  If you omit the <option>-osuf</option> flag when
  building with <option>-prof</option> and Template Haskell is used,
  GHC will emit an error message. </para>
</listitem>
</orderedlist>
</sect2>

<sect2 id="th-quasiquotation">  <title> Template Haskell Quasi-quotation </title>
<para>Quasi-quotation allows patterns and expressions to be written using
programmer-defined concrete syntax; the motivation behind the extension and
several examples are documented in
"<ulink url="http://www.eecs.harvard.edu/~mainland/ghc-quasiquoting/">Why It's
Nice to be Quoted: Quasiquoting for Haskell</ulink>" (Proc Haskell Workshop
2007). The example below shows how to write a quasiquoter for a simple
expression language.</para>
<para>
Here are the salient features
<itemizedlist>
<listitem><para>
A quasi-quote has the form
<literal>[<replaceable>quoter</replaceable>| <replaceable>string</replaceable> |]</literal>.
<itemizedlist>
<listitem><para>
The <replaceable>quoter</replaceable> must be the (unqualified) name of an imported
quoter; it cannot be an arbitrary expression.
</para></listitem>
<listitem><para>
The <replaceable>quoter</replaceable> cannot be "<literal>e</literal>",
"<literal>t</literal>", "<literal>d</literal>", or "<literal>p</literal>", since
those overlap with Template Haskell quotations.
</para></listitem>
<listitem><para>
There must be no spaces in the token
<literal>[<replaceable>quoter</replaceable>|</literal>.
</para></listitem>
<listitem><para>
The quoted <replaceable>string</replaceable>
can be arbitrary, and may contain newlines.
</para></listitem>
<listitem><para>
The quoted <replaceable>string</replaceable>
finishes at the first occurrence of the two-character sequence <literal>"|]"</literal>.
Absolutely no escaping is performed.  If you want to embed that character
sequence in the string, you must invent your own escape convention (such
as, say, using the string <literal>"|~]"</literal> instead), and make your
quoter function interpret <literal>"|~]"</literal> as <literal>"|]"</literal>.
One way to implement this is to compose your quoter with a pre-processing pass to
perform your escape conversion.  See the
<ulink url="http://hackage.haskell.org/trac/ghc/ticket/5348">
discussion in Trac</ulink> for details.
</para></listitem>
</itemizedlist>
</para></listitem>

<listitem><para>
A quasiquote may appear in place of
<itemizedlist>
<listitem><para>An expression</para></listitem>
<listitem><para>A pattern</para></listitem>
<listitem><para>A type</para></listitem>
<listitem><para>A top-level declaration</para></listitem>
</itemizedlist>
(Only the first two are described in the paper.)
</para></listitem>

<listitem><para>
A quoter is a value of type <literal>Language.Haskell.TH.Quote.QuasiQuoter</literal>,
which is defined thus:
<programlisting>
data QuasiQuoter = QuasiQuoter { quoteExp  :: String -> Q Exp,
                                 quotePat  :: String -> Q Pat,
                                 quoteType :: String -> Q Type,
                                 quoteDec  :: String -> Q [Dec] }
</programlisting>
That is, a quoter is a tuple of four parsers, one for each of the contexts
in which a quasi-quote can occur.
</para></listitem>
<listitem><para>
A quasi-quote is expanded by applying the appropriate parser to the string
enclosed by the Oxford brackets.  The context of the quasi-quote (expression, pattern,
type, declaration) determines which of the parsers is called.
</para></listitem>
</itemizedlist>
</para>
<para>
The example below shows quasi-quotation in action.  The quoter <literal>expr</literal>
is bound to a value of type <literal>QuasiQuoter</literal> defined in module <literal>Expr</literal>.
The example makes use of an antiquoted
variable <literal>n</literal>, indicated by the syntax <literal>'int:n</literal>
(this syntax for anti-quotation was defined by the parser's
author, <emphasis>not</emphasis> by GHC). This binds <literal>n</literal> to the
integer value argument of the constructor <literal>IntExpr</literal> when
pattern matching. Please see the referenced paper for further details regarding
anti-quotation as well as the description of a technique that uses SYB to
leverage a single parser of type <literal>String -> a</literal> to generate both
an expression parser that returns a value of type <literal>Q Exp</literal> and a
pattern parser that returns a value of type <literal>Q Pat</literal>.
</para>

<para>
Quasiquoters must obey the same stage restrictions as Template Haskell, e.g., in
the example, <literal>expr</literal> cannot be defined
in <literal>Main.hs</literal> where it is used, but must be imported.
</para>

<programlisting>
{- ------------- file Main.hs --------------- -}
module Main where

import Expr

main :: IO ()
main = do { print $ eval [expr|1 + 2|]
          ; case IntExpr 1 of
              { [expr|'int:n|] -> print n
              ;  _              -> return ()
              }
          }


{- ------------- file Expr.hs --------------- -}
module Expr where

import qualified Language.Haskell.TH as TH
import Language.Haskell.TH.Quote

data Expr  =  IntExpr Integer
           |  AntiIntExpr String
           |  BinopExpr BinOp Expr Expr
           |  AntiExpr String
    deriving(Show, Typeable, Data)

data BinOp  =  AddOp
            |  SubOp
            |  MulOp
            |  DivOp
    deriving(Show, Typeable, Data)

eval :: Expr -> Integer
eval (IntExpr n)        = n
eval (BinopExpr op x y) = (opToFun op) (eval x) (eval y)
  where
    opToFun AddOp = (+)
    opToFun SubOp = (-)
    opToFun MulOp = (*)
    opToFun DivOp = div

expr = QuasiQuoter { quoteExp = parseExprExp, quotePat =  parseExprPat }

-- Parse an Expr, returning its representation as
-- either a Q Exp or a Q Pat. See the referenced paper
-- for how to use SYB to do this by writing a single
-- parser of type String -> Expr instead of two
-- separate parsers.

parseExprExp :: String -> Q Exp
parseExprExp ...

parseExprPat :: String -> Q Pat
parseExprPat ...
</programlisting>

<para>Now run the compiler:
<programlisting>
$ ghc --make -XQuasiQuotes Main.hs -o main
</programlisting>
</para>

<para>Run "main" and here is your output:
<programlisting>
$ ./main
3
1
</programlisting>
</para>
</sect2>

</sect1>

<!-- ===================== Arrow notation ===================  -->

<sect1 id="arrow-notation">
<title>Arrow notation
</title>

<para>Arrows are a generalization of monads introduced by John Hughes.
For more details, see
<itemizedlist>

<listitem>
<para>
&ldquo;Generalising Monads to Arrows&rdquo;,
John Hughes, in <citetitle>Science of Computer Programming</citetitle> 37,
pp67&ndash;111, May 2000.
The paper that introduced arrows: a friendly introduction, motivated with
programming examples.
</para>
</listitem>

<listitem>
<para>
&ldquo;<ulink url="http://www.soi.city.ac.uk/~ross/papers/notation.html">A New Notation for Arrows</ulink>&rdquo;,
Ross Paterson, in <citetitle>ICFP</citetitle>, Sep 2001.
Introduced the notation described here.
</para>
</listitem>

<listitem>
<para>
&ldquo;<ulink url="http://www.soi.city.ac.uk/~ross/papers/fop.html">Arrows and Computation</ulink>&rdquo;,
Ross Paterson, in <citetitle>The Fun of Programming</citetitle>,
Palgrave, 2003.
</para>
</listitem>

<listitem>
<para>
&ldquo;<ulink url="http://www.cs.chalmers.se/~rjmh/afp-arrows.pdf">Programming with Arrows</ulink>&rdquo;,
John Hughes, in <citetitle>5th International Summer School on
Advanced Functional Programming</citetitle>,
<citetitle>Lecture Notes in Computer Science</citetitle> vol. 3622,
Springer, 2004.
This paper includes another introduction to the notation,
with practical examples.
</para>
</listitem>

<listitem>
<para>
&ldquo;<ulink url="http://www.haskell.org/ghc/docs/papers/arrow-rules.pdf">Type and Translation Rules for Arrow Notation in GHC</ulink>&rdquo;,
Ross Paterson and Simon Peyton Jones, September 16, 2004.
A terse enumeration of the formal rules used
(extracted from comments in the source code).
</para>
</listitem>

<listitem>
<para>
The arrows web page at
<ulink url="http://www.haskell.org/arrows/"><literal>http://www.haskell.org/arrows/</literal></ulink>.
</para>
</listitem>

</itemizedlist>
With the <option>-XArrows</option> flag, GHC supports the arrow
notation described in the second of these papers,
translating it using combinators from the
<ulink url="&libraryBaseLocation;/Control-Arrow.html"><literal>Control.Arrow</literal></ulink>
module.
What follows is a brief introduction to the notation;
it won't make much sense unless you've read Hughes's paper.
</para>

<para>The extension adds a new kind of expression for defining arrows:
<screen>
<replaceable>exp</replaceable><superscript>10</superscript> ::= ...
       |  proc <replaceable>apat</replaceable> -> <replaceable>cmd</replaceable>
</screen>
where <literal>proc</literal> is a new keyword.
The variables of the pattern are bound in the body of the
<literal>proc</literal>-expression,
which is a new sort of thing called a <firstterm>command</firstterm>.
The syntax of commands is as follows:
<screen>
<replaceable>cmd</replaceable>   ::= <replaceable>exp</replaceable><superscript>10</superscript> -&lt;  <replaceable>exp</replaceable>
       |  <replaceable>exp</replaceable><superscript>10</superscript> -&lt;&lt; <replaceable>exp</replaceable>
       |  <replaceable>cmd</replaceable><superscript>0</superscript>
</screen>
with <replaceable>cmd</replaceable><superscript>0</superscript> up to
<replaceable>cmd</replaceable><superscript>9</superscript> defined using
infix operators as for expressions, and
<screen>
<replaceable>cmd</replaceable><superscript>10</superscript> ::= \ <replaceable>apat</replaceable> ... <replaceable>apat</replaceable> -> <replaceable>cmd</replaceable>
       |  let <replaceable>decls</replaceable> in <replaceable>cmd</replaceable>
       |  if <replaceable>exp</replaceable> then <replaceable>cmd</replaceable> else <replaceable>cmd</replaceable>
       |  case <replaceable>exp</replaceable> of { <replaceable>calts</replaceable> }
       |  do { <replaceable>cstmt</replaceable> ; ... <replaceable>cstmt</replaceable> ; <replaceable>cmd</replaceable> }
       |  <replaceable>fcmd</replaceable>

<replaceable>fcmd</replaceable>  ::= <replaceable>fcmd</replaceable> <replaceable>aexp</replaceable>
       |  ( <replaceable>cmd</replaceable> )
       |  (| <replaceable>aexp</replaceable> <replaceable>cmd</replaceable> ... <replaceable>cmd</replaceable> |)

<replaceable>cstmt</replaceable> ::= let <replaceable>decls</replaceable>
       |  <replaceable>pat</replaceable> &lt;- <replaceable>cmd</replaceable>
       |  rec { <replaceable>cstmt</replaceable> ; ... <replaceable>cstmt</replaceable> [;] }
       |  <replaceable>cmd</replaceable>
</screen>
where <replaceable>calts</replaceable> are like <replaceable>alts</replaceable>
except that the bodies are commands instead of expressions.
</para>

<para>
Commands produce values, but (like monadic computations)
may yield more than one value,
or none, and may do other things as well.
For the most part, familiarity with monadic notation is a good guide to
using commands.
However the values of expressions, even monadic ones,
are determined by the values of the variables they contain;
this is not necessarily the case for commands.
</para>

<para>
A simple example of the new notation is the expression
<screen>
proc x -> f -&lt; x+1
</screen>
We call this a <firstterm>procedure</firstterm> or
<firstterm>arrow abstraction</firstterm>.
As with a lambda expression, the variable <literal>x</literal>
is a new variable bound within the <literal>proc</literal>-expression.
It refers to the input to the arrow.
In the above example, <literal>-&lt;</literal> is not an identifier but an
new reserved symbol used for building commands from an expression of arrow
type and an expression to be fed as input to that arrow.
(The weird look will make more sense later.)
It may be read as analogue of application for arrows.
The above example is equivalent to the Haskell expression
<screen>
arr (\ x -> x+1) >>> f
</screen>
That would make no sense if the expression to the left of
<literal>-&lt;</literal> involves the bound variable <literal>x</literal>.
More generally, the expression to the left of <literal>-&lt;</literal>
may not involve any <firstterm>local variable</firstterm>,
i.e. a variable bound in the current arrow abstraction.
For such a situation there is a variant <literal>-&lt;&lt;</literal>, as in
<screen>
proc x -> f x -&lt;&lt; x+1
</screen>
which is equivalent to
<screen>
arr (\ x -> (f x, x+1)) >>> app
</screen>
so in this case the arrow must belong to the <literal>ArrowApply</literal>
class.
Such an arrow is equivalent to a monad, so if you're using this form
you may find a monadic formulation more convenient.
</para>

<sect2>
<title>do-notation for commands</title>

<para>
Another form of command is a form of <literal>do</literal>-notation.
For example, you can write
<screen>
proc x -> do
        y &lt;- f -&lt; x+1
        g -&lt; 2*y
        let z = x+y
        t &lt;- h -&lt; x*z
        returnA -&lt; t+z
</screen>
You can read this much like ordinary <literal>do</literal>-notation,
but with commands in place of monadic expressions.
The first line sends the value of <literal>x+1</literal> as an input to
the arrow <literal>f</literal>, and matches its output against
<literal>y</literal>.
In the next line, the output is discarded.
The arrow <function>returnA</function> is defined in the
<ulink url="&libraryBaseLocation;/Control-Arrow.html"><literal>Control.Arrow</literal></ulink>
module as <literal>arr id</literal>.
The above example is treated as an abbreviation for
<screen>
arr (\ x -> (x, x)) >>>
        first (arr (\ x -> x+1) >>> f) >>>
        arr (\ (y, x) -> (y, (x, y))) >>>
        first (arr (\ y -> 2*y) >>> g) >>>
        arr snd >>>
        arr (\ (x, y) -> let z = x+y in ((x, z), z)) >>>
        first (arr (\ (x, z) -> x*z) >>> h) >>>
        arr (\ (t, z) -> t+z) >>>
        returnA
</screen>
Note that variables not used later in the composition are projected out.
After simplification using rewrite rules (see <xref linkend="rewrite-rules"/>)
defined in the
<ulink url="&libraryBaseLocation;/Control-Arrow.html"><literal>Control.Arrow</literal></ulink>
module, this reduces to
<screen>
arr (\ x -> (x+1, x)) >>>
        first f >>>
        arr (\ (y, x) -> (2*y, (x, y))) >>>
        first g >>>
        arr (\ (_, (x, y)) -> let z = x+y in (x*z, z)) >>>
        first h >>>
        arr (\ (t, z) -> t+z)
</screen>
which is what you might have written by hand.
With arrow notation, GHC keeps track of all those tuples of variables for you.
</para>

<para>
Note that although the above translation suggests that
<literal>let</literal>-bound variables like <literal>z</literal> must be
monomorphic, the actual translation produces Core,
so polymorphic variables are allowed.
</para>

<para>
It's also possible to have mutually recursive bindings,
using the new <literal>rec</literal> keyword, as in the following example:
<programlisting>
counter :: ArrowCircuit a => a Bool Int
counter = proc reset -> do
        rec     output &lt;- returnA -&lt; if reset then 0 else next
                next &lt;- delay 0 -&lt; output+1
        returnA -&lt; output
</programlisting>
The translation of such forms uses the <function>loop</function> combinator,
so the arrow concerned must belong to the <literal>ArrowLoop</literal> class.
</para>

</sect2>

<sect2>
<title>Conditional commands</title>

<para>
In the previous example, we used a conditional expression to construct the
input for an arrow.
Sometimes we want to conditionally execute different commands, as in
<screen>
proc (x,y) ->
        if f x y
        then g -&lt; x+1
        else h -&lt; y+2
</screen>
which is translated to
<screen>
arr (\ (x,y) -> if f x y then Left x else Right y) >>>
        (arr (\x -> x+1) >>> f) ||| (arr (\y -> y+2) >>> g)
</screen>
Since the translation uses <function>|||</function>,
the arrow concerned must belong to the <literal>ArrowChoice</literal> class.
</para>

<para>
There are also <literal>case</literal> commands, like
<screen>
case input of
    [] -> f -&lt; ()
    [x] -> g -&lt; x+1
    x1:x2:xs -> do
        y &lt;- h -&lt; (x1, x2)
        ys &lt;- k -&lt; xs
        returnA -&lt; y:ys
</screen>
The syntax is the same as for <literal>case</literal> expressions,
except that the bodies of the alternatives are commands rather than expressions.
The translation is similar to that of <literal>if</literal> commands.
</para>

</sect2>

<sect2>
<title>Defining your own control structures</title>

<para>
As we're seen, arrow notation provides constructs,
modelled on those for expressions,
for sequencing, value recursion and conditionals.
But suitable combinators,
which you can define in ordinary Haskell,
may also be used to build new commands out of existing ones.
The basic idea is that a command defines an arrow from environments to values.
These environments assign values to the free local variables of the command.
Thus combinators that produce arrows from arrows
may also be used to build commands from commands.
For example, the <literal>ArrowPlus</literal> class includes a combinator
<programlisting>
ArrowPlus a => (&lt;+>) :: a e c -> a e c -> a e c
</programlisting>
so we can use it to build commands:
<programlisting>
expr' = proc x -> do
                returnA -&lt; x
        &lt;+> do
                symbol Plus -&lt; ()
                y &lt;- term -&lt; ()
                expr' -&lt; x + y
        &lt;+> do
                symbol Minus -&lt; ()
                y &lt;- term -&lt; ()
                expr' -&lt; x - y
</programlisting>
(The <literal>do</literal> on the first line is needed to prevent the first
<literal>&lt;+> ...</literal> from being interpreted as part of the
expression on the previous line.)
This is equivalent to
<programlisting>
expr' = (proc x -> returnA -&lt; x)
        &lt;+> (proc x -> do
                symbol Plus -&lt; ()
                y &lt;- term -&lt; ()
                expr' -&lt; x + y)
        &lt;+> (proc x -> do
                symbol Minus -&lt; ()
                y &lt;- term -&lt; ()
                expr' -&lt; x - y)
</programlisting>
It is essential that this operator be polymorphic in <literal>e</literal>
(representing the environment input to the command
and thence to its subcommands)
and satisfy the corresponding naturality property
<screen>
arr k >>> (f &lt;+> g) = (arr k >>> f) &lt;+> (arr k >>> g)
</screen>
at least for strict <literal>k</literal>.
(This should be automatic if you're not using <function>seq</function>.)
This ensures that environments seen by the subcommands are environments
of the whole command,
and also allows the translation to safely trim these environments.
The operator must also not use any variable defined within the current
arrow abstraction.
</para>

<para>
We could define our own operator
<programlisting>
untilA :: ArrowChoice a => a e () -> a e Bool -> a e ()
untilA body cond = proc x ->
        b &lt;- cond -&lt; x
        if b then returnA -&lt; ()
        else do
                body -&lt; x
                untilA body cond -&lt; x
</programlisting>
and use it in the same way.
Of course this infix syntax only makes sense for binary operators;
there is also a more general syntax involving special brackets:
<screen>
proc x -> do
        y &lt;- f -&lt; x+1
        (|untilA (increment -&lt; x+y) (within 0.5 -&lt; x)|)
</screen>
</para>

</sect2>

<sect2>
<title>Primitive constructs</title>

<para>
Some operators will need to pass additional inputs to their subcommands.
For example, in an arrow type supporting exceptions,
the operator that attaches an exception handler will wish to pass the
exception that occurred to the handler.
Such an operator might have a type
<screen>
handleA :: ... => a e c -> a (e,Ex) c -> a e c
</screen>
where <literal>Ex</literal> is the type of exceptions handled.
You could then use this with arrow notation by writing a command
<screen>
body `handleA` \ ex -> handler
</screen>
so that if an exception is raised in the command <literal>body</literal>,
the variable <literal>ex</literal> is bound to the value of the exception
and the command <literal>handler</literal>,
which typically refers to <literal>ex</literal>, is entered.
Though the syntax here looks like a functional lambda,
we are talking about commands, and something different is going on.
The input to the arrow represented by a command consists of values for
the free local variables in the command, plus a stack of anonymous values.
In all the prior examples, this stack was empty.
In the second argument to <function>handleA</function>,
this stack consists of one value, the value of the exception.
The command form of lambda merely gives this value a name.
</para>

<para>
More concretely,
the values on the stack are paired to the right of the environment.
So operators like <function>handleA</function> that pass
extra inputs to their subcommands can be designed for use with the notation
by pairing the values with the environment in this way.
More precisely, the type of each argument of the operator (and its result)
should have the form
<screen>
a (...(e,t1), ... tn) t
</screen>
where <replaceable>e</replaceable> is a polymorphic variable
(representing the environment)
and <replaceable>ti</replaceable> are the types of the values on the stack,
with <replaceable>t1</replaceable> being the <quote>top</quote>.
The polymorphic variable <replaceable>e</replaceable> must not occur in
<replaceable>a</replaceable>, <replaceable>ti</replaceable> or
<replaceable>t</replaceable>.
However the arrows involved need not be the same.
Here are some more examples of suitable operators:
<screen>
bracketA :: ... => a e b -> a (e,b) c -> a (e,c) d -> a e d
runReader :: ... => a e c -> a' (e,State) c
runState :: ... => a e c -> a' (e,State) (c,State)
</screen>
We can supply the extra input required by commands built with the last two
by applying them to ordinary expressions, as in
<screen>
proc x -> do
        s &lt;- ...
        (|runReader (do { ... })|) s
</screen>
which adds <literal>s</literal> to the stack of inputs to the command
built using <function>runReader</function>.
</para>

<para>
The command versions of lambda abstraction and application are analogous to
the expression versions.
In particular, the beta and eta rules describe equivalences of commands.
These three features (operators, lambda abstraction and application)
are the core of the notation; everything else can be built using them,
though the results would be somewhat clumsy.
For example, we could simulate <literal>do</literal>-notation by defining
<programlisting>
bind :: Arrow a => a e b -> a (e,b) c -> a e c
u `bind` f = returnA &amp;&amp;&amp; u >>> f

bind_ :: Arrow a => a e b -> a e c -> a e c
u `bind_` f = u `bind` (arr fst >>> f)
</programlisting>
We could simulate <literal>if</literal> by defining
<programlisting>
cond :: ArrowChoice a => a e b -> a e b -> a (e,Bool) b
cond f g = arr (\ (e,b) -> if b then Left e else Right e) >>> f ||| g
</programlisting>
</para>

</sect2>

<sect2>
<title>Differences with the paper</title>

<itemizedlist>

<listitem>
<para>Instead of a single form of arrow application (arrow tail) with two
translations, the implementation provides two forms
<quote><literal>-&lt;</literal></quote> (first-order)
and <quote><literal>-&lt;&lt;</literal></quote> (higher-order).
</para>
</listitem>

<listitem>
<para>User-defined operators are flagged with banana brackets instead of
a new <literal>form</literal> keyword.
</para>
</listitem>

</itemizedlist>

</sect2>

<sect2>
<title>Portability</title>

<para>
Although only GHC implements arrow notation directly,
there is also a preprocessor
(available from the
<ulink url="http://www.haskell.org/arrows/">arrows web page</ulink>)
that translates arrow notation into Haskell 98
for use with other Haskell systems.
You would still want to check arrow programs with GHC;
tracing type errors in the preprocessor output is not easy.
Modules intended for both GHC and the preprocessor must observe some
additional restrictions:
<itemizedlist>

<listitem>
<para>
The module must import
<ulink url="&libraryBaseLocation;/Control-Arrow.html"><literal>Control.Arrow</literal></ulink>.
</para>
</listitem>

<listitem>
<para>
The preprocessor cannot cope with other Haskell extensions.
These would have to go in separate modules.
</para>
</listitem>

<listitem>
<para>
Because the preprocessor targets Haskell (rather than Core),
<literal>let</literal>-bound variables are monomorphic.
</para>
</listitem>

</itemizedlist>
</para>

</sect2>

</sect1>

<!-- ==================== BANG PATTERNS =================  -->

<sect1 id="bang-patterns">
<title>Bang patterns
<indexterm><primary>Bang patterns</primary></indexterm>
</title>
<para>GHC supports an extension of pattern matching called <emphasis>bang
patterns</emphasis>, written <literal>!<replaceable>pat</replaceable></literal>.
Bang patterns are under consideration for Haskell Prime.
The <ulink
url="http://hackage.haskell.org/trac/haskell-prime/wiki/BangPatterns">Haskell
prime feature description</ulink> contains more discussion and examples
than the material below.
</para>
<para>
The key change is the addition of a new rule to the
<ulink url="http://haskell.org/onlinereport/exps.html#sect3.17.2">semantics of pattern matching in the Haskell 98 report</ulink>.
Add new bullet 10, saying: Matching the pattern <literal>!</literal><replaceable>pat</replaceable>
against a value <replaceable>v</replaceable> behaves as follows:
<itemizedlist>
<listitem><para>if <replaceable>v</replaceable> is bottom, the match diverges</para></listitem>
<listitem><para>otherwise, <replaceable>pat</replaceable> is matched against <replaceable>v</replaceable>  </para></listitem>
</itemizedlist>
</para>
<para>
Bang patterns are enabled by the flag <option>-XBangPatterns</option>.
</para>

<sect2 id="bang-patterns-informal">
<title>Informal description of bang patterns
</title>
<para>
The main idea is to add a single new production to the syntax of patterns:
<programlisting>
  pat ::= !pat
</programlisting>
Matching an expression <literal>e</literal> against a pattern <literal>!p</literal> is done by first
evaluating <literal>e</literal> (to WHNF) and then matching the result against <literal>p</literal>.
Example:
<programlisting>
f1 !x = True
</programlisting>
This definition makes <literal>f1</literal> is strict in <literal>x</literal>,
whereas without the bang it would be lazy.
Bang patterns can be nested of course:
<programlisting>
f2 (!x, y) = [x,y]
</programlisting>
Here, <literal>f2</literal> is strict in <literal>x</literal> but not in
<literal>y</literal>.
A bang only really has an effect if it precedes a variable or wild-card pattern:
<programlisting>
f3 !(x,y) = [x,y]
f4 (x,y)  = [x,y]
</programlisting>
Here, <literal>f3</literal> and <literal>f4</literal> are identical;
putting a bang before a pattern that
forces evaluation anyway does nothing.
</para>
<para>
There is one (apparent) exception to this general rule that a bang only
makes a difference when it precedes a variable or wild-card: a bang at the
top level of a <literal>let</literal> or <literal>where</literal>
binding makes the binding strict, regardless of the pattern.
(We say "apparent" exception because the Right Way to think of it is that the bang
at the top of a binding is not part of the <emphasis>pattern</emphasis>; rather it
is part of the syntax of the <emphasis>binding</emphasis>,
creating a "bang-pattern binding".)
For example:
<programlisting>
let ![x,y] = e in b
</programlisting>
is a bang-pattern binding. Operationally, it behaves just like a case expression:
<programlisting>
case e of [x,y] -> b
</programlisting>
Like a case expression, a bang-pattern binding must be non-recursive, and
is monomorphic.

However, <emphasis>nested</emphasis> bangs in a pattern binding behave uniformly with all other forms of
pattern matching.  For example
<programlisting>
let (!x,[y]) = e in b
</programlisting>
is equivalent to this:
<programlisting>
let { t = case e of (x,[y]) -> x `seq` (x,y)
      x = fst t
      y = snd t }
in b
</programlisting>
The binding is lazy, but when either <literal>x</literal> or <literal>y</literal> is
evaluated by <literal>b</literal> the entire pattern is matched, including forcing the
evaluation of <literal>x</literal>.
</para>
<para>
Bang patterns work in <literal>case</literal> expressions too, of course:
<programlisting>
g5 x = let y = f x in body
g6 x = case f x of { y -&gt; body }
g7 x = case f x of { !y -&gt; body }
</programlisting>
The functions <literal>g5</literal> and <literal>g6</literal> mean exactly the same thing.
But <literal>g7</literal> evaluates <literal>(f x)</literal>, binds <literal>y</literal> to the
result, and then evaluates <literal>body</literal>.
</para>
</sect2>


<sect2 id="bang-patterns-sem">
<title>Syntax and semantics
</title>
<para>

We add a single new production to the syntax of patterns:
<programlisting>
  pat ::= !pat
</programlisting>
There is one problem with syntactic ambiguity.  Consider:
<programlisting>
f !x = 3
</programlisting>
Is this a definition of the infix function "<literal>(!)</literal>",
or of the "<literal>f</literal>" with a bang pattern? GHC resolves this
ambiguity in favour of the latter.  If you want to define
<literal>(!)</literal> with bang-patterns enabled, you have to do so using
prefix notation:
<programlisting>
(!) f x = 3
</programlisting>
The semantics of Haskell pattern matching is described in <ulink
url="http://www.haskell.org/onlinereport/exps.html#sect3.17.2">
Section 3.17.2</ulink> of the Haskell Report.  To this description add
one extra item 10, saying:
<itemizedlist><listitem><para>Matching
the pattern <literal>!pat</literal> against a value <literal>v</literal> behaves as follows:
<itemizedlist><listitem><para>if <literal>v</literal> is bottom, the match diverges</para></listitem>
		<listitem><para>otherwise, <literal>pat</literal> is matched against
		<literal>v</literal></para></listitem>
</itemizedlist>
</para></listitem></itemizedlist>
Similarly, in Figure 4 of  <ulink url="http://www.haskell.org/onlinereport/exps.html#sect3.17.3">
Section 3.17.3</ulink>, add a new case (t):
<programlisting>
case v of { !pat -> e; _ -> e' }
   = v `seq` case v of { pat -> e; _ -> e' }
</programlisting>
</para><para>
That leaves let expressions, whose translation is given in
<ulink url="http://www.haskell.org/onlinereport/exps.html#sect3.12">Section
3.12</ulink>
of the Haskell Report.
In the translation box, first apply
the following transformation:  for each pattern <literal>pi</literal> that is of
form <literal>!qi = ei</literal>, transform it to <literal>(xi,!qi) = ((),ei)</literal>, and replace <literal>e0</literal>
by <literal>(xi `seq` e0)</literal>.  Then, when none of the left-hand-side patterns
have a bang at the top, apply the rules in the existing box.
</para>
<para>The effect of the let rule is to force complete matching of the pattern
<literal>qi</literal> before evaluation of the body is begun.  The bang is
retained in the translated form in case <literal>qi</literal> is a variable,
thus:
<programlisting>
  let !y = f x in b
</programlisting>

</para>
<para>
The let-binding can be recursive.  However, it is much more common for
the let-binding to be non-recursive, in which case the following law holds:
<literal>(let !p = rhs in body)</literal>
     is equivalent to
<literal>(case rhs of !p -> body)</literal>
</para>
<para>
A pattern with a bang at the outermost level is not allowed at the top level of
a module.
</para>
</sect2>
</sect1>

<!-- ==================== ASSERTIONS =================  -->

<sect1 id="assertions">
<title>Assertions
<indexterm><primary>Assertions</primary></indexterm>
</title>

<para>
If you want to make use of assertions in your standard Haskell code, you
could define a function like the following:
</para>

<para>

<programlisting>
assert :: Bool -> a -> a
assert False x = error "assertion failed!"
assert _     x = x
</programlisting>

</para>

<para>
which works, but gives you back a less than useful error message --
an assertion failed, but which and where?
</para>

<para>
One way out is to define an extended <function>assert</function> function which also
takes a descriptive string to include in the error message and
perhaps combine this with the use of a pre-processor which inserts
the source location where <function>assert</function> was used.
</para>

<para>
Ghc offers a helping hand here, doing all of this for you. For every
use of <function>assert</function> in the user's source:
</para>

<para>

<programlisting>
kelvinToC :: Double -> Double
kelvinToC k = assert (k &gt;= 0.0) (k+273.15)
</programlisting>

</para>

<para>
Ghc will rewrite this to also include the source location where the
assertion was made,
</para>

<para>

<programlisting>
assert pred val ==> assertError "Main.hs|15" pred val
</programlisting>

</para>

<para>
The rewrite is only performed by the compiler when it spots
applications of <function>Control.Exception.assert</function>, so you
can still define and use your own versions of
<function>assert</function>, should you so wish. If not, import
<literal>Control.Exception</literal> to make use
<function>assert</function> in your code.
</para>

<para>
GHC ignores assertions when optimisation is turned on with the
      <option>-O</option><indexterm><primary><option>-O</option></primary></indexterm> flag.  That is, expressions of the form
<literal>assert pred e</literal> will be rewritten to
<literal>e</literal>.  You can also disable assertions using the
      <option>-fignore-asserts</option>
      option<indexterm><primary><option>-fignore-asserts</option></primary>
      </indexterm>.</para>

<para>
Assertion failures can be caught, see the documentation for the
<literal>Control.Exception</literal> library for the details.
</para>

</sect1>


<!-- =============================== PRAGMAS ===========================  -->

  <sect1 id="pragmas">
    <title>Pragmas</title>

    <indexterm><primary>pragma</primary></indexterm>

    <para>GHC supports several pragmas, or instructions to the
    compiler placed in the source code.  Pragmas don't normally affect
    the meaning of the program, but they might affect the efficiency
    of the generated code.</para>

    <para>Pragmas all take the form

<literal>{-# <replaceable>word</replaceable> ... #-}</literal>

    where <replaceable>word</replaceable> indicates the type of
    pragma, and is followed optionally by information specific to that
    type of pragma.  Case is ignored in
    <replaceable>word</replaceable>.  The various values for
    <replaceable>word</replaceable> that GHC understands are described
    in the following sections; any pragma encountered with an
    unrecognised <replaceable>word</replaceable> is
    ignored. The layout rule applies in pragmas, so the closing <literal>#-}</literal>
    should start in a column to the right of the opening <literal>{-#</literal>. </para>

    <para>Certain pragmas are <emphasis>file-header pragmas</emphasis>:
      <itemizedlist>
      <listitem><para>
	  A file-header
	  pragma must precede the <literal>module</literal> keyword in the file.
	  </para></listitem>
      <listitem><para>
      There can be as many file-header pragmas as you please, and they can be
      preceded or followed by comments.
	  </para></listitem>
      <listitem><para>
      File-header pragmas are read once only, before
      pre-processing the file (e.g. with cpp).
	  </para></listitem>
      <listitem><para>
         The file-header pragmas are: <literal>{-# LANGUAGE #-}</literal>,
	<literal>{-# OPTIONS_GHC #-}</literal>, and
	<literal>{-# INCLUDE #-}</literal>.
	  </para></listitem>
      </itemizedlist>
      </para>

    <sect2 id="language-pragma">
      <title>LANGUAGE pragma</title>

      <indexterm><primary>LANGUAGE</primary><secondary>pragma</secondary></indexterm>
      <indexterm><primary>pragma</primary><secondary>LANGUAGE</secondary></indexterm>

      <para>The <literal>LANGUAGE</literal> pragma allows language extensions to be enabled
	in a portable way.
	It is the intention that all Haskell compilers support the
	<literal>LANGUAGE</literal> pragma with the same syntax, although not
	all extensions are supported by all compilers, of
	course.  The <literal>LANGUAGE</literal> pragma should be used instead
	of <literal>OPTIONS_GHC</literal>, if possible.</para>

      <para>For example, to enable the FFI and preprocessing with CPP:</para>

<programlisting>{-# LANGUAGE ForeignFunctionInterface, CPP #-}</programlisting>

        <para><literal>LANGUAGE</literal> is a file-header pragma (see <xref linkend="pragmas"/>).</para>

      <para>Every language extension can also be turned into a command-line flag
	by prefixing it with "<literal>-X</literal>"; for example <option>-XForeignFunctionInterface</option>.
	(Similarly, all "<literal>-X</literal>" flags can be written as <literal>LANGUAGE</literal> pragmas.
      </para>

      <para>A list of all supported language extensions can be obtained by invoking
	<literal>ghc --supported-extensions</literal> (see <xref linkend="modes"/>).</para>

      <para>Any extension from the <literal>Extension</literal> type defined in
	<ulink
	  url="&libraryCabalLocation;/Language-Haskell-Extension.html"><literal>Language.Haskell.Extension</literal></ulink>
	may be used.  GHC will report an error if any of the requested extensions are not supported.</para>
    </sect2>


    <sect2 id="options-pragma">
      <title>OPTIONS_GHC pragma</title>
      <indexterm><primary>OPTIONS_GHC</primary>
      </indexterm>
      <indexterm><primary>pragma</primary><secondary>OPTIONS_GHC</secondary>
      </indexterm>

      <para>The <literal>OPTIONS_GHC</literal> pragma is used to specify
      additional options that are given to the compiler when compiling
      this source file.  See <xref linkend="source-file-options"/> for
      details.</para>

      <para>Previous versions of GHC accepted <literal>OPTIONS</literal> rather
	than <literal>OPTIONS_GHC</literal>, but that is now deprecated.</para>
    </sect2>

        <para><literal>OPTIONS_GHC</literal> is a file-header pragma (see <xref linkend="pragmas"/>).</para>

    <sect2 id="include-pragma">
      <title>INCLUDE pragma</title>

      <para>The <literal>INCLUDE</literal> used to be necessary for
        specifying header files to be included when using the FFI and
        compiling via C.  It is no longer required for GHC, but is
        accepted (and ignored) for compatibility with other
        compilers.</para>
    </sect2>

    <sect2 id="warning-deprecated-pragma">
      <title>WARNING and DEPRECATED pragmas</title>
      <indexterm><primary>WARNING</primary></indexterm>
      <indexterm><primary>DEPRECATED</primary></indexterm>

      <para>The WARNING pragma allows you to attach an arbitrary warning
      to a particular function, class, or type.
      A DEPRECATED pragma lets you specify that
      a particular function, class, or type is deprecated.
      There are two ways of using these pragmas.

      <itemizedlist>
	<listitem>
	  <para>You can work on an entire module thus:</para>
<programlisting>
   module Wibble {-# DEPRECATED "Use Wobble instead" #-} where
     ...
</programlisting>
      <para>Or:</para>
<programlisting>
   module Wibble {-# WARNING "This is an unstable interface." #-} where
     ...
</programlisting>
	  <para>When you compile any module that import
          <literal>Wibble</literal>, GHC will print the specified
          message.</para>
	</listitem>

	<listitem>
	  <para>You can attach a warning to a function, class, type, or data constructor, with the
	  following top-level declarations:</para>
<programlisting>
   {-# DEPRECATED f, C, T "Don't use these" #-}
   {-# WARNING unsafePerformIO "This is unsafe; I hope you know what you're doing" #-}
</programlisting>
	  <para>When you compile any module that imports and uses any
          of the specified entities, GHC will print the specified
          message.</para>
	  <para> You can only attach to entities declared at top level in the module
	  being compiled, and you can only use unqualified names in the list of
	  entities. A capitalised name, such as <literal>T</literal>
	  refers to <emphasis>either</emphasis> the type constructor <literal>T</literal>
	  <emphasis>or</emphasis> the data constructor <literal>T</literal>, or both if
	  both are in scope.  If both are in scope, there is currently no way to
      specify one without the other (c.f. fixities
      <xref linkend="infix-tycons"/>).</para>
	</listitem>
      </itemizedlist>
      Warnings and deprecations are not reported for
      (a) uses within the defining module, and
      (b) uses in an export list.
      The latter reduces spurious complaints within a library
      in which one module gathers together and re-exports
      the exports of several others.
      </para>
      <para>You can suppress the warnings with the flag
      <option>-fno-warn-warnings-deprecations</option>.</para>
    </sect2>

    <sect2 id="inline-noinline-pragma">
      <title>INLINE and NOINLINE pragmas</title>

      <para>These pragmas control the inlining of function
      definitions.</para>

      <sect3 id="inline-pragma">
	<title>INLINE pragma</title>
	<indexterm><primary>INLINE</primary></indexterm>

	<para>GHC (with <option>-O</option>, as always) tries to
        inline (or &ldquo;unfold&rdquo;) functions/values that are
        &ldquo;small enough,&rdquo; thus avoiding the call overhead
        and possibly exposing other more-wonderful optimisations.
        Normally, if GHC decides a function is &ldquo;too
        expensive&rdquo; to inline, it will not do so, nor will it
        export that unfolding for other modules to use.</para>

        <para>The sledgehammer you can bring to bear is the
        <literal>INLINE</literal><indexterm><primary>INLINE
        pragma</primary></indexterm> pragma, used thusly:</para>

<programlisting>
key_function :: Int -> String -> (Bool, Double)
{-# INLINE key_function #-}
</programlisting>

        <para>The major effect of an <literal>INLINE</literal> pragma
        is to declare a function's &ldquo;cost&rdquo; to be very low.
        The normal unfolding machinery will then be very keen to
        inline it.  However, an <literal>INLINE</literal> pragma for a
	function "<literal>f</literal>" has a number of other effects:
<itemizedlist>
<listitem><para>
While GHC is keen to inline the function, it does not do so
blindly.  For example, if you write
<programlisting>
map key_function xs
</programlisting>
there really isn't any point in inlining <literal>key_function</literal> to get
<programlisting>
map (\x -> <replaceable>body</replaceable>) xs
</programlisting>
In general, GHC only inlines the function if there is some reason (no matter
how slight) to suppose that it is useful to do so.
</para></listitem>

<listitem><para>
Moreover, GHC will only inline the function if it is <emphasis>fully applied</emphasis>,
where "fully applied"
means applied to as many arguments as appear (syntactically)
on the LHS of the function
definition.  For example:
<programlisting>
comp1 :: (b -> c) -> (a -> b) -> a -> c
{-# INLINE comp1 #-}
comp1 f g = \x -> f (g x)

comp2 :: (b -> c) -> (a -> b) -> a -> c
{-# INLINE comp2 #-}
comp2 f g x = f (g x)
</programlisting>
The two functions <literal>comp1</literal> and <literal>comp2</literal> have the
same semantics, but <literal>comp1</literal> will be inlined when applied
to <emphasis>two</emphasis> arguments, while <literal>comp2</literal> requires
<emphasis>three</emphasis>.  This might make a big difference if you say
<programlisting>
map (not `comp1` not) xs
</programlisting>
which will optimise better than the corresponding use of `comp2`.
</para></listitem>

<listitem><para>
It is useful for GHC to optimise the definition of an
INLINE function <literal>f</literal> just like any other non-INLINE function,
in case the non-inlined version of <literal>f</literal> is
ultimately called.  But we don't want to inline
the <emphasis>optimised</emphasis> version
of <literal>f</literal>;
a major reason for INLINE pragmas is to expose functions
in <literal>f</literal>'s RHS that have
rewrite rules, and it's no good if those functions have been optimised
away.
</para>
<para>
So <emphasis>GHC guarantees to inline precisely the code that you wrote</emphasis>, no more
and no less.  It does this by capturing a copy of the definition of the function to use
for inlining (we call this the "inline-RHS"), which it leaves untouched,
while optimising the ordinarily RHS as usual.  For externally-visible functions
the inline-RHS (not the optimised RHS) is recorded in the interface file.
</para></listitem>
<listitem><para>
An INLINE function is not worker/wrappered by strictness analysis.
It's going to be inlined wholesale instead.
</para></listitem>
</itemizedlist>
</para>
<para>GHC ensures that inlining cannot go on forever: every mutually-recursive
group is cut by one or more <emphasis>loop breakers</emphasis> that is never inlined
(see <ulink url="http://research.microsoft.com/%7Esimonpj/Papers/inlining/index.htm">
Secrets of the GHC inliner, JFP 12(4) July 2002</ulink>).
GHC tries not to select a function with an INLINE pragma as a loop breaker, but
when there is no choice even an INLINE function can be selected, in which case
the INLINE pragma is ignored.
For example, for a self-recursive function, the loop breaker can only be the function
itself, so an INLINE pragma is always ignored.</para>

	<para>Syntactically, an <literal>INLINE</literal> pragma for a
        function can be put anywhere its type signature could be
        put.</para>

	<para><literal>INLINE</literal> pragmas are a particularly
        good idea for the
        <literal>then</literal>/<literal>return</literal> (or
        <literal>bind</literal>/<literal>unit</literal>) functions in
        a monad.  For example, in GHC's own
        <literal>UniqueSupply</literal> monad code, we have:</para>

<programlisting>
{-# INLINE thenUs #-}
{-# INLINE returnUs #-}
</programlisting>

	<para>See also the <literal>NOINLINE</literal> (<xref linkend="noinline-pragma"/>)
        and <literal>INLINABLE</literal> (<xref linkend="inlinable-pragma"/>)
        pragmas.</para>

	<para>Note: the HBC compiler doesn't like <literal>INLINE</literal> pragmas,
	  so if you want your code to be HBC-compatible you'll have to surround
	  the pragma with C pre-processor directives
	  <literal>#ifdef __GLASGOW_HASKELL__</literal>...<literal>#endif</literal>.</para>

      </sect3>

      <sect3 id="inlinable-pragma">
	<title>INLINABLE pragma</title>

<para>An <literal>{-# INLINABLE f #-}</literal> pragma on a
function <literal>f</literal> has the following behaviour:
<itemizedlist>
<listitem><para>
While <literal>INLINE</literal> says "please inline me", the <literal>INLINABLE</literal>
says "feel free to inline me; use your
discretion".  In other words the choice is left to GHC, which uses the same
rules as for pragma-free functions.  Unlike <literal>INLINE</literal>, that decision is made at
the <emphasis>call site</emphasis>, and
will therefore be affected by the inlining threshold, optimisation level etc.
</para></listitem>
<listitem><para>
Like <literal>INLINE</literal>, the <literal>INLINABLE</literal> pragma retains a
copy of the original RHS for
inlining purposes, and persists it in the interface file, regardless of
the size of the RHS.
</para></listitem>

<listitem><para>
One way to use <literal>INLINABLE</literal> is in conjunction with
the special function <literal>inline</literal> (<xref linkend="special-ids"/>).
The call <literal>inline f</literal> tries very hard to inline <literal>f</literal>.
To make sure that <literal>f</literal> can be inlined,
it is a good idea to mark the definition
of <literal>f</literal> as <literal>INLINABLE</literal>,
so that GHC guarantees to expose an unfolding regardless of how big it is.
Moreover, by annotating <literal>f</literal> as <literal>INLINABLE</literal>,
you ensure that <literal>f</literal>'s original RHS is inlined, rather than
whatever random optimised version of <literal>f</literal> GHC's optimiser
has produced.
</para></listitem>

<listitem><para>
The <literal>INLINABLE</literal> pragma also works with <literal>SPECIALISE</literal>:
if you mark function <literal>f</literal> as <literal>INLINABLE</literal>, then
you can subsequently <literal>SPECIALISE</literal> in another module
(see <xref linkend="specialize-pragma"/>).</para></listitem>

<listitem><para>
Unlike <literal>INLINE</literal>, it is OK to use
an <literal>INLINABLE</literal> pragma on a recursive function.
The principal reason do to so to allow later use of <literal>SPECIALISE</literal>
</para></listitem>
</itemizedlist>
</para>

      </sect3>

      <sect3 id="noinline-pragma">
	<title>NOINLINE pragma</title>

	<indexterm><primary>NOINLINE</primary></indexterm>
	<indexterm><primary>NOTINLINE</primary></indexterm>

	<para>The <literal>NOINLINE</literal> pragma does exactly what
        you'd expect: it stops the named function from being inlined
        by the compiler.  You shouldn't ever need to do this, unless
        you're very cautious about code size.</para>

	<para><literal>NOTINLINE</literal> is a synonym for
        <literal>NOINLINE</literal> (<literal>NOINLINE</literal> is
        specified by Haskell 98 as the standard way to disable
        inlining, so it should be used if you want your code to be
        portable).</para>
      </sect3>

      <sect3 id="conlike-pragma">
	<title>CONLIKE modifier</title>
	<indexterm><primary>CONLIKE</primary></indexterm>
        <para>An INLINE or NOINLINE pragma may have a CONLIKE modifier,
        which affects matching in RULEs (only).  See <xref linkend="conlike"/>.
        </para>
      </sect3>

      <sect3 id="phase-control">
	<title>Phase control</title>

	<para> Sometimes you want to control exactly when in GHC's
        pipeline the INLINE pragma is switched on.  Inlining happens
        only during runs of the <emphasis>simplifier</emphasis>.  Each
        run of the simplifier has a different <emphasis>phase
        number</emphasis>; the phase number decreases towards zero.
        If you use <option>-dverbose-core2core</option> you'll see the
        sequence of phase numbers for successive runs of the
        simplifier.  In an INLINE pragma you can optionally specify a
        phase number, thus:
	<itemizedlist>
	  <listitem>
	    <para>"<literal>INLINE[k] f</literal>" means: do not inline
	    <literal>f</literal>
	      until phase <literal>k</literal>, but from phase
	      <literal>k</literal> onwards be very keen to inline it.
            </para></listitem>
	  <listitem>
	    <para>"<literal>INLINE[~k] f</literal>" means: be very keen to inline
	    <literal>f</literal>
	      until phase <literal>k</literal>, but from phase
	      <literal>k</literal> onwards do not inline it.
            </para></listitem>
	  <listitem>
	    <para>"<literal>NOINLINE[k] f</literal>" means: do not inline
	    <literal>f</literal>
	      until phase <literal>k</literal>, but from phase
	      <literal>k</literal> onwards be willing to inline it (as if
	      there was no pragma).
            </para></listitem>
	    <listitem>
	    <para>"<literal>NOINLINE[~k] f</literal>" means: be willing to inline
	    <literal>f</literal>
	      until phase <literal>k</literal>, but from phase
	      <literal>k</literal> onwards do not inline it.
            </para></listitem>
	</itemizedlist>
The same information is summarised here:
<programlisting>
                           -- Before phase 2     Phase 2 and later
  {-# INLINE   [2]  f #-}  --      No                 Yes
  {-# INLINE   [~2] f #-}  --      Yes                No
  {-# NOINLINE [2]  f #-}  --      No                 Maybe
  {-# NOINLINE [~2] f #-}  --      Maybe              No

  {-# INLINE   f #-}       --      Yes                Yes
  {-# NOINLINE f #-}       --      No                 No
</programlisting>
By "Maybe" we mean that the usual heuristic inlining rules apply (if the
function body is small, or it is applied to interesting-looking arguments etc).
Another way to understand the semantics is this:
<itemizedlist>
<listitem><para>For both INLINE and NOINLINE, the phase number says
when inlining is allowed at all.</para></listitem>
<listitem><para>The INLINE pragma has the additional effect of making the
function body look small, so that when inlining is allowed it is very likely to
happen.
</para></listitem>
</itemizedlist>
</para>
<para>The same phase-numbering control is available for RULES
	(<xref linkend="rewrite-rules"/>).</para>
      </sect3>
    </sect2>


    <sect2 id="line-pragma">
      <title>LINE pragma</title>

      <indexterm><primary>LINE</primary><secondary>pragma</secondary></indexterm>
      <indexterm><primary>pragma</primary><secondary>LINE</secondary></indexterm>
      <para>This pragma is similar to C's <literal>&num;line</literal>
      pragma, and is mainly for use in automatically generated Haskell
      code.  It lets you specify the line number and filename of the
      original code; for example</para>

<programlisting>{-# LINE 42 "Foo.vhs" #-}</programlisting>

      <para>if you'd generated the current file from something called
      <filename>Foo.vhs</filename> and this line corresponds to line
      42 in the original.  GHC will adjust its error messages to refer
      to the line/file named in the <literal>LINE</literal>
      pragma.</para>
    </sect2>

    <sect2 id="rules">
      <title>RULES pragma</title>

      <para>The RULES pragma lets you specify rewrite rules.  It is
      described in <xref linkend="rewrite-rules"/>.</para>
    </sect2>

    <sect2 id="specialize-pragma">
      <title>SPECIALIZE pragma</title>

      <indexterm><primary>SPECIALIZE pragma</primary></indexterm>
      <indexterm><primary>pragma, SPECIALIZE</primary></indexterm>
      <indexterm><primary>overloading, death to</primary></indexterm>

      <para>(UK spelling also accepted.)  For key overloaded
      functions, you can create extra versions (NB: more code space)
      specialised to particular types.  Thus, if you have an
      overloaded function:</para>

<programlisting>
  hammeredLookup :: Ord key => [(key, value)] -> key -> value
</programlisting>

      <para>If it is heavily used on lists with
      <literal>Widget</literal> keys, you could specialise it as
      follows:</para>

<programlisting>
  {-# SPECIALIZE hammeredLookup :: [(Widget, value)] -> Widget -> value #-}
</programlisting>

<itemizedlist>
<listitem>
      <para>A <literal>SPECIALIZE</literal> pragma for a function can
      be put anywhere its type signature could be put.  Moreover, you
      can also <literal>SPECIALIZE</literal> an <emphasis>imported</emphasis>
		function provided it was given an <literal>INLINABLE</literal> pragma at
		its definition site (<xref linkend="inlinable-pragma"/>).</para>
</listitem>

<listitem>
      <para>A <literal>SPECIALIZE</literal> has the effect of generating
      (a) a specialised version of the function and (b) a rewrite rule
      (see <xref linkend="rewrite-rules"/>) that rewrites a call to
      the un-specialised function into a call to the specialised one.
      Moreover, given a <literal>SPECIALIZE</literal> pragma for a
      function <literal>f</literal>, GHC will automatically create
      specialisations for any type-class-overloaded functions called
      by <literal>f</literal>, if they are in the same module as
      the <literal>SPECIALIZE</literal> pragma, or if they are
      <literal>INLINABLE</literal>; and so on, transitively.</para>
</listitem>

<listitem>
   <para>You can add phase control (<xref linkend="phase-control"/>)
   to the RULE generated by a <literal>SPECIALIZE</literal> pragma,
   just as you can if you write a RULE directly. For example:
<programlisting>
  {-# SPECIALIZE [0] hammeredLookup :: [(Widget, value)] -> Widget -> value #-}
</programlisting>
   generates a specialisation rule that only fires in Phase 0 (the final phase).
   If you do not specify any phase control in the <literal>SPECIALIZE</literal> pragma,
   the phase control is inherited from the inline pragma (if any) of the function.
   For example:
<programlisting>
  foo :: Num a => a -> a
  foo = ...blah...
  {-# NOINLINE [0] foo #-}
  {-# SPECIALIZE foo :: Int -> Int #-}
</programlisting>
  The <literal>NOINLINE</literal> pragma tells GHC not to inline <literal>foo</literal>
  until Phase 0; and this property is inherited by the specialisation RULE, which will
  therefore only fire in Phase 0.</para>
  <para>The main reason for using phase control on specialisations is so that you can
  write optimisation RULES that fire early in the compilation pipeline, and only
   <emphasis>then</emphasis> specialise the calls to the function. If specialisation is
   done too early, the optimisation rules might fail to fire.
  </para>
</listitem>

<listitem>
      <para>The type in a SPECIALIZE pragma can be any type that is less
	polymorphic than the type of the original function.  In concrete terms,
	if the original function is <literal>f</literal> then the pragma
<programlisting>
  {-# SPECIALIZE f :: &lt;type&gt; #-}
</programlisting>
      is valid if and only if the definition
<programlisting>
  f_spec :: &lt;type&gt;
  f_spec = f
</programlisting>
      is valid.  Here are some examples (where we only give the type signature
      for the original function, not its code):
<programlisting>
  f :: Eq a => a -> b -> b
  {-# SPECIALISE f :: Int -> b -> b #-}

  g :: (Eq a, Ix b) => a -> b -> b
  {-# SPECIALISE g :: (Eq a) => a -> Int -> Int #-}

  h :: Eq a => a -> a -> a
  {-# SPECIALISE h :: (Eq a) => [a] -> [a] -> [a] #-}
</programlisting>
The last of these examples will generate a
RULE with a somewhat-complex left-hand side (try it yourself), so it might not fire very
well.  If you use this kind of specialisation, let us know how well it works.
</para>
</listitem>
</itemizedlist>

    <sect3 id="specialize-inline">
      <title>SPECIALIZE INLINE</title>

<para>A <literal>SPECIALIZE</literal> pragma can optionally be followed with a
<literal>INLINE</literal> or <literal>NOINLINE</literal> pragma, optionally
followed by a phase, as described in <xref linkend="inline-noinline-pragma"/>.
The <literal>INLINE</literal> pragma affects the specialised version of the
function (only), and applies even if the function is recursive.  The motivating
example is this:
<programlisting>
-- A GADT for arrays with type-indexed representation
data Arr e where
  ArrInt :: !Int -> ByteArray# -> Arr Int
  ArrPair :: !Int -> Arr e1 -> Arr e2 -> Arr (e1, e2)

(!:) :: Arr e -> Int -> e
{-# SPECIALISE INLINE (!:) :: Arr Int -> Int -> Int #-}
{-# SPECIALISE INLINE (!:) :: Arr (a, b) -> Int -> (a, b) #-}
(ArrInt _ ba)     !: (I# i) = I# (indexIntArray# ba i)
(ArrPair _ a1 a2) !: i      = (a1 !: i, a2 !: i)
</programlisting>
Here, <literal>(!:)</literal> is a recursive function that indexes arrays
of type <literal>Arr e</literal>.  Consider a call to  <literal>(!:)</literal>
at type <literal>(Int,Int)</literal>.  The second specialisation will fire, and
the specialised function will be inlined.  It has two calls to
<literal>(!:)</literal>,
both at type <literal>Int</literal>.  Both these calls fire the first
specialisation, whose body is also inlined.  The result is a type-based
unrolling of the indexing function.</para>
<para>You can add explicit phase control (<xref linkend="phase-control"/>)
to <literal>SPECIALISE INLINE</literal> pragma,
just like on an <literal>INLINE</literal> pragma; if you do so, the same phase
is used for the rewrite rule and the INLINE control of the specialised function.</para>

<para>Warning: you can make GHC diverge by using <literal>SPECIALISE INLINE</literal>
on an ordinarily-recursive function.</para>
</sect3>

<sect3><title>SPECIALIZE for imported functions</title>

<para>
Generally, you can only give a <literal>SPECIALIZE</literal> pragma
for a function defined in the same module.
However if a function <literal>f</literal> is given an <literal>INLINABLE</literal>
pragma at its definition site, then it can subsequently be specialised by
importing modules (see <xref linkend="inlinable-pragma"/>).
For example
<programlisting>
module Map( lookup, blah blah ) where
  lookup :: Ord key => [(key,a)] -> key -> Maybe a
  lookup = ...
  {-# INLINABLE lookup #-}

module Client where
  import Map( lookup )

  data T = T1 | T2 deriving( Eq, Ord )
  {-# SPECIALISE lookup :: [(T,a)] -> T -> Maybe a
</programlisting>
Here, <literal>lookup</literal> is declared <literal>INLINABLE</literal>, but
it cannot be specialised for type <literal>T</literal> at its definition site,
because that type does not exist yet.  Instead a client module can define <literal>T</literal>
and then specialise <literal>lookup</literal> at that type.
</para>
<para>
Moreover, every module that imports <literal>Client</literal> (or imports a module
that imports <literal>Client</literal>, transitively) will "see", and make use of,
the specialised version of <literal>lookup</literal>.  You don't need to put
a <literal>SPECIALIZE</literal> pragma in every module.
</para>
<para>
Moreover you often don't even need the <literal>SPECIALIZE</literal> pragma in the
first place. When compiling a module M,
GHC's optimiser (with -O) automatically considers each top-level
overloaded function declared in M, and specialises it
for the different types at which it is called in M.  The optimiser
<emphasis>also</emphasis> considers each <emphasis>imported</emphasis>
<literal>INLINABLE</literal> overloaded function, and specialises it
for the different types at which it is called in M.
So in our example, it would be enough for <literal>lookup</literal> to
be called at type <literal>T</literal>:
<programlisting>
module Client where
  import Map( lookup )

  data T = T1 | T2 deriving( Eq, Ord )

  findT1 :: [(T,a)] -> Maybe a
  findT1 m = lookup m T1   -- A call of lookup at type T
</programlisting>
However, sometimes there are no such calls, in which case the
pragma can be useful.
</para>
</sect3>

<sect3><title>Obsolete SPECIALIZE syntax</title>

      <para>Note: In earlier versions of GHC, it was possible to provide your own
      specialised function for a given type:

<programlisting>
{-# SPECIALIZE hammeredLookup :: [(Int, value)] -> Int -> value = intLookup #-}
</programlisting>

      This feature has been removed, as it is now subsumed by the
      <literal>RULES</literal> pragma (see <xref linkend="rule-spec"/>).</para>
</sect3>

    </sect2>

<sect2 id="specialize-instance-pragma">
<title>SPECIALIZE instance pragma
</title>

<para>
<indexterm><primary>SPECIALIZE pragma</primary></indexterm>
<indexterm><primary>overloading, death to</primary></indexterm>
Same idea, except for instance declarations.  For example:

<programlisting>
instance (Eq a) => Eq (Foo a) where {
   {-# SPECIALIZE instance Eq (Foo [(Int, Bar)]) #-}
   ... usual stuff ...
 }
</programlisting>
The pragma must occur inside the <literal>where</literal> part
of the instance declaration.
</para>
<para>
Compatible with HBC, by the way, except perhaps in the placement
of the pragma.
</para>

</sect2>

    <sect2 id="unpack-pragma">
      <title>UNPACK pragma</title>

      <indexterm><primary>UNPACK</primary></indexterm>

      <para>The <literal>UNPACK</literal> indicates to the compiler
      that it should unpack the contents of a constructor field into
      the constructor itself, removing a level of indirection.  For
      example:</para>

<programlisting>
data T = T {-# UNPACK #-} !Float
           {-# UNPACK #-} !Float
</programlisting>

      <para>will create a constructor <literal>T</literal> containing
      two unboxed floats.  This may not always be an optimisation: if
      the <function>T</function> constructor is scrutinised and the
      floats passed to a non-strict function for example, they will
      have to be reboxed (this is done automatically by the
      compiler).</para>

      <para>Unpacking constructor fields should only be used in
      conjunction with <option>-O</option><footnote>in fact, UNPACK
          has no effect without <option>-O</option>, for technical
          reasons
      (see <ulink url="http://hackage.haskell.org/trac/ghc/ticket/5252">tick
            5252</ulink>)</footnote>, in order to expose
      unfoldings to the compiler so the reboxing can be removed as
      often as possible.  For example:</para>

<programlisting>
f :: T -&#62; Float
f (T f1 f2) = f1 + f2
</programlisting>

      <para>The compiler will avoid reboxing <function>f1</function>
      and <function>f2</function> by inlining <function>+</function>
      on floats, but only when <option>-O</option> is on.</para>

      <para>Any single-constructor data is eligible for unpacking; for
      example</para>

<programlisting>
data T = T {-# UNPACK #-} !(Int,Int)
</programlisting>

      <para>will store the two <literal>Int</literal>s directly in the
      <function>T</function> constructor, by flattening the pair.
      Multi-level unpacking is also supported:

<programlisting>
data T = T {-# UNPACK #-} !S
data S = S {-# UNPACK #-} !Int {-# UNPACK #-} !Int
</programlisting>

      will store two unboxed <literal>Int&num;</literal>s
      directly in the <function>T</function> constructor.  The
      unpacker can see through newtypes, too.</para>

      <para>See also the <option>-funbox-strict-fields</option> flag,
      which essentially has the effect of adding
      <literal>{-#&nbsp;UNPACK&nbsp;#-}</literal> to every strict
      constructor field.</para>
    </sect2>

    <sect2 id="nounpack-pragma">
      <title>NOUNPACK pragma</title>

      <indexterm><primary>NOUNPACK</primary></indexterm>

      <para>The <literal>NOUNPACK</literal> pragma indicates to the compiler
      that it should not unpack the contents of a constructor field.
      Example:
      </para>
<programlisting>
data T = T {-# NOUNPACK #-} !(Int,Int)
</programlisting>
      <para>
        Even with the flags
        <option>-funbox-strict-fields</option> and <option>-O</option>,
        the field of the constructor <function>T</function> is not
        unpacked.
      </para>
    </sect2>

    <sect2 id="source-pragma">
      <title>SOURCE pragma</title>

      <indexterm><primary>SOURCE</primary></indexterm>
     <para>The <literal>{-# SOURCE #-}</literal> pragma is used only in <literal>import</literal> declarations,
     to break a module loop.  It is described in detail in <xref linkend="mutual-recursion"/>.
     </para>
</sect2>

</sect1>

<!--  ======================= REWRITE RULES ======================== -->

<sect1 id="rewrite-rules">
<title>Rewrite rules

<indexterm><primary>RULES pragma</primary></indexterm>
<indexterm><primary>pragma, RULES</primary></indexterm>
<indexterm><primary>rewrite rules</primary></indexterm></title>

<para>
The programmer can specify rewrite rules as part of the source program
(in a pragma).
Here is an example:

<programlisting>
  {-# RULES
  "map/map"    forall f g xs.  map f (map g xs) = map (f.g) xs
    #-}
</programlisting>
</para>
<para>
Use the debug flag <option>-ddump-simpl-stats</option> to see what rules fired.
If you need more information, then <option>-ddump-rule-firings</option> shows you
each individual rule firing and <option>-ddump-rule-rewrites</option> also shows what the code looks like before and after the rewrite.
</para>

<sect2>
<title>Syntax</title>

<para>
From a syntactic point of view:

<itemizedlist>

<listitem>
<para>
 There may be zero or more rules in a <literal>RULES</literal> pragma, separated by semicolons (which
 may be generated by the layout rule).
</para>
</listitem>

<listitem>
<para>
The layout rule applies in a pragma.
Currently no new indentation level
is set, so if you put several rules in single RULES pragma and wish to use layout to separate them,
you must lay out the starting in the same column as the enclosing definitions.
<programlisting>
  {-# RULES
  "map/map"    forall f g xs.  map f (map g xs) = map (f.g) xs
  "map/append" forall f xs ys. map f (xs ++ ys) = map f xs ++ map f ys
    #-}
</programlisting>
Furthermore, the closing <literal>#-}</literal>
should start in a column to the right of the opening <literal>{-#</literal>.
</para>
</listitem>

<listitem>
<para>
 Each rule has a name, enclosed in double quotes.  The name itself has
no significance at all.  It is only used when reporting how many times the rule fired.
</para>
</listitem>

<listitem>
<para>
A rule may optionally have a phase-control number (see <xref linkend="phase-control"/>),
immediately after the name of the rule.  Thus:
<programlisting>
  {-# RULES
        "map/map" [2]  forall f g xs. map f (map g xs) = map (f.g) xs
    #-}
</programlisting>
The "[2]" means that the rule is active in Phase 2 and subsequent phases.  The inverse
notation "[~2]" is also accepted, meaning that the rule is active up to, but not including,
Phase 2.
</para>
</listitem>



<listitem>
<para>
 Each variable mentioned in a rule must either be in scope (e.g. <function>map</function>),
or bound by the <literal>forall</literal> (e.g. <function>f</function>, <function>g</function>, <function>xs</function>).  The variables bound by
the <literal>forall</literal> are called the <emphasis>pattern</emphasis> variables.  They are separated
by spaces, just like in a type <literal>forall</literal>.
</para>
</listitem>
<listitem>

<para>
 A pattern variable may optionally have a type signature.
If the type of the pattern variable is polymorphic, it <emphasis>must</emphasis> have a type signature.
For example, here is the <literal>foldr/build</literal> rule:

<programlisting>
"fold/build"  forall k z (g::forall b. (a->b->b) -> b -> b) .
              foldr k z (build g) = g k z
</programlisting>

Since <function>g</function> has a polymorphic type, it must have a type signature.

</para>
</listitem>
<listitem>

<para>
The left hand side of a rule must consist of a top-level variable applied
to arbitrary expressions.  For example, this is <emphasis>not</emphasis> OK:

<programlisting>
"wrong1"   forall e1 e2.  case True of { True -> e1; False -> e2 } = e1
"wrong2"   forall f.      f True = True
</programlisting>

In <literal>"wrong1"</literal>, the LHS is not an application; in <literal>"wrong2"</literal>, the LHS has a pattern variable
in the head.
</para>
</listitem>
<listitem>

<para>
 A rule does not need to be in the same module as (any of) the
variables it mentions, though of course they need to be in scope.
</para>
</listitem>
<listitem>

<para>
 All rules are implicitly exported from the module, and are therefore
in force in any module that imports the module that defined the rule, directly
or indirectly.  (That is, if A imports B, which imports C, then C's rules are
in force when compiling A.)  The situation is very similar to that for instance
declarations.
</para>
</listitem>

<listitem>

<para>
Inside a RULE "<literal>forall</literal>" is treated as a keyword, regardless of
any other flag settings.  Furthermore, inside a RULE, the language extension
<option>-XScopedTypeVariables</option> is automatically enabled; see
<xref linkend="scoped-type-variables"/>.
</para>
</listitem>
<listitem>

<para>
Like other pragmas, RULE pragmas are always checked for scope errors, and
are typechecked. Typechecking means that the LHS and RHS of a rule are typechecked,
and must have the same type.  However, rules are only <emphasis>enabled</emphasis>
if the <option>-fenable-rewrite-rules</option> flag is
on (see <xref linkend="rule-semantics"/>).
</para>
</listitem>
</itemizedlist>

</para>

</sect2>

<sect2 id="rule-semantics">
<title>Semantics</title>

<para>
From a semantic point of view:

<itemizedlist>
<listitem>
<para>
Rules are enabled (that is, used during optimisation)
by the <option>-fenable-rewrite-rules</option> flag.
This flag is implied by <option>-O</option>, and may be switched
off (as usual) by <option>-fno-enable-rewrite-rules</option>.
(NB: enabling <option>-fenable-rewrite-rules</option> without <option>-O</option>
may not do what you expect, though, because without <option>-O</option> GHC
ignores all optimisation information in interface files;
see <option>-fignore-interface-pragmas</option>, <xref linkend="options-f"/>.)
Note that <option>-fenable-rewrite-rules</option> is an <emphasis>optimisation</emphasis> flag, and
has no effect on parsing or typechecking.
</para>
</listitem>

<listitem>
<para>
 Rules are regarded as left-to-right rewrite rules.
When GHC finds an expression that is a substitution instance of the LHS
of a rule, it replaces the expression by the (appropriately-substituted) RHS.
By "a substitution instance" we mean that the LHS can be made equal to the
expression by substituting for the pattern variables.

</para>
</listitem>
<listitem>

<para>
 GHC makes absolutely no attempt to verify that the LHS and RHS
of a rule have the same meaning.  That is undecidable in general, and
infeasible in most interesting cases.  The responsibility is entirely the programmer's!

</para>
</listitem>
<listitem>

<para>
 GHC makes no attempt to make sure that the rules are confluent or
terminating.  For example:

<programlisting>
  "loop"        forall x y.  f x y = f y x
</programlisting>

This rule will cause the compiler to go into an infinite loop.

</para>
</listitem>
<listitem>

<para>
 If more than one rule matches a call, GHC will choose one arbitrarily to apply.

</para>
</listitem>
<listitem>
<para>
 GHC currently uses a very simple, syntactic, matching algorithm
for matching a rule LHS with an expression.  It seeks a substitution
which makes the LHS and expression syntactically equal modulo alpha
conversion.  The pattern (rule), but not the expression, is eta-expanded if
necessary.  (Eta-expanding the expression can lead to laziness bugs.)
But not beta conversion (that's called higher-order matching).
</para>

<para>
Matching is carried out on GHC's intermediate language, which includes
type abstractions and applications.  So a rule only matches if the
types match too.  See <xref linkend="rule-spec"/> below.
</para>
</listitem>
<listitem>

<para>
 GHC keeps trying to apply the rules as it optimises the program.
For example, consider:

<programlisting>
  let s = map f
      t = map g
  in
  s (t xs)
</programlisting>

The expression <literal>s (t xs)</literal> does not match the rule <literal>"map/map"</literal>, but GHC
will substitute for <varname>s</varname> and <varname>t</varname>, giving an expression which does match.
If <varname>s</varname> or <varname>t</varname> was (a) used more than once, and (b) large or a redex, then it would
not be substituted, and the rule would not fire.

</para>
</listitem>
</itemizedlist>

</para>

</sect2>

<sect2 id="conlike">
<title>How rules interact with INLINE/NOINLINE and CONLIKE pragmas</title>

<para>
Ordinary inlining happens at the same time as rule rewriting, which may lead to unexpected
results.  Consider this (artificial) example
<programlisting>
f x = x
g y = f y
h z = g True

{-# RULES "f" f True = False #-}
</programlisting>
Since <literal>f</literal>'s right-hand side is small, it is inlined into <literal>g</literal>,
to give
<programlisting>
g y = y
</programlisting>
Now <literal>g</literal> is inlined into <literal>h</literal>, but <literal>f</literal>'s RULE has
no chance to fire.
If instead GHC had first inlined <literal>g</literal> into <literal>h</literal> then there
would have been a better chance that <literal>f</literal>'s RULE might fire.
</para>
<para>
The way to get predictable behaviour is to use a NOINLINE
pragma, or an INLINE[<replaceable>phase</replaceable>] pragma, on <literal>f</literal>, to ensure
that it is not inlined until its RULEs have had a chance to fire.
</para>
<para>
GHC is very cautious about duplicating work.  For example, consider
<programlisting>
f k z xs = let xs = build g
           in ...(foldr k z xs)...sum xs...
{-# RULES "foldr/build" forall k z g. foldr k z (build g) = g k z #-}
</programlisting>
Since <literal>xs</literal> is used twice, GHC does not fire the foldr/build rule.  Rightly
so, because it might take a lot of work to compute <literal>xs</literal>, which would be
duplicated if the rule fired.
</para>
<para>
Sometimes, however, this approach is over-cautious, and we <emphasis>do</emphasis> want the
rule to fire, even though doing so would duplicate redex.  There is no way that GHC can work out
when this is a good idea, so we provide the CONLIKE pragma to declare it, thus:
<programlisting>
{-# INLINE[1] CONLIKE f #-}
f x = <replaceable>blah</replaceable>
</programlisting>
CONLIKE is a modifier to an INLINE or NOINLINE pragma.  It specifies that an application
of f to one argument (in general, the number of arguments to the left of the '=' sign)
should be considered cheap enough to duplicate, if such a duplication would make rule
fire.  (The name "CONLIKE" is short for "constructor-like", because constructors certainly
have such a property.)
The CONLIKE pragma is a modifier to INLINE/NOINLINE because it really only makes sense to match
<literal>f</literal> on the LHS of a rule if you are sure that <literal>f</literal> is
not going to be inlined before the rule has a chance to fire.
</para>
</sect2>

<sect2>
<title>List fusion</title>

<para>
The RULES mechanism is used to implement fusion (deforestation) of common list functions.
If a "good consumer" consumes an intermediate list constructed by a "good producer", the
intermediate list should be eliminated entirely.
</para>

<para>
The following are good producers:

<itemizedlist>
<listitem>

<para>
 List comprehensions
</para>
</listitem>
<listitem>

<para>
 Enumerations of <literal>Int</literal>, <literal>Integer</literal> and <literal>Char</literal> (e.g. <literal>['a'..'z']</literal>).
</para>
</listitem>
<listitem>

<para>
 Explicit lists (e.g. <literal>[True, False]</literal>)
</para>
</listitem>
<listitem>

<para>
 The cons constructor (e.g <literal>3:4:[]</literal>)
</para>
</listitem>
<listitem>

<para>
 <function>++</function>
</para>
</listitem>

<listitem>
<para>
 <function>map</function>
</para>
</listitem>

<listitem>
<para>
<function>take</function>, <function>filter</function>
</para>
</listitem>
<listitem>

<para>
 <function>iterate</function>, <function>repeat</function>
</para>
</listitem>
<listitem>

<para>
 <function>zip</function>, <function>zipWith</function>
</para>
</listitem>

</itemizedlist>

</para>

<para>
The following are good consumers:

<itemizedlist>
<listitem>

<para>
 List comprehensions
</para>
</listitem>
<listitem>

<para>
 <function>array</function> (on its second argument)
</para>
</listitem>
<listitem>

<para>
 <function>++</function> (on its first argument)
</para>
</listitem>

<listitem>
<para>
 <function>foldr</function>
</para>
</listitem>

<listitem>
<para>
 <function>map</function>
</para>
</listitem>
<listitem>

<para>
<function>take</function>, <function>filter</function>
</para>
</listitem>
<listitem>

<para>
 <function>concat</function>
</para>
</listitem>
<listitem>

<para>
 <function>unzip</function>, <function>unzip2</function>, <function>unzip3</function>, <function>unzip4</function>
</para>
</listitem>
<listitem>

<para>
 <function>zip</function>, <function>zipWith</function> (but on one argument only; if both are good producers, <function>zip</function>
will fuse with one but not the other)
</para>
</listitem>
<listitem>

<para>
 <function>partition</function>
</para>
</listitem>
<listitem>

<para>
 <function>head</function>
</para>
</listitem>
<listitem>

<para>
 <function>and</function>, <function>or</function>, <function>any</function>, <function>all</function>
</para>
</listitem>
<listitem>

<para>
 <function>sequence&lowbar;</function>
</para>
</listitem>
<listitem>

<para>
 <function>msum</function>
</para>
</listitem>

</itemizedlist>

</para>

 <para>
So, for example, the following should generate no intermediate lists:

<programlisting>
array (1,10) [(i,i*i) | i &#60;- map (+ 1) [0..9]]
</programlisting>

</para>

<para>
This list could readily be extended; if there are Prelude functions that you use
a lot which are not included, please tell us.
</para>

<para>
If you want to write your own good consumers or producers, look at the
Prelude definitions of the above functions to see how to do so.
</para>

</sect2>

<sect2 id="rule-spec">
<title>Specialisation
</title>

<para>
Rewrite rules can be used to get the same effect as a feature
present in earlier versions of GHC.
For example, suppose that:

<programlisting>
genericLookup :: Ord a => Table a b   -> a   -> b
intLookup     ::          Table Int b -> Int -> b
</programlisting>

where <function>intLookup</function> is an implementation of
<function>genericLookup</function> that works very fast for
keys of type <literal>Int</literal>.  You might wish
to tell GHC to use <function>intLookup</function> instead of
<function>genericLookup</function> whenever the latter was called with
type <literal>Table Int b -&gt; Int -&gt; b</literal>.
It used to be possible to write

<programlisting>
{-# SPECIALIZE genericLookup :: Table Int b -> Int -> b = intLookup #-}
</programlisting>

This feature is no longer in GHC, but rewrite rules let you do the same thing:

<programlisting>
{-# RULES "genericLookup/Int" genericLookup = intLookup #-}
</programlisting>

This slightly odd-looking rule instructs GHC to replace
<function>genericLookup</function> by <function>intLookup</function>
<emphasis>whenever the types match</emphasis>.
What is more, this rule does not need to be in the same
file as <function>genericLookup</function>, unlike the
<literal>SPECIALIZE</literal> pragmas which currently do (so that they
have an original definition available to specialise).
</para>

<para>It is <emphasis>Your Responsibility</emphasis> to make sure that
<function>intLookup</function> really behaves as a specialised version
of <function>genericLookup</function>!!!</para>

<para>An example in which using <literal>RULES</literal> for
specialisation will Win Big:

<programlisting>
toDouble :: Real a => a -> Double
toDouble = fromRational . toRational

{-# RULES "toDouble/Int" toDouble = i2d #-}
i2d (I# i) = D# (int2Double# i) -- uses Glasgow prim-op directly
</programlisting>

The <function>i2d</function> function is virtually one machine
instruction; the default conversion&mdash;via an intermediate
<literal>Rational</literal>&mdash;is obscenely expensive by
comparison.
</para>

</sect2>

<sect2 id="controlling-rules">
<title>Controlling what's going on in rewrite rules</title>

<para>

<itemizedlist>
<listitem>

<para>
Use <option>-ddump-rules</option> to see the rules that are defined
<emphasis>in this module</emphasis>.
This includes rules generated by the specialisation pass, but excludes
rules imported from other modules.
</para>
</listitem>

<listitem>
<para>
 Use <option>-ddump-simpl-stats</option> to see what rules are being fired.
If you add <option>-dppr-debug</option> you get a more detailed listing.
</para>
</listitem>

<listitem>
<para>
 Use <option>-ddump-rule-firings</option> or <option>-ddump-rule-rewrites</option>
to see in great detail what rules are being fired.
If you add <option>-dppr-debug</option> you get a still more detailed listing.
</para>
</listitem>

<listitem>
<para>
 The definition of (say) <function>build</function> in <filename>GHC/Base.lhs</filename> looks like this:

<programlisting>
        build   :: forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
        {-# INLINE build #-}
        build g = g (:) []
</programlisting>

Notice the <literal>INLINE</literal>!  That prevents <literal>(:)</literal> from being inlined when compiling
<literal>PrelBase</literal>, so that an importing module will &ldquo;see&rdquo; the <literal>(:)</literal>, and can
match it on the LHS of a rule.  <literal>INLINE</literal> prevents any inlining happening
in the RHS of the <literal>INLINE</literal> thing.  I regret the delicacy of this.

</para>
</listitem>
<listitem>

<para>
 In <filename>libraries/base/GHC/Base.lhs</filename> look at the rules for <function>map</function> to
see how to write rules that will do fusion and yet give an efficient
program even if fusion doesn't happen.  More rules in <filename>GHC/List.lhs</filename>.
</para>
</listitem>

</itemizedlist>

</para>

</sect2>

<sect2 id="core-pragma">
  <title>CORE pragma</title>

  <indexterm><primary>CORE pragma</primary></indexterm>
  <indexterm><primary>pragma, CORE</primary></indexterm>
  <indexterm><primary>core, annotation</primary></indexterm>

<para>
  The external core format supports <quote>Note</quote> annotations;
  the <literal>CORE</literal> pragma gives a way to specify what these
  should be in your Haskell source code.  Syntactically, core
  annotations are attached to expressions and take a Haskell string
  literal as an argument.  The following function definition shows an
  example:

<programlisting>
f x = ({-# CORE "foo" #-} show) ({-# CORE "bar" #-} x)
</programlisting>

  Semantically, this is equivalent to:

<programlisting>
g x = show x
</programlisting>
</para>

<para>
  However, when external core is generated (via
  <option>-fext-core</option>), there will be Notes attached to the
  expressions <function>show</function> and <varname>x</varname>.
  The core function declaration for <function>f</function> is:
</para>

<programlisting>
  f :: %forall a . GHCziShow.ZCTShow a ->
                   a -> GHCziBase.ZMZN GHCziBase.Char =
    \ @ a (zddShow::GHCziShow.ZCTShow a) (eta::a) ->
        (%note "foo"
         %case zddShow %of (tpl::GHCziShow.ZCTShow a)
           {GHCziShow.ZCDShow
            (tpl1::GHCziBase.Int ->
                   a ->
                   GHCziBase.ZMZN GHCziBase.Char -> GHCziBase.ZMZN GHCziBase.Cha
r)
            (tpl2::a -> GHCziBase.ZMZN GHCziBase.Char)
            (tpl3::GHCziBase.ZMZN a ->
                   GHCziBase.ZMZN GHCziBase.Char -> GHCziBase.ZMZN GHCziBase.Cha
r) ->
              tpl2})
        (%note "bar"
         eta);
</programlisting>

<para>
  Here, we can see that the function <function>show</function> (which
  has been expanded out to a case expression over the Show dictionary)
  has a <literal>%note</literal> attached to it, as does the
  expression <varname>eta</varname> (which used to be called
  <varname>x</varname>).
</para>

</sect2>

</sect1>

<sect1 id="special-ids">
<title>Special built-in functions</title>
<para>GHC has a few built-in functions with special behaviour.  These
are now described in the module <ulink
url="&libraryGhcPrimLocation;/GHC-Prim.html"><literal>GHC.Prim</literal></ulink>
in the library documentation.
In particular:
<itemizedlist>
<listitem><para>
<ulink url="&libraryGhcPrimLocation;/GHC-Prim.html#v%3Ainline"><literal>inline</literal></ulink>
allows control over inlining on a per-call-site basis.
</para></listitem>
<listitem><para>
<ulink url="&libraryGhcPrimLocation;/GHC-Prim.html#v%3Alazy"><literal>lazy</literal></ulink>
restrains the strictness analyser.
</para></listitem>
<listitem><para>
<ulink url="&libraryGhcPrimLocation;/GHC-Prim.html#v%3AunsafeCoerce%23"><literal>unsafeCoerce#</literal></ulink>
allows you to fool the type checker.
</para></listitem>
</itemizedlist>
</para>
</sect1>


<sect1 id="generic-classes">
<title>Generic classes</title>

<para>
GHC used to have an implementation of generic classes as defined in the paper
"Derivable type classes", Ralf Hinze and Simon Peyton Jones, Haskell Workshop,
Montreal Sept 2000, pp94-105. These have been removed and replaced by the more
general <link linkend="generic-programming">support for generic programming</link>.
</para>

</sect1>


<sect1 id="generic-programming">
<title>Generic programming</title>

<para>
Using a combination of <option>-XDeriveGeneric</option>
(<xref linkend="deriving-typeable"/>) and
<option>-XDefaultSignatures</option> (<xref linkend="class-default-signatures"/>),
you can easily do datatype-generic
programming using the <literal>GHC.Generics</literal> framework. This section
gives a very brief overview of how to do it.
</para>

<para>
Generic programming support in GHC allows defining classes with methods that
do not need a user specification when instantiating: the method body is
automatically derived by GHC. This is similar to what happens for standard
classes such as <literal>Read</literal> and <literal>Show</literal>, for
instance, but now for user-defined classes.
</para>

<sect2>
<title>Deriving representations</title>

<para>
The first thing we need is generic representations. The
<literal>GHC.Generics</literal> module defines a couple of primitive types
that are used to represent Haskell datatypes:

<programlisting>
-- | Unit: used for constructors without arguments
data U1 p = U1

-- | Constants, additional parameters and recursion of kind *
newtype K1 i c p = K1 { unK1 :: c }

-- | Meta-information (constructor names, etc.)
newtype M1 i c f p = M1 { unM1 :: f p }

-- | Sums: encode choice between constructors
infixr 5 :+:
data (:+:) f g p = L1 (f p) | R1 (g p)

-- | Products: encode multiple arguments to constructors
infixr 6 :*:
data (:*:) f g p = f p :*: g p
</programlisting>
</para>

<para>
The <literal>Generic</literal> class mediates between user-defined datatypes
and their internal representation as a sum-of-products:

<programlisting>
class Generic a where
  -- Encode the representation of a user datatype
  type Rep a :: * -> *
  -- Convert from the datatype to its representation
  from  :: a -> (Rep a) x
  -- Convert from the representation to the datatype
  to    :: (Rep a) x -> a
</programlisting>

Instances of this class can be derived by GHC with the
<option>-XDeriveGeneric</option> (<xref linkend="deriving-typeable"/>), and are
necessary to be able to define generic instances automatically.
</para>

<para>
For example, a user-defined datatype of trees <literal>data UserTree a = Node a
(UserTree a) (UserTree a) | Leaf</literal> gets the following representation:

<programlisting>
instance Generic (UserTree a) where
  -- Representation type
  type Rep (UserTree a) =
    M1 D D1UserTree (
          M1 C C1_0UserTree (
                M1 S NoSelector (K1 P a)
            :*: M1 S NoSelector (K1 R (UserTree a))
            :*: M1 S NoSelector (K1 R (UserTree a)))
      :+: M1 C C1_1UserTree U1)

  -- Conversion functions
  from (Node x l r) = M1 (L1 (M1 (M1 (K1 x) :*: M1 (K1 l) :*: M1 (K1 r))))
  from Leaf         = M1 (R1 (M1 U1))
  to (M1 (L1 (M1 (M1 (K1 x) :*: M1 (K1 l) :*: M1 (K1 r))))) = Node x l r
  to (M1 (R1 (M1 U1)))                                      = Leaf

-- Meta-information
data D1UserTree
data C1_0UserTree
data C1_1UserTree

instance Datatype D1UserTree where
  datatypeName _ = "UserTree"
  moduleName _   = "Main"

instance Constructor C1_0UserTree where
  conName _ = "Node"

instance Constructor C1_1UserTree where
  conName _ = "Leaf"
</programlisting>

This representation is generated automatically if a
<literal>deriving Generic</literal> clause is attached to the datatype.
<link linkend="stand-alone-deriving">Standalone deriving</link> can also be
used.
</para>

</sect2>

<sect2>
<title>Writing generic functions</title>

<para>
A generic function is defined by creating a class and giving instances for
each of the representation types of <literal>GHC.Generics</literal>. As an
example we show generic serialization:
<programlisting>
data Bin = O | I

class GSerialize f where
  gput :: f a -> [Bin]

instance GSerialize U1 where
  gput U1 = []

instance (GSerialize a, GSerialize b) => GSerialize (a :*: b) where
  gput (x :*: y) = gput x ++ gput y

instance (GSerialize a, GSerialize b) => GSerialize (a :+: b) where
  gput (L1 x) = O : gput x
  gput (R1 x) = I : gput x

instance (GSerialize a) => GSerialize (M1 i c a) where
  gput (M1 x) = gput x

instance (Serialize a) => GSerialize (K1 i a) where
  gput (K1 x) = put x
</programlisting>

Typically this class will not be exported, as it only makes sense to have
instances for the representation types.
</para>
</sect2>

<sect2>
<title>Generic defaults</title>

<para>
The only thing left to do now is to define a "front-end" class, which is
exposed to the user:
<programlisting>
class Serialize a where
  put :: a -> [Bin]

  default put :: (Generic a, GSerialize (Rep a)) => a -> [Bit]
  put = gput . from
</programlisting>
Here we use a <link linkend="class-default-signatures">default signature</link>
to specify that the user does not have to provide an implementation for
<literal>put</literal>, as long as there is a <literal>Generic</literal>
instance for the type to instantiate. For the <literal>UserTree</literal> type,
for instance, the user can just write:

<programlisting>
instance (Serialize a) => Serialize (UserTree a)
</programlisting>

The default method for <literal>put</literal> is then used, corresponding to the
generic implementation of serialization.
</para>
</sect2>


<sect2>
<title>More information</title>

<para>
For more detail please refer to the
<ulink url="http://www.haskell.org/haskellwiki/Generics">HaskellWiki page</ulink>
or the original paper:
</para>

<itemizedlist>
<listitem>
<para>
Jose Pedro Magalhaes, Atze Dijkstra, Johan Jeuring, and Andres Loeh.
<ulink url="http://dreixel.net/research/pdf/gdmh.pdf">
  A generic deriving mechanism for Haskell</ulink>.
<citetitle>Proceedings of the third ACM Haskell symposium on Haskell</citetitle>
(Haskell'2010), pp. 37-48, ACM, 2010.
</para>
</listitem>
</itemizedlist>

<emphasis>Note</emphasis>: the current support for generic programming in GHC
is preliminary. In particular, we only allow deriving instances for the
<literal>Generic</literal> class. Support for deriving
<literal>Generic1</literal> (and thus enabling generic functions of kind
<literal>* -> *</literal> such as <literal>fmap</literal>) will come at a
later stage.
</sect2>

</sect1>


<sect1 id="monomorphism">
<title>Control over monomorphism</title>

<para>GHC supports two flags that control the way in which generalisation is
carried out at let and where bindings.
</para>

<sect2>
<title>Switching off the dreaded Monomorphism Restriction</title>
          <indexterm><primary><option>-XNoMonomorphismRestriction</option></primary></indexterm>

<para>Haskell's monomorphism restriction (see
<ulink url="http://www.haskell.org/onlinereport/decls.html#sect4.5.5">Section
4.5.5</ulink>
of the Haskell Report)
can be completely switched off by
<option>-XNoMonomorphismRestriction</option>.
</para>
</sect2>

<sect2>
<title>Monomorphic pattern bindings</title>
          <indexterm><primary><option>-XNoMonoPatBinds</option></primary></indexterm>
          <indexterm><primary><option>-XMonoPatBinds</option></primary></indexterm>

	  <para> As an experimental change, we are exploring the possibility of
	  making pattern bindings monomorphic; that is, not generalised at all.
	    A pattern binding is a binding whose LHS has no function arguments,
	    and is not a simple variable.  For example:
<programlisting>
  f x = x                    -- Not a pattern binding
  f = \x -> x                -- Not a pattern binding
  f :: Int -> Int = \x -> x  -- Not a pattern binding

  (g,h) = e                  -- A pattern binding
  (f) = e                    -- A pattern binding
  [x] = e                    -- A pattern binding
</programlisting>
Experimentally, GHC now makes pattern bindings monomorphic <emphasis>by
default</emphasis>.  Use <option>-XNoMonoPatBinds</option> to recover the
standard behaviour.
</para>
</sect2>
</sect1>


<!-- Emacs stuff:
     ;;; Local Variables: ***
     ;;; sgml-parent-document: ("users_guide.xml" "book" "chapter" "sect1") ***
     ;;; ispell-local-dictionary: "british" ***
     ;;; End: ***
 -->

